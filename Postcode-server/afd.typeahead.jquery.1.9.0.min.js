(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('jquery')) :
	typeof define === 'function' && define.amd ? define(['jquery'], factory) :
	(factory(global.$));
}(this, (function (jQuery) { 'use strict';

	jQuery = jQuery && jQuery.hasOwnProperty('default') ? jQuery['default'] : jQuery;

	var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	var _global = createCommonjsModule(function (module) {
	// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
	var global = module.exports = typeof window != 'undefined' && window.Math == Math
	  ? window : typeof self != 'undefined' && self.Math == Math ? self
	  // eslint-disable-next-line no-new-func
	  : Function('return this')();
	if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef
	});

	var _core = createCommonjsModule(function (module) {
	var core = module.exports = { version: '2.5.7' };
	if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef
	});
	var _core_1 = _core.version;

	var _isObject = function (it) {
	  return typeof it === 'object' ? it !== null : typeof it === 'function';
	};

	var _anObject = function (it) {
	  if (!_isObject(it)) throw TypeError(it + ' is not an object!');
	  return it;
	};

	var _fails = function (exec) {
	  try {
	    return !!exec();
	  } catch (e) {
	    return true;
	  }
	};

	// Thank's IE8 for his funny defineProperty
	var _descriptors = !_fails(function () {
	  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
	});

	var document$1 = _global.document;
	// typeof document.createElement is 'object' in old IE
	var is = _isObject(document$1) && _isObject(document$1.createElement);
	var _domCreate = function (it) {
	  return is ? document$1.createElement(it) : {};
	};

	var _ie8DomDefine = !_descriptors && !_fails(function () {
	  return Object.defineProperty(_domCreate('div'), 'a', { get: function () { return 7; } }).a != 7;
	});

	// 7.1.1 ToPrimitive(input [, PreferredType])

	// instead of the ES6 spec version, we didn't implement @@toPrimitive case
	// and the second argument - flag - preferred type is a string
	var _toPrimitive = function (it, S) {
	  if (!_isObject(it)) return it;
	  var fn, val;
	  if (S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) return val;
	  if (typeof (fn = it.valueOf) == 'function' && !_isObject(val = fn.call(it))) return val;
	  if (!S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) return val;
	  throw TypeError("Can't convert object to primitive value");
	};

	var dP = Object.defineProperty;

	var f = _descriptors ? Object.defineProperty : function defineProperty(O, P, Attributes) {
	  _anObject(O);
	  P = _toPrimitive(P, true);
	  _anObject(Attributes);
	  if (_ie8DomDefine) try {
	    return dP(O, P, Attributes);
	  } catch (e) { /* empty */ }
	  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
	  if ('value' in Attributes) O[P] = Attributes.value;
	  return O;
	};

	var _objectDp = {
		f: f
	};

	var _propertyDesc = function (bitmap, value) {
	  return {
	    enumerable: !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable: !(bitmap & 4),
	    value: value
	  };
	};

	var _hide = _descriptors ? function (object, key, value) {
	  return _objectDp.f(object, key, _propertyDesc(1, value));
	} : function (object, key, value) {
	  object[key] = value;
	  return object;
	};

	var hasOwnProperty = {}.hasOwnProperty;
	var _has = function (it, key) {
	  return hasOwnProperty.call(it, key);
	};

	var id = 0;
	var px = Math.random();
	var _uid = function (key) {
	  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
	};

	var _redefine = createCommonjsModule(function (module) {
	var SRC = _uid('src');
	var TO_STRING = 'toString';
	var $toString = Function[TO_STRING];
	var TPL = ('' + $toString).split(TO_STRING);

	_core.inspectSource = function (it) {
	  return $toString.call(it);
	};

	(module.exports = function (O, key, val, safe) {
	  var isFunction = typeof val == 'function';
	  if (isFunction) _has(val, 'name') || _hide(val, 'name', key);
	  if (O[key] === val) return;
	  if (isFunction) _has(val, SRC) || _hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
	  if (O === _global) {
	    O[key] = val;
	  } else if (!safe) {
	    delete O[key];
	    _hide(O, key, val);
	  } else if (O[key]) {
	    O[key] = val;
	  } else {
	    _hide(O, key, val);
	  }
	// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
	})(Function.prototype, TO_STRING, function toString() {
	  return typeof this == 'function' && this[SRC] || $toString.call(this);
	});
	});

	var _aFunction = function (it) {
	  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
	  return it;
	};

	// optional / simple context binding

	var _ctx = function (fn, that, length) {
	  _aFunction(fn);
	  if (that === undefined) return fn;
	  switch (length) {
	    case 1: return function (a) {
	      return fn.call(that, a);
	    };
	    case 2: return function (a, b) {
	      return fn.call(that, a, b);
	    };
	    case 3: return function (a, b, c) {
	      return fn.call(that, a, b, c);
	    };
	  }
	  return function (/* ...args */) {
	    return fn.apply(that, arguments);
	  };
	};

	var PROTOTYPE = 'prototype';

	var $export = function (type, name, source) {
	  var IS_FORCED = type & $export.F;
	  var IS_GLOBAL = type & $export.G;
	  var IS_STATIC = type & $export.S;
	  var IS_PROTO = type & $export.P;
	  var IS_BIND = type & $export.B;
	  var target = IS_GLOBAL ? _global : IS_STATIC ? _global[name] || (_global[name] = {}) : (_global[name] || {})[PROTOTYPE];
	  var exports = IS_GLOBAL ? _core : _core[name] || (_core[name] = {});
	  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
	  var key, own, out, exp;
	  if (IS_GLOBAL) source = name;
	  for (key in source) {
	    // contains in native
	    own = !IS_FORCED && target && target[key] !== undefined;
	    // export native or passed
	    out = (own ? target : source)[key];
	    // bind timers to global for call from export context
	    exp = IS_BIND && own ? _ctx(out, _global) : IS_PROTO && typeof out == 'function' ? _ctx(Function.call, out) : out;
	    // extend global
	    if (target) _redefine(target, key, out, type & $export.U);
	    // export
	    if (exports[key] != out) _hide(exports, key, exp);
	    if (IS_PROTO && expProto[key] != out) expProto[key] = out;
	  }
	};
	_global.core = _core;
	// type bitmap
	$export.F = 1;   // forced
	$export.G = 2;   // global
	$export.S = 4;   // static
	$export.P = 8;   // proto
	$export.B = 16;  // bind
	$export.W = 32;  // wrap
	$export.U = 64;  // safe
	$export.R = 128; // real proto method for `library`
	var _export = $export;

	var toString = {}.toString;

	var _cof = function (it) {
	  return toString.call(it).slice(8, -1);
	};

	// fallback for non-array-like ES3 and non-enumerable old V8 strings

	// eslint-disable-next-line no-prototype-builtins
	var _iobject = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
	  return _cof(it) == 'String' ? it.split('') : Object(it);
	};

	// 7.2.1 RequireObjectCoercible(argument)
	var _defined = function (it) {
	  if (it == undefined) throw TypeError("Can't call method on  " + it);
	  return it;
	};

	// 7.1.13 ToObject(argument)

	var _toObject = function (it) {
	  return Object(_defined(it));
	};

	// 7.1.4 ToInteger
	var ceil = Math.ceil;
	var floor = Math.floor;
	var _toInteger = function (it) {
	  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
	};

	// 7.1.15 ToLength

	var min = Math.min;
	var _toLength = function (it) {
	  return it > 0 ? min(_toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
	};

	// 7.2.2 IsArray(argument)

	var _isArray = Array.isArray || function isArray(arg) {
	  return _cof(arg) == 'Array';
	};

	var _library = false;

	var _shared = createCommonjsModule(function (module) {
	var SHARED = '__core-js_shared__';
	var store = _global[SHARED] || (_global[SHARED] = {});

	(module.exports = function (key, value) {
	  return store[key] || (store[key] = value !== undefined ? value : {});
	})('versions', []).push({
	  version: _core.version,
	  mode: 'global',
	  copyright: 'Â© 2018 Denis Pushkarev (zloirock.ru)'
	});
	});

	var _wks = createCommonjsModule(function (module) {
	var store = _shared('wks');

	var Symbol = _global.Symbol;
	var USE_SYMBOL = typeof Symbol == 'function';

	var $exports = module.exports = function (name) {
	  return store[name] || (store[name] =
	    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : _uid)('Symbol.' + name));
	};

	$exports.store = store;
	});

	var SPECIES = _wks('species');

	var _arraySpeciesConstructor = function (original) {
	  var C;
	  if (_isArray(original)) {
	    C = original.constructor;
	    // cross-realm fallback
	    if (typeof C == 'function' && (C === Array || _isArray(C.prototype))) C = undefined;
	    if (_isObject(C)) {
	      C = C[SPECIES];
	      if (C === null) C = undefined;
	    }
	  } return C === undefined ? Array : C;
	};

	// 9.4.2.3 ArraySpeciesCreate(originalArray, length)


	var _arraySpeciesCreate = function (original, length) {
	  return new (_arraySpeciesConstructor(original))(length);
	};

	// 0 -> Array#forEach
	// 1 -> Array#map
	// 2 -> Array#filter
	// 3 -> Array#some
	// 4 -> Array#every
	// 5 -> Array#find
	// 6 -> Array#findIndex





	var _arrayMethods = function (TYPE, $create) {
	  var IS_MAP = TYPE == 1;
	  var IS_FILTER = TYPE == 2;
	  var IS_SOME = TYPE == 3;
	  var IS_EVERY = TYPE == 4;
	  var IS_FIND_INDEX = TYPE == 6;
	  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
	  var create = $create || _arraySpeciesCreate;
	  return function ($this, callbackfn, that) {
	    var O = _toObject($this);
	    var self = _iobject(O);
	    var f = _ctx(callbackfn, that, 3);
	    var length = _toLength(self.length);
	    var index = 0;
	    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
	    var val, res;
	    for (;length > index; index++) if (NO_HOLES || index in self) {
	      val = self[index];
	      res = f(val, index, O);
	      if (TYPE) {
	        if (IS_MAP) result[index] = res;   // map
	        else if (res) switch (TYPE) {
	          case 3: return true;             // some
	          case 5: return val;              // find
	          case 6: return index;            // findIndex
	          case 2: result.push(val);        // filter
	        } else if (IS_EVERY) return false; // every
	      }
	    }
	    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
	  };
	};

	// 22.1.3.31 Array.prototype[@@unscopables]
	var UNSCOPABLES = _wks('unscopables');
	var ArrayProto = Array.prototype;
	if (ArrayProto[UNSCOPABLES] == undefined) _hide(ArrayProto, UNSCOPABLES, {});
	var _addToUnscopables = function (key) {
	  ArrayProto[UNSCOPABLES][key] = true;
	};

	// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)

	var $find = _arrayMethods(5);
	var KEY = 'find';
	var forced = true;
	// Shouldn't skip holes
	if (KEY in []) Array(1)[KEY](function () { forced = false; });
	_export(_export.P + _export.F * forced, 'Array', {
	  find: function find(callbackfn /* , that = undefined */) {
	    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});
	_addToUnscopables(KEY);

	var defaults = {
	  pceUrl: '//pce.afd.co.uk/afddata.pce',
	  nativeValidationMessages: false,
	  defaultCountry: null,
	  afdc: 0,
	  phone: {
	    defaultDialingCode: '+44',
	    invalidPhoneNumberMessage: 'Please input a valid phone number',
	    loadingSpinner: null,
	    countryControl: null,
	    countryControlConverter: null
	  },
	  email: {
	    invalidEmailMessage: 'Please input a valid email address',
	    loadingSpinner: null
	  },
	  card: {
	    invalidCardNumberMessage: 'Please input a valid card number',
	    invalidCardOrExpiryMessage: 'Either the card number or expiry date are not valid',
	    invalidExpiryMonthMessage: 'Please input a valid month',
	    invalidExpiryDateMessage: 'Please input a valid expiry date',
	    loadingSpinner: null,
	    logoHeight: 16,
	    logoWidth: 24
	  },
	  account: {
	    invalidAccountNumberMessage: 'Please input a valid account number',
	    invalidSortCodeMessage: 'Please input a valid Sort Code',
	    loadingSpinner: null
	  },
	  typeahead: {
	    maxItems: 5,
	    pushUp: false,
	    afterHideTypeahead: false,
	    searchAgain: true,
	    afterClearTypeahead: true,
	    beforeHideResults: false,
	    parentClass: null,
	    fieldSets: [],
	    manualInputButton: false,
	    fewResultsManualInput: true,
	    fewResultsManualInputText: 'Can\'t see your address? Enter it manually',
	    notEmptyShowResults: false,
	    hideEmpties: false,
	    containers: ['#old_address','#new_address'],
	    retrieveFields: 'standard',
	    availableCountries: [],
	    minLength: 2,
	    matchPositions: false,
	    postcodeFirst: true,
	    hideForCountries: [],
	    showForCountries: [],
	    containerOnlyContainsControl: false,
	    regionMap: null,
	    regionAttribute: 'value'
	  },
	  lookup: {
	    prefetch: true,
	    pushUp: false,
	    beforeHideResults: false,
	    parentClass: null,
	    fieldSets: [],
	    manualInputButton: false,
	    hideEmpties: false,
	    afterRetrieveHideResultsList: true,
	    postcodeIsLookup: false,
	    resultsContainer: '',
	    containers: [],
	    retrieveFields: 'standard',
	    availableCountries: [],
	    postcodeFirst: true,
	    hideForCountries: [],
	    showForCountries: [],
	    regionMap: null,
	    regionAttribute: 'value'
	  },
	  country: {
	    defaultCountry: null,
	    availableCountries: [],
	    customCountryControl: null,
	    customCountryConverter: null
	  },
	  reverseGeocode: {
	    maxItems: 100,
	    pushUp: false,
	    fieldSets: [],
	    hideEmpties: false,
	    afterRetrieveHideResultsList: true,
	    containers: [],
	    retrieveFields: 'standard',
	    postcodeFirst: true,
	    hideForCountries: [],
	    showForCountries: ['GBR'],
	    linkedControl: 'typeahead',
	    hideOnDesktop: false,
	    buttonContainer: null
	  }
	};

	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	}

	var classCallCheck = _classCallCheck;

	var _typeof_1 = createCommonjsModule(function (module) {
	function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

	function _typeof(obj) {
	  if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
	    module.exports = _typeof = function _typeof(obj) {
	      return _typeof2(obj);
	    };
	  } else {
	    module.exports = _typeof = function _typeof(obj) {
	      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
	    };
	  }

	  return _typeof(obj);
	}

	module.exports = _typeof;
	});

	function _assertThisInitialized(self) {
	  if (self === void 0) {
	    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	  }

	  return self;
	}

	var assertThisInitialized = _assertThisInitialized;

	function _possibleConstructorReturn(self, call) {
	  if (call && (_typeof_1(call) === "object" || typeof call === "function")) {
	    return call;
	  }

	  return assertThisInitialized(self);
	}

	var possibleConstructorReturn = _possibleConstructorReturn;

	var getPrototypeOf = createCommonjsModule(function (module) {
	function _getPrototypeOf(o) {
	  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
	    return o.__proto__ || Object.getPrototypeOf(o);
	  };
	  return _getPrototypeOf(o);
	}

	module.exports = _getPrototypeOf;
	});

	var setPrototypeOf = createCommonjsModule(function (module) {
	function _setPrototypeOf(o, p) {
	  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
	    o.__proto__ = p;
	    return o;
	  };

	  return _setPrototypeOf(o, p);
	}

	module.exports = _setPrototypeOf;
	});

	function _inherits(subClass, superClass) {
	  if (typeof superClass !== "function" && superClass !== null) {
	    throw new TypeError("Super expression must either be null or a function");
	  }

	  subClass.prototype = Object.create(superClass && superClass.prototype, {
	    constructor: {
	      value: subClass,
	      writable: true,
	      configurable: true
	    }
	  });
	  if (superClass) setPrototypeOf(subClass, superClass);
	}

	var inherits = _inherits;

	function _defineProperty(obj, key, value) {
	  if (key in obj) {
	    Object.defineProperty(obj, key, {
	      value: value,
	      enumerable: true,
	      configurable: true,
	      writable: true
	    });
	  } else {
	    obj[key] = value;
	  }

	  return obj;
	}

	var defineProperty = _defineProperty;

	var AfdControl = function AfdControl($el, options) {
	  var _this = this;

	  classCallCheck(this, AfdControl);

	  defineProperty(this, "setupParams", function (requestOptions) {
	    var defaultData = {
	      format: 'json'
	    };

	    if (_this.options.serial && _this.options.password) {
	      defaultData.serial = _this.options.serial;
	      defaultData.password = _this.options.password;
	    } else if (_this.options.token && _this.options.id) {
	      defaultData.token = _this.options.token;
	      defaultData.id = _this.options.id;
	    } else {
	      throw 'You must either supply password and serial, or token and id';
	    } // reverseGeocode should not have a country ISO set


	    if (_this.controlType !== 'reverseGeocode') {
	      // check to see if default country
	      if (_this.options.defaultCountry) {
	        defaultData.countryiso = _this.options.defaultCountry;
	      }

	      if (_this.options.country.defaultCountry) {
	        defaultData.countryiso = _this.options.country.defaultCountry;
	      } // Check to see if there is a country control, if so WA will be activated


	      var $countryField = $('[data-afd-control="country"]');

	      if ($countryField.length > 0) {
	        defaultData.countryiso = $countryField.val();
	      } // checks to see if there is a custom country control and whether or not a function is supplied to turn the value into ISO3


	      if (_this.options.country.customCountryControl) {
	        var customCountryControl = $(_this.options.country.customCountryControl);

	        if (_this.options.country.customCountryConverter) {
	          if (typeof _this.options.country.customCountryConverter !== 'function') {
	            throw 'customCountryConverter Must be a function';
	          }

	          defaultData.countryiso = _this.options.country.customCountryConverter(customCountryControl.val());
	        } else {
	          defaultData.countryiso = customCountryControl.val();
	        }
	      }
	    }

	    try {
	      return {
	        method: 'GET',
	        url: _this.options.pceUrl,
	        error: function error(err, errText, errThrown) {
	          console.log(err);
	          console.log(errText);
	          console.log(errThrown);
	          $(document).trigger('afd:pceError', err);
	        },
	        data: $.extend(true, {}, defaultData, requestOptions),
	        // callback and beforesend are only applicable when the request sequence module is used
	        callback: typeof _this.requestCallback !== 'undefined' ? {
	          done: _this.requestCallback
	        } : null,
	        beforeSend: typeof _this.beforeSend !== 'undefined' ? _this.beforeSend : null
	      };
	    } catch (err) {
	      console.error('Error setting up request');
	      console.error(err);
	    }
	  });

	  defineProperty(this, "eventHandler", function ($element, event, handler) {
	    $element.off(event + '.afd').on(event + '.afd', handler);
	  });

	  this.$element = $el;
	  this.element = $el.get()[0];

	  if (typeof $el.data('afd-additional-options') !== 'undefined') {
	    var customOptions = window[$el.data('afd-additional-options')];
	    this.options = $.extend(true, {}, options, customOptions);
	  } else {
	    this.options = options;
	  }
	};

	function _arrayWithHoles(arr) {
	  if (Array.isArray(arr)) return arr;
	}

	var arrayWithHoles = _arrayWithHoles;

	function _iterableToArrayLimit(arr, i) {
	  var _arr = [];
	  var _n = true;
	  var _d = false;
	  var _e = undefined;

	  try {
	    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
	      _arr.push(_s.value);

	      if (i && _arr.length === i) break;
	    }
	  } catch (err) {
	    _d = true;
	    _e = err;
	  } finally {
	    try {
	      if (!_n && _i["return"] != null) _i["return"]();
	    } finally {
	      if (_d) throw _e;
	    }
	  }

	  return _arr;
	}

	var iterableToArrayLimit = _iterableToArrayLimit;

	function _nonIterableRest() {
	  throw new TypeError("Invalid attempt to destructure non-iterable instance");
	}

	var nonIterableRest = _nonIterableRest;

	function _slicedToArray(arr, i) {
	  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || nonIterableRest();
	}

	var slicedToArray = _slicedToArray;

	// 21.2.5.3 get RegExp.prototype.flags

	var _flags = function () {
	  var that = _anObject(this);
	  var result = '';
	  if (that.global) result += 'g';
	  if (that.ignoreCase) result += 'i';
	  if (that.multiline) result += 'm';
	  if (that.unicode) result += 'u';
	  if (that.sticky) result += 'y';
	  return result;
	};

	// 21.2.5.3 get RegExp.prototype.flags()
	if (_descriptors && /./g.flags != 'g') _objectDp.f(RegExp.prototype, 'flags', {
	  configurable: true,
	  get: _flags
	});

	var TO_STRING = 'toString';
	var $toString = /./[TO_STRING];

	var define = function (fn) {
	  _redefine(RegExp.prototype, TO_STRING, fn, true);
	};

	// 21.2.5.14 RegExp.prototype.toString()
	if (_fails(function () { return $toString.call({ source: 'a', flags: 'b' }) != '/a/b'; })) {
	  define(function toString() {
	    var R = _anObject(this);
	    return '/'.concat(R.source, '/',
	      'flags' in R ? R.flags : !_descriptors && R instanceof RegExp ? _flags.call(R) : undefined);
	  });
	// FF44- RegExp#toString has a wrong name
	} else if ($toString.name != TO_STRING) {
	  define(function toString() {
	    return $toString.call(this);
	  });
	}

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$1 = objectProto.hasOwnProperty;

	/**
	 * The base implementation of `_.has` without support for deep paths.
	 *
	 * @private
	 * @param {Object} [object] The object to query.
	 * @param {Array|string} key The key to check.
	 * @returns {boolean} Returns `true` if `key` exists, else `false`.
	 */
	function baseHas(object, key) {
	  return object != null && hasOwnProperty$1.call(object, key);
	}

	var _baseHas = baseHas;

	/**
	 * Checks if `value` is classified as an `Array` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
	 * @example
	 *
	 * _.isArray([1, 2, 3]);
	 * // => true
	 *
	 * _.isArray(document.body.children);
	 * // => false
	 *
	 * _.isArray('abc');
	 * // => false
	 *
	 * _.isArray(_.noop);
	 * // => false
	 */
	var isArray = Array.isArray;

	var isArray_1 = isArray;

	/** Detect free variable `global` from Node.js. */
	var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

	var _freeGlobal = freeGlobal;

	/** Detect free variable `self`. */
	var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

	/** Used as a reference to the global object. */
	var root = _freeGlobal || freeSelf || Function('return this')();

	var _root = root;

	/** Built-in value references. */
	var Symbol$1 = _root.Symbol;

	var _Symbol = Symbol$1;

	/** Used for built-in method references. */
	var objectProto$1 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$2 = objectProto$1.hasOwnProperty;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString = objectProto$1.toString;

	/** Built-in value references. */
	var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;

	/**
	 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the raw `toStringTag`.
	 */
	function getRawTag(value) {
	  var isOwn = hasOwnProperty$2.call(value, symToStringTag),
	      tag = value[symToStringTag];

	  try {
	    value[symToStringTag] = undefined;
	  } catch (e) {}

	  var result = nativeObjectToString.call(value);
	  {
	    if (isOwn) {
	      value[symToStringTag] = tag;
	    } else {
	      delete value[symToStringTag];
	    }
	  }
	  return result;
	}

	var _getRawTag = getRawTag;

	/** Used for built-in method references. */
	var objectProto$2 = Object.prototype;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString$1 = objectProto$2.toString;

	/**
	 * Converts `value` to a string using `Object.prototype.toString`.
	 *
	 * @private
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 */
	function objectToString(value) {
	  return nativeObjectToString$1.call(value);
	}

	var _objectToString = objectToString;

	/** `Object#toString` result references. */
	var nullTag = '[object Null]',
	    undefinedTag = '[object Undefined]';

	/** Built-in value references. */
	var symToStringTag$1 = _Symbol ? _Symbol.toStringTag : undefined;

	/**
	 * The base implementation of `getTag` without fallbacks for buggy environments.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	function baseGetTag(value) {
	  if (value == null) {
	    return value === undefined ? undefinedTag : nullTag;
	  }
	  return (symToStringTag$1 && symToStringTag$1 in Object(value))
	    ? _getRawTag(value)
	    : _objectToString(value);
	}

	var _baseGetTag = baseGetTag;

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return value != null && typeof value == 'object';
	}

	var isObjectLike_1 = isObjectLike;

	/** `Object#toString` result references. */
	var symbolTag = '[object Symbol]';

	/**
	 * Checks if `value` is classified as a `Symbol` primitive or object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
	 * @example
	 *
	 * _.isSymbol(Symbol.iterator);
	 * // => true
	 *
	 * _.isSymbol('abc');
	 * // => false
	 */
	function isSymbol(value) {
	  return typeof value == 'symbol' ||
	    (isObjectLike_1(value) && _baseGetTag(value) == symbolTag);
	}

	var isSymbol_1 = isSymbol;

	/** Used to match property names within property paths. */
	var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
	    reIsPlainProp = /^\w*$/;

	/**
	 * Checks if `value` is a property name and not a property path.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {Object} [object] The object to query keys on.
	 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
	 */
	function isKey(value, object) {
	  if (isArray_1(value)) {
	    return false;
	  }
	  var type = typeof value;
	  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
	      value == null || isSymbol_1(value)) {
	    return true;
	  }
	  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
	    (object != null && value in Object(object));
	}

	var _isKey = isKey;

	/**
	 * Checks if `value` is the
	 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */
	function isObject(value) {
	  var type = typeof value;
	  return value != null && (type == 'object' || type == 'function');
	}

	var isObject_1 = isObject;

	/** `Object#toString` result references. */
	var asyncTag = '[object AsyncFunction]',
	    funcTag = '[object Function]',
	    genTag = '[object GeneratorFunction]',
	    proxyTag = '[object Proxy]';

	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction(value) {
	  if (!isObject_1(value)) {
	    return false;
	  }
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in Safari 9 which returns 'object' for typed arrays and other constructors.
	  var tag = _baseGetTag(value);
	  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
	}

	var isFunction_1 = isFunction;

	/** Used to detect overreaching core-js shims. */
	var coreJsData = _root['__core-js_shared__'];

	var _coreJsData = coreJsData;

	/** Used to detect methods masquerading as native. */
	var maskSrcKey = (function() {
	  var uid = /[^.]+$/.exec(_coreJsData && _coreJsData.keys && _coreJsData.keys.IE_PROTO || '');
	  return uid ? ('Symbol(src)_1.' + uid) : '';
	}());

	/**
	 * Checks if `func` has its source masked.
	 *
	 * @private
	 * @param {Function} func The function to check.
	 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
	 */
	function isMasked(func) {
	  return !!maskSrcKey && (maskSrcKey in func);
	}

	var _isMasked = isMasked;

	/** Used for built-in method references. */
	var funcProto = Function.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;

	/**
	 * Converts `func` to its source code.
	 *
	 * @private
	 * @param {Function} func The function to convert.
	 * @returns {string} Returns the source code.
	 */
	function toSource(func) {
	  if (func != null) {
	    try {
	      return funcToString.call(func);
	    } catch (e) {}
	    try {
	      return (func + '');
	    } catch (e) {}
	  }
	  return '';
	}

	var _toSource = toSource;

	/**
	 * Used to match `RegExp`
	 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
	 */
	var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

	/** Used to detect host constructors (Safari). */
	var reIsHostCtor = /^\[object .+?Constructor\]$/;

	/** Used for built-in method references. */
	var funcProto$1 = Function.prototype,
	    objectProto$3 = Object.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString$1 = funcProto$1.toString;

	/** Used to check objects for own properties. */
	var hasOwnProperty$3 = objectProto$3.hasOwnProperty;

	/** Used to detect if a method is native. */
	var reIsNative = RegExp('^' +
	  funcToString$1.call(hasOwnProperty$3).replace(reRegExpChar, '\\$&')
	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	);

	/**
	 * The base implementation of `_.isNative` without bad shim checks.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a native function,
	 *  else `false`.
	 */
	function baseIsNative(value) {
	  if (!isObject_1(value) || _isMasked(value)) {
	    return false;
	  }
	  var pattern = isFunction_1(value) ? reIsNative : reIsHostCtor;
	  return pattern.test(_toSource(value));
	}

	var _baseIsNative = baseIsNative;

	/**
	 * Gets the value at `key` of `object`.
	 *
	 * @private
	 * @param {Object} [object] The object to query.
	 * @param {string} key The key of the property to get.
	 * @returns {*} Returns the property value.
	 */
	function getValue(object, key) {
	  return object == null ? undefined : object[key];
	}

	var _getValue = getValue;

	/**
	 * Gets the native function at `key` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the method to get.
	 * @returns {*} Returns the function if it's native, else `undefined`.
	 */
	function getNative(object, key) {
	  var value = _getValue(object, key);
	  return _baseIsNative(value) ? value : undefined;
	}

	var _getNative = getNative;

	/* Built-in method references that are verified to be native. */
	var nativeCreate = _getNative(Object, 'create');

	var _nativeCreate = nativeCreate;

	/**
	 * Removes all key-value entries from the hash.
	 *
	 * @private
	 * @name clear
	 * @memberOf Hash
	 */
	function hashClear() {
	  this.__data__ = _nativeCreate ? _nativeCreate(null) : {};
	  this.size = 0;
	}

	var _hashClear = hashClear;

	/**
	 * Removes `key` and its value from the hash.
	 *
	 * @private
	 * @name delete
	 * @memberOf Hash
	 * @param {Object} hash The hash to modify.
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function hashDelete(key) {
	  var result = this.has(key) && delete this.__data__[key];
	  this.size -= result ? 1 : 0;
	  return result;
	}

	var _hashDelete = hashDelete;

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = '__lodash_hash_undefined__';

	/** Used for built-in method references. */
	var objectProto$4 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$4 = objectProto$4.hasOwnProperty;

	/**
	 * Gets the hash value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Hash
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function hashGet(key) {
	  var data = this.__data__;
	  if (_nativeCreate) {
	    var result = data[key];
	    return result === HASH_UNDEFINED ? undefined : result;
	  }
	  return hasOwnProperty$4.call(data, key) ? data[key] : undefined;
	}

	var _hashGet = hashGet;

	/** Used for built-in method references. */
	var objectProto$5 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$5 = objectProto$5.hasOwnProperty;

	/**
	 * Checks if a hash value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Hash
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function hashHas(key) {
	  var data = this.__data__;
	  return _nativeCreate ? (data[key] !== undefined) : hasOwnProperty$5.call(data, key);
	}

	var _hashHas = hashHas;

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

	/**
	 * Sets the hash `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Hash
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the hash instance.
	 */
	function hashSet(key, value) {
	  var data = this.__data__;
	  this.size += this.has(key) ? 0 : 1;
	  data[key] = (_nativeCreate && value === undefined) ? HASH_UNDEFINED$1 : value;
	  return this;
	}

	var _hashSet = hashSet;

	/**
	 * Creates a hash object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Hash(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `Hash`.
	Hash.prototype.clear = _hashClear;
	Hash.prototype['delete'] = _hashDelete;
	Hash.prototype.get = _hashGet;
	Hash.prototype.has = _hashHas;
	Hash.prototype.set = _hashSet;

	var _Hash = Hash;

	/**
	 * Removes all key-value entries from the list cache.
	 *
	 * @private
	 * @name clear
	 * @memberOf ListCache
	 */
	function listCacheClear() {
	  this.__data__ = [];
	  this.size = 0;
	}

	var _listCacheClear = listCacheClear;

	/**
	 * Performs a
	 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * comparison between two values to determine if they are equivalent.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 * var other = { 'a': 1 };
	 *
	 * _.eq(object, object);
	 * // => true
	 *
	 * _.eq(object, other);
	 * // => false
	 *
	 * _.eq('a', 'a');
	 * // => true
	 *
	 * _.eq('a', Object('a'));
	 * // => false
	 *
	 * _.eq(NaN, NaN);
	 * // => true
	 */
	function eq(value, other) {
	  return value === other || (value !== value && other !== other);
	}

	var eq_1 = eq;

	/**
	 * Gets the index at which the `key` is found in `array` of key-value pairs.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} key The key to search for.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function assocIndexOf(array, key) {
	  var length = array.length;
	  while (length--) {
	    if (eq_1(array[length][0], key)) {
	      return length;
	    }
	  }
	  return -1;
	}

	var _assocIndexOf = assocIndexOf;

	/** Used for built-in method references. */
	var arrayProto = Array.prototype;

	/** Built-in value references. */
	var splice = arrayProto.splice;

	/**
	 * Removes `key` and its value from the list cache.
	 *
	 * @private
	 * @name delete
	 * @memberOf ListCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function listCacheDelete(key) {
	  var data = this.__data__,
	      index = _assocIndexOf(data, key);

	  if (index < 0) {
	    return false;
	  }
	  var lastIndex = data.length - 1;
	  if (index == lastIndex) {
	    data.pop();
	  } else {
	    splice.call(data, index, 1);
	  }
	  --this.size;
	  return true;
	}

	var _listCacheDelete = listCacheDelete;

	/**
	 * Gets the list cache value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf ListCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function listCacheGet(key) {
	  var data = this.__data__,
	      index = _assocIndexOf(data, key);

	  return index < 0 ? undefined : data[index][1];
	}

	var _listCacheGet = listCacheGet;

	/**
	 * Checks if a list cache value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf ListCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function listCacheHas(key) {
	  return _assocIndexOf(this.__data__, key) > -1;
	}

	var _listCacheHas = listCacheHas;

	/**
	 * Sets the list cache `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf ListCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the list cache instance.
	 */
	function listCacheSet(key, value) {
	  var data = this.__data__,
	      index = _assocIndexOf(data, key);

	  if (index < 0) {
	    ++this.size;
	    data.push([key, value]);
	  } else {
	    data[index][1] = value;
	  }
	  return this;
	}

	var _listCacheSet = listCacheSet;

	/**
	 * Creates an list cache object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function ListCache(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `ListCache`.
	ListCache.prototype.clear = _listCacheClear;
	ListCache.prototype['delete'] = _listCacheDelete;
	ListCache.prototype.get = _listCacheGet;
	ListCache.prototype.has = _listCacheHas;
	ListCache.prototype.set = _listCacheSet;

	var _ListCache = ListCache;

	/* Built-in method references that are verified to be native. */
	var Map = _getNative(_root, 'Map');

	var _Map = Map;

	/**
	 * Removes all key-value entries from the map.
	 *
	 * @private
	 * @name clear
	 * @memberOf MapCache
	 */
	function mapCacheClear() {
	  this.size = 0;
	  this.__data__ = {
	    'hash': new _Hash,
	    'map': new (_Map || _ListCache),
	    'string': new _Hash
	  };
	}

	var _mapCacheClear = mapCacheClear;

	/**
	 * Checks if `value` is suitable for use as unique object key.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
	 */
	function isKeyable(value) {
	  var type = typeof value;
	  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
	    ? (value !== '__proto__')
	    : (value === null);
	}

	var _isKeyable = isKeyable;

	/**
	 * Gets the data for `map`.
	 *
	 * @private
	 * @param {Object} map The map to query.
	 * @param {string} key The reference key.
	 * @returns {*} Returns the map data.
	 */
	function getMapData(map, key) {
	  var data = map.__data__;
	  return _isKeyable(key)
	    ? data[typeof key == 'string' ? 'string' : 'hash']
	    : data.map;
	}

	var _getMapData = getMapData;

	/**
	 * Removes `key` and its value from the map.
	 *
	 * @private
	 * @name delete
	 * @memberOf MapCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function mapCacheDelete(key) {
	  var result = _getMapData(this, key)['delete'](key);
	  this.size -= result ? 1 : 0;
	  return result;
	}

	var _mapCacheDelete = mapCacheDelete;

	/**
	 * Gets the map value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf MapCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function mapCacheGet(key) {
	  return _getMapData(this, key).get(key);
	}

	var _mapCacheGet = mapCacheGet;

	/**
	 * Checks if a map value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf MapCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function mapCacheHas(key) {
	  return _getMapData(this, key).has(key);
	}

	var _mapCacheHas = mapCacheHas;

	/**
	 * Sets the map `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf MapCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the map cache instance.
	 */
	function mapCacheSet(key, value) {
	  var data = _getMapData(this, key),
	      size = data.size;

	  data.set(key, value);
	  this.size += data.size == size ? 0 : 1;
	  return this;
	}

	var _mapCacheSet = mapCacheSet;

	/**
	 * Creates a map cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function MapCache(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `MapCache`.
	MapCache.prototype.clear = _mapCacheClear;
	MapCache.prototype['delete'] = _mapCacheDelete;
	MapCache.prototype.get = _mapCacheGet;
	MapCache.prototype.has = _mapCacheHas;
	MapCache.prototype.set = _mapCacheSet;

	var _MapCache = MapCache;

	/** Error message constants. */
	var FUNC_ERROR_TEXT = 'Expected a function';

	/**
	 * Creates a function that memoizes the result of `func`. If `resolver` is
	 * provided, it determines the cache key for storing the result based on the
	 * arguments provided to the memoized function. By default, the first argument
	 * provided to the memoized function is used as the map cache key. The `func`
	 * is invoked with the `this` binding of the memoized function.
	 *
	 * **Note:** The cache is exposed as the `cache` property on the memoized
	 * function. Its creation may be customized by replacing the `_.memoize.Cache`
	 * constructor with one whose instances implement the
	 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
	 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Function
	 * @param {Function} func The function to have its output memoized.
	 * @param {Function} [resolver] The function to resolve the cache key.
	 * @returns {Function} Returns the new memoized function.
	 * @example
	 *
	 * var object = { 'a': 1, 'b': 2 };
	 * var other = { 'c': 3, 'd': 4 };
	 *
	 * var values = _.memoize(_.values);
	 * values(object);
	 * // => [1, 2]
	 *
	 * values(other);
	 * // => [3, 4]
	 *
	 * object.a = 2;
	 * values(object);
	 * // => [1, 2]
	 *
	 * // Modify the result cache.
	 * values.cache.set(object, ['a', 'b']);
	 * values(object);
	 * // => ['a', 'b']
	 *
	 * // Replace `_.memoize.Cache`.
	 * _.memoize.Cache = WeakMap;
	 */
	function memoize(func, resolver) {
	  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
	    throw new TypeError(FUNC_ERROR_TEXT);
	  }
	  var memoized = function() {
	    var args = arguments,
	        key = resolver ? resolver.apply(this, args) : args[0],
	        cache = memoized.cache;

	    if (cache.has(key)) {
	      return cache.get(key);
	    }
	    var result = func.apply(this, args);
	    memoized.cache = cache.set(key, result) || cache;
	    return result;
	  };
	  memoized.cache = new (memoize.Cache || _MapCache);
	  return memoized;
	}

	// Expose `MapCache`.
	memoize.Cache = _MapCache;

	var memoize_1 = memoize;

	/** Used as the maximum memoize cache size. */
	var MAX_MEMOIZE_SIZE = 500;

	/**
	 * A specialized version of `_.memoize` which clears the memoized function's
	 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
	 *
	 * @private
	 * @param {Function} func The function to have its output memoized.
	 * @returns {Function} Returns the new memoized function.
	 */
	function memoizeCapped(func) {
	  var result = memoize_1(func, function(key) {
	    if (cache.size === MAX_MEMOIZE_SIZE) {
	      cache.clear();
	    }
	    return key;
	  });

	  var cache = result.cache;
	  return result;
	}

	var _memoizeCapped = memoizeCapped;

	/** Used to match property names within property paths. */
	var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

	/** Used to match backslashes in property paths. */
	var reEscapeChar = /\\(\\)?/g;

	/**
	 * Converts `string` to a property path array.
	 *
	 * @private
	 * @param {string} string The string to convert.
	 * @returns {Array} Returns the property path array.
	 */
	var stringToPath = _memoizeCapped(function(string) {
	  var result = [];
	  if (string.charCodeAt(0) === 46 /* . */) {
	    result.push('');
	  }
	  string.replace(rePropName, function(match, number, quote, subString) {
	    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
	  });
	  return result;
	});

	var _stringToPath = stringToPath;

	/**
	 * A specialized version of `_.map` for arrays without support for iteratee
	 * shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the new mapped array.
	 */
	function arrayMap(array, iteratee) {
	  var index = -1,
	      length = array == null ? 0 : array.length,
	      result = Array(length);

	  while (++index < length) {
	    result[index] = iteratee(array[index], index, array);
	  }
	  return result;
	}

	var _arrayMap = arrayMap;

	/** Used as references for various `Number` constants. */
	var INFINITY = 1 / 0;

	/** Used to convert symbols to primitives and strings. */
	var symbolProto = _Symbol ? _Symbol.prototype : undefined,
	    symbolToString = symbolProto ? symbolProto.toString : undefined;

	/**
	 * The base implementation of `_.toString` which doesn't convert nullish
	 * values to empty strings.
	 *
	 * @private
	 * @param {*} value The value to process.
	 * @returns {string} Returns the string.
	 */
	function baseToString(value) {
	  // Exit early for strings to avoid a performance hit in some environments.
	  if (typeof value == 'string') {
	    return value;
	  }
	  if (isArray_1(value)) {
	    // Recursively convert values (susceptible to call stack limits).
	    return _arrayMap(value, baseToString) + '';
	  }
	  if (isSymbol_1(value)) {
	    return symbolToString ? symbolToString.call(value) : '';
	  }
	  var result = (value + '');
	  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
	}

	var _baseToString = baseToString;

	/**
	 * Converts `value` to a string. An empty string is returned for `null`
	 * and `undefined` values. The sign of `-0` is preserved.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 * @example
	 *
	 * _.toString(null);
	 * // => ''
	 *
	 * _.toString(-0);
	 * // => '-0'
	 *
	 * _.toString([1, 2, 3]);
	 * // => '1,2,3'
	 */
	function toString$1(value) {
	  return value == null ? '' : _baseToString(value);
	}

	var toString_1 = toString$1;

	/**
	 * Casts `value` to a path array if it's not one.
	 *
	 * @private
	 * @param {*} value The value to inspect.
	 * @param {Object} [object] The object to query keys on.
	 * @returns {Array} Returns the cast property path array.
	 */
	function castPath(value, object) {
	  if (isArray_1(value)) {
	    return value;
	  }
	  return _isKey(value, object) ? [value] : _stringToPath(toString_1(value));
	}

	var _castPath = castPath;

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]';

	/**
	 * The base implementation of `_.isArguments`.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 */
	function baseIsArguments(value) {
	  return isObjectLike_1(value) && _baseGetTag(value) == argsTag;
	}

	var _baseIsArguments = baseIsArguments;

	/** Used for built-in method references. */
	var objectProto$6 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$6 = objectProto$6.hasOwnProperty;

	/** Built-in value references. */
	var propertyIsEnumerable = objectProto$6.propertyIsEnumerable;

	/**
	 * Checks if `value` is likely an `arguments` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArguments(function() { return arguments; }());
	 * // => true
	 *
	 * _.isArguments([1, 2, 3]);
	 * // => false
	 */
	var isArguments = _baseIsArguments(function() { return arguments; }()) ? _baseIsArguments : function(value) {
	  return isObjectLike_1(value) && hasOwnProperty$6.call(value, 'callee') &&
	    !propertyIsEnumerable.call(value, 'callee');
	};

	var isArguments_1 = isArguments;

	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER = 9007199254740991;

	/** Used to detect unsigned integer values. */
	var reIsUint = /^(?:0|[1-9]\d*)$/;

	/**
	 * Checks if `value` is a valid array-like index.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	 */
	function isIndex(value, length) {
	  var type = typeof value;
	  length = length == null ? MAX_SAFE_INTEGER : length;

	  return !!length &&
	    (type == 'number' ||
	      (type != 'symbol' && reIsUint.test(value))) &&
	        (value > -1 && value % 1 == 0 && value < length);
	}

	var _isIndex = isIndex;

	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER$1 = 9007199254740991;

	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This method is loosely based on
	 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 * @example
	 *
	 * _.isLength(3);
	 * // => true
	 *
	 * _.isLength(Number.MIN_VALUE);
	 * // => false
	 *
	 * _.isLength(Infinity);
	 * // => false
	 *
	 * _.isLength('3');
	 * // => false
	 */
	function isLength(value) {
	  return typeof value == 'number' &&
	    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$1;
	}

	var isLength_1 = isLength;

	/** Used as references for various `Number` constants. */
	var INFINITY$1 = 1 / 0;

	/**
	 * Converts `value` to a string key if it's not a string or symbol.
	 *
	 * @private
	 * @param {*} value The value to inspect.
	 * @returns {string|symbol} Returns the key.
	 */
	function toKey(value) {
	  if (typeof value == 'string' || isSymbol_1(value)) {
	    return value;
	  }
	  var result = (value + '');
	  return (result == '0' && (1 / value) == -INFINITY$1) ? '-0' : result;
	}

	var _toKey = toKey;

	/**
	 * Checks if `path` exists on `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path to check.
	 * @param {Function} hasFunc The function to check properties.
	 * @returns {boolean} Returns `true` if `path` exists, else `false`.
	 */
	function hasPath(object, path, hasFunc) {
	  path = _castPath(path, object);

	  var index = -1,
	      length = path.length,
	      result = false;

	  while (++index < length) {
	    var key = _toKey(path[index]);
	    if (!(result = object != null && hasFunc(object, key))) {
	      break;
	    }
	    object = object[key];
	  }
	  if (result || ++index != length) {
	    return result;
	  }
	  length = object == null ? 0 : object.length;
	  return !!length && isLength_1(length) && _isIndex(key, length) &&
	    (isArray_1(object) || isArguments_1(object));
	}

	var _hasPath = hasPath;

	/**
	 * Checks if `path` is a direct property of `object`.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path to check.
	 * @returns {boolean} Returns `true` if `path` exists, else `false`.
	 * @example
	 *
	 * var object = { 'a': { 'b': 2 } };
	 * var other = _.create({ 'a': _.create({ 'b': 2 }) });
	 *
	 * _.has(object, 'a');
	 * // => true
	 *
	 * _.has(object, 'a.b');
	 * // => true
	 *
	 * _.has(object, ['a', 'b']);
	 * // => true
	 *
	 * _.has(other, 'a');
	 * // => false
	 */
	function has(object, path) {
	  return object != null && _hasPath(object, path, _baseHas);
	}

	var has_1 = has;

	/**
	 * The base implementation of `_.get` without support for default values.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path of the property to get.
	 * @returns {*} Returns the resolved value.
	 */
	function baseGet(object, path) {
	  path = _castPath(path, object);

	  var index = 0,
	      length = path.length;

	  while (object != null && index < length) {
	    object = object[_toKey(path[index++])];
	  }
	  return (index && index == length) ? object : undefined;
	}

	var _baseGet = baseGet;

	/**
	 * Gets the value at `path` of `object`. If the resolved value is
	 * `undefined`, the `defaultValue` is returned in its place.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.7.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path of the property to get.
	 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
	 * @returns {*} Returns the resolved value.
	 * @example
	 *
	 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	 *
	 * _.get(object, 'a[0].b.c');
	 * // => 3
	 *
	 * _.get(object, ['a', '0', 'b', 'c']);
	 * // => 3
	 *
	 * _.get(object, 'a.b.c', 'default');
	 * // => 'default'
	 */
	function get(object, path, defaultValue) {
	  var result = object == null ? undefined : _baseGet(object, path);
	  return result === undefined ? defaultValue : result;
	}

	var get_1 = get;

	/**
	 *
	 *
	 * @author Jerry Bendy <jerry@icewingcc.com>
	 * @licence MIT
	 *
	 */

	(function(self) {

	    var nativeURLSearchParams = (self.URLSearchParams && self.URLSearchParams.prototype.get) ? self.URLSearchParams : null,
	        isSupportObjectConstructor = nativeURLSearchParams && (new nativeURLSearchParams({a: 1})).toString() === 'a=1',
	        // There is a bug in safari 10.1 (and earlier) that incorrectly decodes `%2B` as an empty space and not a plus.
	        decodesPlusesCorrectly = nativeURLSearchParams && (new nativeURLSearchParams('s=%2B').get('s') === '+'),
	        __URLSearchParams__ = "__URLSearchParams__",
	        // Fix bug in Edge which cannot encode ' &' correctly
	        encodesAmpersandsCorrectly = nativeURLSearchParams ? (function() {
	            var ampersandTest = new nativeURLSearchParams();
	            ampersandTest.append('s', ' &');
	            return ampersandTest.toString() === 's=+%26';
	        })() : true,
	        prototype = URLSearchParamsPolyfill.prototype,
	        iterable = !!(self.Symbol && self.Symbol.iterator);

	    if (nativeURLSearchParams && isSupportObjectConstructor && decodesPlusesCorrectly && encodesAmpersandsCorrectly) {
	        return;
	    }


	    /**
	     * Make a URLSearchParams instance
	     *
	     * @param {object|string|URLSearchParams} search
	     * @constructor
	     */
	    function URLSearchParamsPolyfill(search) {
	        search = search || "";

	        // support construct object with another URLSearchParams instance
	        if (search instanceof URLSearchParams || search instanceof URLSearchParamsPolyfill) {
	            search = search.toString();
	        }
	        this [__URLSearchParams__] = parseToDict(search);
	    }


	    /**
	     * Appends a specified key/value pair as a new search parameter.
	     *
	     * @param {string} name
	     * @param {string} value
	     */
	    prototype.append = function(name, value) {
	        appendTo(this [__URLSearchParams__], name, value);
	    };

	    /**
	     * Deletes the given search parameter, and its associated value,
	     * from the list of all search parameters.
	     *
	     * @param {string} name
	     */
	    prototype['delete'] = function(name) {
	        delete this [__URLSearchParams__] [name];
	    };

	    /**
	     * Returns the first value associated to the given search parameter.
	     *
	     * @param {string} name
	     * @returns {string|null}
	     */
	    prototype.get = function(name) {
	        var dict = this [__URLSearchParams__];
	        return name in dict ? dict[name][0] : null;
	    };

	    /**
	     * Returns all the values association with a given search parameter.
	     *
	     * @param {string} name
	     * @returns {Array}
	     */
	    prototype.getAll = function(name) {
	        var dict = this [__URLSearchParams__];
	        return name in dict ? dict [name].slice(0) : [];
	    };

	    /**
	     * Returns a Boolean indicating if such a search parameter exists.
	     *
	     * @param {string} name
	     * @returns {boolean}
	     */
	    prototype.has = function(name) {
	        return name in this [__URLSearchParams__];
	    };

	    /**
	     * Sets the value associated to a given search parameter to
	     * the given value. If there were several values, delete the
	     * others.
	     *
	     * @param {string} name
	     * @param {string} value
	     */
	    prototype.set = function set(name, value) {
	        this [__URLSearchParams__][name] = ['' + value];
	    };

	    /**
	     * Returns a string containg a query string suitable for use in a URL.
	     *
	     * @returns {string}
	     */
	    prototype.toString = function() {
	        var dict = this[__URLSearchParams__], query = [], i, key, name, value;
	        for (key in dict) {
	            name = encode(key);
	            for (i = 0, value = dict[key]; i < value.length; i++) {
	                query.push(name + '=' + encode(value[i]));
	            }
	        }
	        return query.join('&');
	    };

	    // There is a bug in Safari 10.1 and `Proxy`ing it is not enough.
	    var forSureUsePolyfill = !decodesPlusesCorrectly;
	    var useProxy = (!forSureUsePolyfill && nativeURLSearchParams && !isSupportObjectConstructor && self.Proxy);
	    /*
	     * Apply polifill to global object and append other prototype into it
	     */
	    Object.defineProperty(self, 'URLSearchParams', {
	        value: (useProxy ?
	            // Safari 10.0 doesn't support Proxy, so it won't extend URLSearchParams on safari 10.0
	            new Proxy(nativeURLSearchParams, {
	                construct: function(target, args) {
	                    return new target((new URLSearchParamsPolyfill(args[0]).toString()));
	                }
	            }) :
	            URLSearchParamsPolyfill)
	    });

	    var USPProto = self.URLSearchParams.prototype;

	    USPProto.polyfill = true;

	    /**
	     *
	     * @param {function} callback
	     * @param {object} thisArg
	     */
	    USPProto.forEach = USPProto.forEach || function(callback, thisArg) {
	        var dict = parseToDict(this.toString());
	        Object.getOwnPropertyNames(dict).forEach(function(name) {
	            dict[name].forEach(function(value) {
	                callback.call(thisArg, value, name, this);
	            }, this);
	        }, this);
	    };

	    /**
	     * Sort all name-value pairs
	     */
	    USPProto.sort = USPProto.sort || function() {
	        var dict = parseToDict(this.toString()), keys = [], k, i, j;
	        for (k in dict) {
	            keys.push(k);
	        }
	        keys.sort();

	        for (i = 0; i < keys.length; i++) {
	            this['delete'](keys[i]);
	        }
	        for (i = 0; i < keys.length; i++) {
	            var key = keys[i], values = dict[key];
	            for (j = 0; j < values.length; j++) {
	                this.append(key, values[j]);
	            }
	        }
	    };

	    /**
	     * Returns an iterator allowing to go through all keys of
	     * the key/value pairs contained in this object.
	     *
	     * @returns {function}
	     */
	    USPProto.keys = USPProto.keys || function() {
	        var items = [];
	        this.forEach(function(item, name) {
	            items.push(name);
	        });
	        return makeIterator(items);
	    };

	    /**
	     * Returns an iterator allowing to go through all values of
	     * the key/value pairs contained in this object.
	     *
	     * @returns {function}
	     */
	    USPProto.values = USPProto.values || function() {
	        var items = [];
	        this.forEach(function(item) {
	            items.push(item);
	        });
	        return makeIterator(items);
	    };

	    /**
	     * Returns an iterator allowing to go through all key/value
	     * pairs contained in this object.
	     *
	     * @returns {function}
	     */
	    USPProto.entries = USPProto.entries || function() {
	        var items = [];
	        this.forEach(function(item, name) {
	            items.push([name, item]);
	        });
	        return makeIterator(items);
	    };


	    if (iterable) {
	        USPProto[self.Symbol.iterator] = USPProto[self.Symbol.iterator] || USPProto.entries;
	    }


	    function encode(str) {
	        var replace = {
	            '!': '%21',
	            "'": '%27',
	            '(': '%28',
	            ')': '%29',
	            '~': '%7E',
	            '%20': '+',
	            '%00': '\x00'
	        };
	        return encodeURIComponent(str).replace(/[!'\(\)~]|%20|%00/g, function(match) {
	            return replace[match];
	        });
	    }

	    function decode(str) {
	        return str
	            .replace(/[ +]/g, '%20')
	            .replace(/(%[a-f0-9]{2})+/ig, function(match) {
	                return decodeURIComponent(match);
	            });
	    }

	    function makeIterator(arr) {
	        var iterator = {
	            next: function() {
	                var value = arr.shift();
	                return {done: value === undefined, value: value};
	            }
	        };

	        if (iterable) {
	            iterator[self.Symbol.iterator] = function() {
	                return iterator;
	            };
	        }

	        return iterator;
	    }

	    function parseToDict(search) {
	        var dict = {};

	        if (typeof search === "object") {
	            // if `search` is an array, treat it as a sequence
	            if (isArray(search)) {
	                for (var i = 0; i < search.length; i++) {
	                    var item = search[i];
	                    if (isArray(item) && item.length === 2) {
	                        appendTo(dict, item[0], item[1]);
	                    } else {
	                        throw new TypeError("Failed to construct 'URLSearchParams': Sequence initializer must only contain pair elements");
	                    }
	                }

	            } else {
	                for (var key in search) {
	                    if (search.hasOwnProperty(key)) {
	                        appendTo(dict, key, search[key]);
	                    }
	                }
	            }

	        } else {
	            // remove first '?'
	            if (search.indexOf("?") === 0) {
	                search = search.slice(1);
	            }

	            var pairs = search.split("&");
	            for (var j = 0; j < pairs.length; j++) {
	                var value = pairs [j],
	                    index = value.indexOf('=');

	                if (-1 < index) {
	                    appendTo(dict, decode(value.slice(0, index)), decode(value.slice(index + 1)));

	                } else {
	                    if (value) {
	                        appendTo(dict, decode(value), '');
	                    }
	                }
	            }
	        }

	        return dict;
	    }

	    function appendTo(dict, name, value) {
	        var val = typeof value === 'string' ? value : (
	            value !== null && value !== undefined && typeof value.toString === 'function' ? value.toString() : JSON.stringify(value)
	        );

	        if (name in dict) {
	            dict[name].push(val);
	        } else {
	            dict[name] = [val];
	        }
	    }

	    function isArray(val) {
	        return !!val && '[object Array]' === Object.prototype.toString.call(val);
	    }

	})(typeof commonjsGlobal !== 'undefined' ? commonjsGlobal : (typeof window !== 'undefined' ? window : commonjsGlobal));

	var addressToolsMixin = function addressToolsMixin(Base) {
	  var _temp;

	  return _temp =
	  /*#__PURE__*/
	  function (_Base) {
	    inherits(_temp, _Base);

	    function _temp($element, _options) {
	      var _this;

	      classCallCheck(this, _temp);

	      _this = possibleConstructorReturn(this, getPrototypeOf(_temp).call(this, $element, _options));

	      defineProperty(assertThisInitialized(assertThisInitialized(_this)), "initRequestSequence", function () {
	        _this.seq = 0;
	        _this.lastSeq = 0;
	      });

	      defineProperty(assertThisInitialized(assertThisInitialized(_this)), "beforeSend", function (jqXHR, options) {
	        var urlParams = new URLSearchParams(options.url);
	        jqXHR.lookup = urlParams.get('lookup');
	        jqXHR.seq = _this.seq;
	        _this.seq++;
	        $(document).trigger('afd:pceLookupStarted', [jqXHR, urlParams.get('lookup')]);
	      });

	      defineProperty(assertThisInitialized(assertThisInitialized(_this)), "requestCallback", function (data, textStatus, jqXHR) {
	        $(document).trigger('afd:pceLookupComplete', [data, jqXHR, jqXHR.lookup]);
	      });

	      defineProperty(assertThisInitialized(assertThisInitialized(_this)), "refreshUniqeID", function () {
	        _this.uniqueID = _this.getUniqueID();
	      });

	      defineProperty(assertThisInitialized(assertThisInitialized(_this)), "getUniqueID", function () {
	        return Math.floor(Math.random() * 90000) + 10000;
	      });

	      defineProperty(assertThisInitialized(assertThisInitialized(_this)), "uniqueIDTimer", function () {
	        if (_this.timer) {
	          window.clearTimeout(_this.timer);
	        } // timer for changing unique id


	        _this.timer = window.setTimeout(function () {
	          _this.timer = null; // get a new unique id

	          _this.refreshUniqeID();

	          if (typeof _this.controlType === 'typeahead') {
	            // we have to reinitialise the control with the new uniqueid, however doing this overwrites and results
	            // this breaks navigation if a 5 second delay happens after navigation, so we need to reinput the old results
	            var _window$Typeahead$inp = window.Typeahead.input,
	                result = _window$Typeahead$inp.result,
	                resultContainer = _window$Typeahead$inp.resultContainer;

	            _this.$element.typeahead(_this.typeaheadOptions);

	            window.Typeahead.input.result = result;
	            window.Typeahead.input.resultContainer = resultContainer;
	          }
	        }, 5000);
	      });

	      defineProperty(assertThisInitialized(assertThisInitialized(_this)), "setFields", function () {
	        var controlType = _this.options[_this.controlType].linkedControl ? _this.options[_this.controlType].linkedControl : _this.controlType;
	        _this.$typeaheadFieldandLabel = get_1(_this.options, controlType + '.containerOnlyContainsControl', false) ? _this.$typeaheadFieldandLabel = $('.afd-typeahead-container') : _this.$typeaheadFieldandLabel = $('.afd-typeahead-container label, .afd-typeahead-field');
	        _this.$typeAheadInput = $('.afd-typeahead-container input');
	        _this.$resultFields = $('[data-afd-result]');
	        _this.$typeaheadContainer = $('.afd-typeahead-container');
	        _this.$manualInputButton = has_1(_this.options, controlType + '.manualInputButtonIdentifier') ? $(_this.options[controlType].manualInputButtonIdentifier) : $('.afd-manual-input-button');
	        _this.$manualInputSearchButton = has_1(_this.options, controlType + '.manualInputSearchButtonIdentifier') ? $(_this.options[controlType].manualInputSearchButtonIdentifier) : $('.afd-manual-input-search-button');
	        _this.$searchAgainButton = has_1(_this.options, controlType + '.searchAgainButtonIdentifier') ? $(_this.options[controlType].searchAgainButtonIdentifier) : $('.afd-search-again');
	        _this.$fieldSets = $(_this.options[controlType].fieldSets.toString());
	        _this.$customCountryField = _this.options.country.customCountryControl ? $(_this.options.country.customCountryControl) : null;
	        _this.containers = _this.options[controlType].containers.toString();
	        _this.multiForms = _this.containers.length > 0; // If a non-afd country control is supplied then listen for changes and fire change event

	        if (_this.$customCountryField) {
	          if (_this.$customCountryField.length === 0) {
	            throw 'Custom country field selector ' + _this.options.country.customCountryControl + ' supplied, but no matching control found.';
	          }

	          _this.$customCountryField.off('change.afd', _this.onCustomCountryChange).on('change.afd', _this.onCustomCountryChange);
	        }
	      });

	      defineProperty(assertThisInitialized(assertThisInitialized(_this)), "initFields", function () {
	        var controlType = _this.controlType;

	        _this.handleMultiForms();

	        _this.$typeaheadFieldandLabel.show();

	        var fieldSets = _this.options[controlType].fieldSets; // show or hide the manual input button
	        // hide or show controls based on the country - also returns country

	        var country = _this.getInitialCountry(); // if set to hide result fields beforehand


	        if (_this.options[controlType].beforeHideResults) {
	          _this.$manualInputSearchButton.hide();

	          _this.hideResultFields(country);

	          if (fieldSets.length > 0) {
	            for (var i = 0; i < fieldSets.length; i++) {
	              $(fieldSets[i]).hide();
	            }
	          }
	        } else {
	          _this.showResultFields();

	          if (fieldSets.length > 0) {
	            for (var _i = 0; _i < fieldSets.length; _i++) {
	              $(fieldSets[_i]).show();
	            }
	          }
	        } // If option is set, show fields of not empty regardless of what is set on beforeHideResults
	        // this setting is useful when you are editing a previous address and you want to still show the previous values


	        if (_this.options[controlType].notEmptyShowResults) {
	          var container = _this.$element.closest(_this.containers);

	          var allEmpty = !_this.multiForms ? $('[data-afd-result]:empty').filter(function () {
	            return $.trim($(this).val()).length !== 0;
	          }).length === 0 : container.find('[data-afd-result]:empty').filter(function () {
	            return $.trim($(this).val()).length !== 0;
	          }).length === 0;

	          if (!allEmpty) {
	            _this.showResultFields();

	            _this.$fieldSets.show();

	            _this.$manualInputButton.hide();
	          }
	        }
	      });

	      defineProperty(assertThisInitialized(assertThisInitialized(_this)), "handleMultiForms", function () {
	        // this function handles the fact that their may be multiple forms on a single page
	        // if a `linkedControl` is specified (reverseGeocode), then this sets all the fields in relation to the linked control instead
	        var controlType = _this.options[_this.controlType].linkedControl ? _this.options[_this.controlType].linkedControl : _this.controlType; // if the containers array lists containers, we need to make sure that only fields in the containers are initialised

	        var container = _this.$element.closest(_this.containers);

	        if (_this.multiForms) {
	          _this.$manualInputButton = has_1(_this.options, controlType + '.manualInputButtonIdentifier') ? container.find(_this.options[controlType].manualInputButtonIdentifier) : container.find('.afd-manual-input-button');
	          _this.$manualInputSearchButton = has_1(_this.options, controlType + '.manualInputSearchButtonIdentifier') ? container.find(_this.options[controlType].manualInputSearchButtonIdentifier) : container.find('.afd-manual-input-search-button');
	          _this.$searchAgainButton = has_1(_this.options, controlType + '.searchAgainButtonIdentifier') ? container.find(_this.options[controlType].searchAgainButtonIdentifier) : container.find('.afd-search-again');
	          _this.$resultFields = container.find('[data-afd-result]');
	          _this.$typeaheadFieldandLabel = get_1(_this.options, controlType + '.containerOnlyContainsControl', false) ? container.find('.afd-typeahead-container') : container.find('.afd-typeahead-container > label, .afd-typeahead-field');
	          _this.$typeaheadContainer = container.find('.afd-typeahead-container');
	          _this.$customCountryField = _this.options.country.customCountryControl ? container.find(_this.options.country.customCountryControl) : null;
	          _this.$fieldSets = container.find(_this.options[controlType].fieldSets.toString());
	        }
	      });

	      defineProperty(assertThisInitialized(assertThisInitialized(_this)), "addressLookup", function (lookup) {
	        var controlType = _this.controlType;

	        var requestOptions = _this.setupParams({
	          data: 'address',
	          task: 'fastfindv4',
	          fields: _this.options[controlType].postcodeFirst ? 'list' : 'fflist',
	          uniqueid: _this.uniqueID,
	          lookup: lookup,
	          allpc: '1'
	        }); // for afd website


	        if (_this.options.afdc === 1) {
	          requestOptions.data.afdc = 1;
	        }

	        return $.ajax(requestOptions);
	      });

	      defineProperty(assertThisInitialized(assertThisInitialized(_this)), "addressRetrieve", function (key) {
	        var requestOptions = _this.setupParams({
	          key: key,
	          data: 'address',
	          task: 'retrieve',
	          fields: _this.options[_this.controlType].retrieveFields
	        });

	        if (_this.options.afdc === 1) {
	          requestOptions.data.afdc = 1;
	        }

	        return $.ajax(requestOptions);
	      });

	      defineProperty(assertThisInitialized(assertThisInitialized(_this)), "reverseGeocodeLookup", function (coords) {
	        var controlType = _this.controlType;

	        var requestOptions = _this.setupParams({
	          data: 'address',
	          task: 'nearest',
	          fields: _this.options[controlType].postcodeFirst ? 'list' : 'fflist',
	          uniqueid: _this.uniqueID,
	          longitude: coords.longitude,
	          latitude: coords.latitude,
	          allpc: '1'
	        }); // for afd website


	        if (_this.options.afdc === 1) {
	          requestOptions.data.afdc = 1;
	        }

	        return $.ajax(requestOptions);
	      });

	      defineProperty(assertThisInitialized(assertThisInitialized(_this)), "handleAddressRetrieve", function (data) {
	        var controlType = _this.options[_this.controlType].linkedControl ? _this.options[_this.controlType].linkedControl : _this.controlType;

	        if (typeof data.Item === 'undefined') {
	          return;
	        }

	        var _data$Item = slicedToArray(data.Item, 1);

	        _this.result = _data$Item[0];
	        $(document).trigger('afd:pceRetrieveComplete', [_this.result]); // hide the manual input after search completed

	        _this.$manualInputButton.hide(); // Clear the typeahead if option set


	        if (_this.options[controlType].afterClearTypeahead) {
	          _this.$typeAheadInput.val('');
	        } // Hide typeahed if option set


	        if (_this.options[controlType].afterHideTypeahead) {
	          _this.$typeaheadFieldandLabel.hide(); // Show search again if set


	          if (_this.options[controlType].searchAgain) {
	            _this.$searchAgainButton.show();
	          }
	        } // Hide lookup button if option set


	        if (_this.options[controlType].afterHideLookupButton) {
	          _this.$lookupButton.hide(); // Show search again if set


	          if (_this.options[controlType].searchAgain) {
	            _this.$searchAgainButton.show();
	          }
	        }

	        _this.$fieldSets.show();

	        if (_this.$resultFields.length < 1) {
	          return;
	        }

	        _this.$resultFields.each(_this.populateResult);

	        _this.$typeAheadInput.blur();
	      });

	      defineProperty(assertThisInitialized(assertThisInitialized(_this)), "populateResult", function (index) {
	        var $el = $(_this.$resultFields[index]);
	        var fieldName = $el.data('afd-result'); // this is for linking geoloaction with either lookup or typeahead

	        var controlType = _this.options[_this.controlType].linkedControl ? _this.options[_this.controlType].linkedControl : _this.controlType; // If a region mapping function is supplied, deal with region fields as dropdown

	        var regionFields = ['Region', 'State', 'AbbreviatedOptionalCounty', 'AbbreviatedPostalCounty', 'AdministrativeCounty', 'PostalCounty', 'TraditionalCounty'];

	        if (regionFields.indexOf(fieldName) > -1 && _this.options[controlType].regionMap) {
	          if (!$el.is('select')) {
	            throw '<' + $el.prop('tagName').toLowerCase() + '> is not a valid tag for `[data-afd-result="' + fieldName + '"]`, when regionMap is set.  This should be <select>';
	          }

	          var regionAttribute = _this.options[controlType].regionAttribute;
	          var afdResult = _this.result[fieldName];
	          var mappedResult = _this.options[controlType].regionMap[afdResult];
	          var optionValue = $el.find('[' + regionAttribute + '="' + mappedResult + '"]').val();
	          $el.val(optionValue);
	          return;
	        } // if pushup option is turned off, just fill out the form


	        if (!_this.options[controlType].pushUp) {
	          $el.val(_this.result[fieldName]); // if pushup is supplied as an array
	        } else if (Array.isArray(_this.options[controlType].pushUp)) {
	          _this.handlePushUp(_this.options[controlType].pushUp, fieldName, $el); // for anything else use default pushup options

	        } else {
	          _this.handlePushUp(['Property', 'Street', 'Locality'], fieldName, $el);
	        } // logic for hiding empty fields


	        if (!_this.options[controlType].hideEmpties || $el.val() && $el.val().length > 0) {
	          if (_this.options[controlType].parentClass) {
	            $el.closest('.' + _this.options[controlType].parentClass).show();
	          } else {
	            $el.show();
	          }
	        } else {
	          if (_this.options[controlType].parentClass) {
	            $el.closest('.' + _this.options[controlType].parentClass).hide();
	          } else {
	            $el.hide();
	          }
	        }

	        _this.$fieldSets.show(); // manually triggering keyup on the field, without this some validators still think the field is empty


	        $el.keyup();
	        $(document).trigger('afd:populateResultsComplete');
	      });

	      defineProperty(assertThisInitialized(assertThisInitialized(_this)), "populateResultsList", function () {
	        var itemTag = _this.$resultList.prop('tagName') === 'SELECT' ? 'option' : 'li';

	        _this.$resultList.empty();

	        for (var i = 0; i < _this.results.length; i++) {
	          var result = _this.results[i];

	          _this.$resultList.append('<' + itemTag + ' value="' + result.Key + '">' + result.List + '</' + itemTag + '>');
	        } // Special event handling required if $resultList is <ul>


	        if (itemTag === 'li') {
	          _this.$resultListResults = _this.$resultList.children('li');

	          _this.eventHandler(_this.$resultListResults, 'click', _this.onResultListItemClick);
	        }

	        _this.$resultList.closest('.afd-form-control').show();

	        _this.$resultList.focus();
	      });

	      defineProperty(assertThisInitialized(assertThisInitialized(_this)), "onResultListItemClick", function (e) {
	        _this.selectResult(e);
	      });

	      defineProperty(assertThisInitialized(assertThisInitialized(_this)), "onKeyDownResult", function (e) {
	        var keycode = e.keyCode ? e.keyCode : e.which;

	        if (keycode === 13) {
	          e.preventDefault();
	        }

	        if ([38, 40].indexOf(keycode) > -1) {
	          _this.blockChange = true;
	        }
	      });

	      defineProperty(assertThisInitialized(assertThisInitialized(_this)), "onKeyUpResult", function (e) {
	        var keycode = e.keyCode ? e.keyCode : e.which;

	        if (keycode === 13) {
	          _this.selectResult(e);
	        }
	      });

	      defineProperty(assertThisInitialized(assertThisInitialized(_this)), "onChangeResult", function (e) {
	        if (!_this.blockChange) {
	          _this.selectResult(e);
	        }

	        _this.blockChange = false;
	      });

	      defineProperty(assertThisInitialized(assertThisInitialized(_this)), "selectResult", function (e) {
	        if (_this.options[_this.controlType].afterRetrieveHideResultsList) {
	          _this.hideResultsElement();
	        }

	        _this.addressRetrieve(e.target.value).then(function (data) {
	          _this.handleAddressRetrieve(data);
	        }).fail(function (err) {
	          throw err;
	        });
	      });

	      defineProperty(assertThisInitialized(assertThisInitialized(_this)), "hideResultsElement", function () {
	        _this.$resultList.closest('.afd-form-control').hide();
	      });

	      defineProperty(assertThisInitialized(assertThisInitialized(_this)), "hideResultFields", function (country) {
	        var controlType = _this.controlType; // only do this if the current control is visible - needed if both lookup and typeahead are on same form

	        var controlRestricted = _this.options[controlType].showForCountries.length > 0 || _this.options[controlType].hideForCountries.length > 0;
	        var controlVisible = !controlRestricted || _this.options[controlType].showForCountries.length > 0 && _this.options[controlType].showForCountries.indexOf(country) > -1 || _this.options[controlType].hideForCountries.length > 0 && _this.options[controlType].hideForCountries.indexOf(country) === -1;

	        if (controlVisible) {
	          // parentClass is for input containers which may include labels/validation etc
	          if (_this.options[controlType].parentClass) {
	            _this.$resultFields.closest('.' + _this.options[controlType].parentClass).hide();
	          } else {
	            _this.$resultFields.hide();
	          }

	          _this.$fieldSets.hide(); // only lookup


	          var showPostcode = get_1(_this.options, controlType + '.postcodeIsLookup', false);

	          if (showPostcode) {
	            if (_this.options[controlType].parentClass) {
	              $('[data-afd-result="Postcode"]').closest('.' + _this.options[controlType].parentClass).show();
	            } else {
	              $('[data-afd-result="Postcode"]').show();
	            }
	          }
	        }
	      });

	      defineProperty(assertThisInitialized(assertThisInitialized(_this)), "showResultFields", function () {
	        var controlType = _this.controlType; // parentClass is for input containers whcih may include labels/validation etc

	        if (_this.options[controlType].parentClass) {
	          _this.$resultFields.closest('.' + _this.options[controlType].parentClass).show();
	        } else {
	          _this.$resultFields.show();
	        }

	        _this.$fieldSets.show();
	      });

	      defineProperty(assertThisInitialized(assertThisInitialized(_this)), "fieldEmpty", function (field) {
	        return typeof _this.result[field] !== 'undefined' && _this.result[field].length === 0;
	      });

	      defineProperty(assertThisInitialized(assertThisInitialized(_this)), "onAfdSearchAgainButtonClick", function () {
	        var controlType = _this.controlType;

	        _this.$resultFields.val('');

	        _this.$searchAgainButton.hide();

	        if (controlType === 'typeahead') {
	          _this.$typeaheadFieldandLabel.show();
	        } else if (controlType === 'lookup') {
	          _this.$lookupButton.show();

	          _this.$lookupField.focus();
	        }

	        if (_this.options[controlType].beforeHideResults) {
	          _this.$manualInputButton.show();

	          _this.hideResultFields(_this.country);

	          _this.$fieldSets.hide();
	        } else {
	          _this.$manualInputButton.hide();

	          _this.showResultFields();

	          _this.$fieldSets.show();
	        }
	      });

	      defineProperty(assertThisInitialized(assertThisInitialized(_this)), "onAfdManualInputButtonClick", function () {
	        var controlType = _this.controlType;

	        _this.$manualInputButton.hide();

	        _this.$manualInputSearchButton.show();

	        if (controlType === 'typeahead') {
	          _this.$typeaheadFieldandLabel.hide();
	        } else {
	          _this.$lookupButton.hide();
	        }

	        _this.showResultFields();

	        if (_this.options[controlType].fieldSets.length > 0) {
	          for (var i = 0; i < _this.options[controlType].fieldSets.length; i++) {
	            $(_this.options[controlType].fieldSets[i]).show();
	          }
	        }
	      });

	      defineProperty(assertThisInitialized(assertThisInitialized(_this)), "onAfdManualInputSearchButtonClick", function () {
	        var controlType = _this.controlType;

	        if (controlType === 'typeahead') {
	          _this.$typeaheadFieldandLabel.show();
	        } else if (controlType === 'lookup') {
	          _this.$lookupButton.show();
	        }

	        _this.$manualInputButton.show();

	        _this.$manualInputSearchButton.hide();

	        _this.hideResultFields(_this.country);

	        _this.$fieldSets.hide();
	      });

	      defineProperty(assertThisInitialized(assertThisInitialized(_this)), "onCustomCountryChange", function () {
	        var country = _this.$customCountryField.val();

	        if (_this.options.country.customCountryConverter) {
	          if (typeof _this.options.country.customCountryConverter !== 'function') {
	            throw 'customCountryConverter Must be a function';
	          }

	          country = _this.options.country.customCountryConverter(country);
	        }

	        $(document).trigger('afd:countryChanged', [country]);
	      });

	      defineProperty(assertThisInitialized(assertThisInitialized(_this)), "onCountryChanged", function (e, country) {
	        _this.country = country;

	        _this.handleHideShowControls(country);
	      });

	      defineProperty(assertThisInitialized(assertThisInitialized(_this)), "handleHideShowControls", function (country) {
	        var controlType = _this.controlType;

	        if (_this.options[controlType].hideForCountries.length > 0) {
	          if (_this.options[controlType].hideForCountries.indexOf(country) > -1) {
	            _this.hideControls(controlType);
	          } else {
	            _this.showControls(controlType);
	          }
	        }

	        if (_this.options[controlType].showForCountries.length > 0) {
	          if (_this.options[controlType].showForCountries.indexOf(country) > -1) {
	            _this.showControls(controlType);

	            if (_this.options[controlType].beforeHideResults) {
	              _this.$manualInputButton.show();

	              _this.hideResultFields(country);

	              _this.$fieldSets.hide();
	            } else {
	              _this.$manualInputButton.hide();

	              _this.showResultFields();

	              _this.$fieldSets.show();
	            }
	          } else {
	            _this.hideControls(controlType);

	            _this.showResultFields();
	          }
	        }

	        if (_this.options[controlType].hideForCountries.length === 0 && _this.options[controlType].showForCountries.length === 0) {
	          _this.showControls(controlType);
	        }
	      });

	      defineProperty(assertThisInitialized(assertThisInitialized(_this)), "showControls", function (controlType) {
	        if (controlType === 'lookup') {
	          _this.$lookupButton.closest('.afd-form-control').show();

	          _this.$lookupField.closest('.afd-form-control').show();
	        } else {
	          _this.$typeaheadFieldandLabel.show();
	        }

	        if (_this.options[controlType].manualInputButton) {
	          _this.$manualInputButton.show();
	        }
	      });

	      defineProperty(assertThisInitialized(assertThisInitialized(_this)), "hideControls", function (controlType) {
	        if (controlType === 'lookup') {
	          _this.$lookupButton.closest('.afd-form-control').hide();

	          _this.$lookupField.closest('.afd-form-control').hide();

	          _this.$resultList.closest('.afd-form-control').hide();
	        } else {
	          _this.$typeaheadFieldandLabel.hide();
	        }

	        _this.$manualInputButton.hide();
	      });

	      defineProperty(assertThisInitialized(assertThisInitialized(_this)), "getInitialCountry", function () {
	        var country = null;

	        if (_this.$customCountryField) {
	          country = _this.$customCountryField.val();

	          if (_this.options.country.customCountryConverter) {
	            if (typeof _this.options.country.customCountryConverter !== 'function') {
	              throw 'customCountryConverter Must be a function';
	            }

	            country = _this.options.country.customCountryConverter(country);
	          }

	          _this.handleHideShowControls(country);
	        } else if (_this.options.country.defaultCountry) {
	          country = _this.options.country.defaultCountry;

	          _this.handleHideShowControls(_this.options.country.defaultCountry);
	        } else if (_this.options.defaultCountry) {
	          country = _this.options.defaultCountry;

	          _this.handleHideShowControls(_this.options.defaultCountry);
	        }

	        return country;
	      });

	      defineProperty(assertThisInitialized(assertThisInitialized(_this)), "handlePushUp", function (fields, fieldName, $el) {
	        //get index of current field in array
	        var index = fields.indexOf(fieldName); // if this field is not involved in pushup manipulation

	        if (index === -1) {
	          $el.val(_this.result[fieldName]);
	          return;
	        } // create an array that contains the populated fields


	        var populatedFields = [];

	        for (var i = 0; i < fields.length; i++) {
	          if (_this.result[fields[i]].length > 0) {
	            populatedFields.push(_this.result[fields[i]]);
	          }
	        }

	        $el.val(populatedFields[index]);
	      });

	      return _this;
	    } // logic for identifying each different lookup so that old ones can be discarded if they come in too late


	    return _temp;
	  }(Base), _temp;
	};

	var _fixReWks = function (KEY, length, exec) {
	  var SYMBOL = _wks(KEY);
	  var fns = exec(_defined, SYMBOL, ''[KEY]);
	  var strfn = fns[0];
	  var rxfn = fns[1];
	  if (_fails(function () {
	    var O = {};
	    O[SYMBOL] = function () { return 7; };
	    return ''[KEY](O) != 7;
	  })) {
	    _redefine(String.prototype, KEY, strfn);
	    _hide(RegExp.prototype, SYMBOL, length == 2
	      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
	      // 21.2.5.11 RegExp.prototype[@@split](string, limit)
	      ? function (string, arg) { return rxfn.call(string, this, arg); }
	      // 21.2.5.6 RegExp.prototype[@@match](string)
	      // 21.2.5.9 RegExp.prototype[@@search](string)
	      : function (string) { return rxfn.call(string, this); }
	    );
	  }
	};

	// @@match logic
	_fixReWks('match', 1, function (defined, MATCH, $match) {
	  // 21.1.3.11 String.prototype.match(regexp)
	  return [function match(regexp) {
	    var O = defined(this);
	    var fn = regexp == undefined ? undefined : regexp[MATCH];
	    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
	  }, $match];
	});

	var f$1 = {}.propertyIsEnumerable;

	var _objectPie = {
		f: f$1
	};

	// to indexed object, toObject with fallback for non-array-like ES3 strings


	var _toIobject = function (it) {
	  return _iobject(_defined(it));
	};

	var gOPD = Object.getOwnPropertyDescriptor;

	var f$2 = _descriptors ? gOPD : function getOwnPropertyDescriptor(O, P) {
	  O = _toIobject(O);
	  P = _toPrimitive(P, true);
	  if (_ie8DomDefine) try {
	    return gOPD(O, P);
	  } catch (e) { /* empty */ }
	  if (_has(O, P)) return _propertyDesc(!_objectPie.f.call(O, P), O[P]);
	};

	var _objectGopd = {
		f: f$2
	};

	// Works with __proto__ only. Old v8 can't work with null proto objects.
	/* eslint-disable no-proto */


	var check = function (O, proto) {
	  _anObject(O);
	  if (!_isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
	};
	var _setProto = {
	  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
	    function (test, buggy, set) {
	      try {
	        set = _ctx(Function.call, _objectGopd.f(Object.prototype, '__proto__').set, 2);
	        set(test, []);
	        buggy = !(test instanceof Array);
	      } catch (e) { buggy = true; }
	      return function setPrototypeOf(O, proto) {
	        check(O, proto);
	        if (buggy) O.__proto__ = proto;
	        else set(O, proto);
	        return O;
	      };
	    }({}, false) : undefined),
	  check: check
	};

	var setPrototypeOf$1 = _setProto.set;
	var _inheritIfRequired = function (that, target, C) {
	  var S = target.constructor;
	  var P;
	  if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && _isObject(P) && setPrototypeOf$1) {
	    setPrototypeOf$1(that, P);
	  } return that;
	};

	var max = Math.max;
	var min$1 = Math.min;
	var _toAbsoluteIndex = function (index, length) {
	  index = _toInteger(index);
	  return index < 0 ? max(index + length, 0) : min$1(index, length);
	};

	// false -> Array#indexOf
	// true  -> Array#includes



	var _arrayIncludes = function (IS_INCLUDES) {
	  return function ($this, el, fromIndex) {
	    var O = _toIobject($this);
	    var length = _toLength(O.length);
	    var index = _toAbsoluteIndex(fromIndex, length);
	    var value;
	    // Array#includes uses SameValueZero equality algorithm
	    // eslint-disable-next-line no-self-compare
	    if (IS_INCLUDES && el != el) while (length > index) {
	      value = O[index++];
	      // eslint-disable-next-line no-self-compare
	      if (value != value) return true;
	    // Array#indexOf ignores holes, Array#includes - not
	    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
	      if (O[index] === el) return IS_INCLUDES || index || 0;
	    } return !IS_INCLUDES && -1;
	  };
	};

	var shared = _shared('keys');

	var _sharedKey = function (key) {
	  return shared[key] || (shared[key] = _uid(key));
	};

	var arrayIndexOf = _arrayIncludes(false);
	var IE_PROTO = _sharedKey('IE_PROTO');

	var _objectKeysInternal = function (object, names) {
	  var O = _toIobject(object);
	  var i = 0;
	  var result = [];
	  var key;
	  for (key in O) if (key != IE_PROTO) _has(O, key) && result.push(key);
	  // Don't enum bug & hidden keys
	  while (names.length > i) if (_has(O, key = names[i++])) {
	    ~arrayIndexOf(result, key) || result.push(key);
	  }
	  return result;
	};

	// IE 8- don't enum bug keys
	var _enumBugKeys = (
	  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
	).split(',');

	// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)

	var hiddenKeys = _enumBugKeys.concat('length', 'prototype');

	var f$3 = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
	  return _objectKeysInternal(O, hiddenKeys);
	};

	var _objectGopn = {
		f: f$3
	};

	// 7.2.8 IsRegExp(argument)


	var MATCH = _wks('match');
	var _isRegexp = function (it) {
	  var isRegExp;
	  return _isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : _cof(it) == 'RegExp');
	};

	var SPECIES$1 = _wks('species');

	var _setSpecies = function (KEY) {
	  var C = _global[KEY];
	  if (_descriptors && C && !C[SPECIES$1]) _objectDp.f(C, SPECIES$1, {
	    configurable: true,
	    get: function () { return this; }
	  });
	};

	var dP$1 = _objectDp.f;
	var gOPN = _objectGopn.f;


	var $RegExp = _global.RegExp;
	var Base = $RegExp;
	var proto = $RegExp.prototype;
	var re1 = /a/g;
	var re2 = /a/g;
	// "new" creates a new object, old webkit buggy here
	var CORRECT_NEW = new $RegExp(re1) !== re1;

	if (_descriptors && (!CORRECT_NEW || _fails(function () {
	  re2[_wks('match')] = false;
	  // RegExp constructor can alter flags and IsRegExp works correct with @@match
	  return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';
	}))) {
	  $RegExp = function RegExp(p, f) {
	    var tiRE = this instanceof $RegExp;
	    var piRE = _isRegexp(p);
	    var fiU = f === undefined;
	    return !tiRE && piRE && p.constructor === $RegExp && fiU ? p
	      : _inheritIfRequired(CORRECT_NEW
	        ? new Base(piRE && !fiU ? p.source : p, f)
	        : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? _flags.call(p) : f)
	      , tiRE ? this : proto, $RegExp);
	  };
	  var proxy = function (key) {
	    key in $RegExp || dP$1($RegExp, key, {
	      configurable: true,
	      get: function () { return Base[key]; },
	      set: function (it) { Base[key] = it; }
	    });
	  };
	  for (var keys = gOPN(Base), i = 0; keys.length > i;) proxy(keys[i++]);
	  proto.constructor = $RegExp;
	  $RegExp.prototype = proto;
	  _redefine(_global, 'RegExp', $RegExp);
	}

	_setSpecies('RegExp');

	var _strictMethod = function (method, arg) {
	  return !!method && _fails(function () {
	    // eslint-disable-next-line no-useless-call
	    arg ? method.call(null, function () { /* empty */ }, 1) : method.call(null);
	  });
	};

	var $sort = [].sort;
	var test = [1, 2, 3];

	_export(_export.P + _export.F * (_fails(function () {
	  // IE8-
	  test.sort(undefined);
	}) || !_fails(function () {
	  // V8 bug
	  test.sort(null);
	  // Old WebKit
	}) || !_strictMethod($sort)), 'Array', {
	  // 22.1.3.25 Array.prototype.sort(comparefn)
	  sort: function sort(comparefn) {
	    return comparefn === undefined
	      ? $sort.call(_toObject(this))
	      : $sort.call(_toObject(this), _aFunction(comparefn));
	  }
	});

	// @@split logic
	_fixReWks('split', 2, function (defined, SPLIT, $split) {
	  var isRegExp = _isRegexp;
	  var _split = $split;
	  var $push = [].push;
	  var $SPLIT = 'split';
	  var LENGTH = 'length';
	  var LAST_INDEX = 'lastIndex';
	  if (
	    'abbc'[$SPLIT](/(b)*/)[1] == 'c' ||
	    'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 ||
	    'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 ||
	    '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 ||
	    '.'[$SPLIT](/()()/)[LENGTH] > 1 ||
	    ''[$SPLIT](/.?/)[LENGTH]
	  ) {
	    var NPCG = /()??/.exec('')[1] === undefined; // nonparticipating capturing group
	    // based on es5-shim implementation, need to rework it
	    $split = function (separator, limit) {
	      var string = String(this);
	      if (separator === undefined && limit === 0) return [];
	      // If `separator` is not a regex, use native split
	      if (!isRegExp(separator)) return _split.call(string, separator, limit);
	      var output = [];
	      var flags = (separator.ignoreCase ? 'i' : '') +
	                  (separator.multiline ? 'm' : '') +
	                  (separator.unicode ? 'u' : '') +
	                  (separator.sticky ? 'y' : '');
	      var lastLastIndex = 0;
	      var splitLimit = limit === undefined ? 4294967295 : limit >>> 0;
	      // Make `global` and avoid `lastIndex` issues by working with a copy
	      var separatorCopy = new RegExp(separator.source, flags + 'g');
	      var separator2, match, lastIndex, lastLength, i;
	      // Doesn't need flags gy, but they don't hurt
	      if (!NPCG) separator2 = new RegExp('^' + separatorCopy.source + '$(?!\\s)', flags);
	      while (match = separatorCopy.exec(string)) {
	        // `separatorCopy.lastIndex` is not reliable cross-browser
	        lastIndex = match.index + match[0][LENGTH];
	        if (lastIndex > lastLastIndex) {
	          output.push(string.slice(lastLastIndex, match.index));
	          // Fix browsers whose `exec` methods don't consistently return `undefined` for NPCG
	          // eslint-disable-next-line no-loop-func
	          if (!NPCG && match[LENGTH] > 1) match[0].replace(separator2, function () {
	            for (i = 1; i < arguments[LENGTH] - 2; i++) if (arguments[i] === undefined) match[i] = undefined;
	          });
	          if (match[LENGTH] > 1 && match.index < string[LENGTH]) $push.apply(output, match.slice(1));
	          lastLength = match[0][LENGTH];
	          lastLastIndex = lastIndex;
	          if (output[LENGTH] >= splitLimit) break;
	        }
	        if (separatorCopy[LAST_INDEX] === match.index) separatorCopy[LAST_INDEX]++; // Avoid an infinite loop
	      }
	      if (lastLastIndex === string[LENGTH]) {
	        if (lastLength || !separatorCopy.test('')) output.push('');
	      } else output.push(string.slice(lastLastIndex));
	      return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;
	    };
	  // Chakra, V8
	  } else if ('0'[$SPLIT](undefined, 0)[LENGTH]) {
	    $split = function (separator, limit) {
	      return separator === undefined && limit === 0 ? [] : _split.call(this, separator, limit);
	    };
	  }
	  // 21.1.3.17 String.prototype.split(separator, limit)
	  return [function split(separator, limit) {
	    var O = defined(this);
	    var fn = separator == undefined ? undefined : separator[SPLIT];
	    return fn !== undefined ? fn.call(separator, O, limit) : $split.call(String(O), separator, limit);
	  }, $split];
	});

	// @@replace logic
	_fixReWks('replace', 2, function (defined, REPLACE, $replace) {
	  // 21.1.3.14 String.prototype.replace(searchValue, replaceValue)
	  return [function replace(searchValue, replaceValue) {
	    var O = defined(this);
	    var fn = searchValue == undefined ? undefined : searchValue[REPLACE];
	    return fn !== undefined
	      ? fn.call(searchValue, O, replaceValue)
	      : $replace.call(String(O), searchValue, replaceValue);
	  }, $replace];
	});

	var _iterStep = function (done, value) {
	  return { value: value, done: !!done };
	};

	var _iterators = {};

	// 19.1.2.14 / 15.2.3.14 Object.keys(O)



	var _objectKeys = Object.keys || function keys(O) {
	  return _objectKeysInternal(O, _enumBugKeys);
	};

	var _objectDps = _descriptors ? Object.defineProperties : function defineProperties(O, Properties) {
	  _anObject(O);
	  var keys = _objectKeys(Properties);
	  var length = keys.length;
	  var i = 0;
	  var P;
	  while (length > i) _objectDp.f(O, P = keys[i++], Properties[P]);
	  return O;
	};

	var document$2 = _global.document;
	var _html = document$2 && document$2.documentElement;

	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])



	var IE_PROTO$1 = _sharedKey('IE_PROTO');
	var Empty = function () { /* empty */ };
	var PROTOTYPE$1 = 'prototype';

	// Create object with fake `null` prototype: use iframe Object with cleared prototype
	var createDict = function () {
	  // Thrash, waste and sodomy: IE GC bug
	  var iframe = _domCreate('iframe');
	  var i = _enumBugKeys.length;
	  var lt = '<';
	  var gt = '>';
	  var iframeDocument;
	  iframe.style.display = 'none';
	  _html.appendChild(iframe);
	  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
	  // createDict = iframe.contentWindow.Object;
	  // html.removeChild(iframe);
	  iframeDocument = iframe.contentWindow.document;
	  iframeDocument.open();
	  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
	  iframeDocument.close();
	  createDict = iframeDocument.F;
	  while (i--) delete createDict[PROTOTYPE$1][_enumBugKeys[i]];
	  return createDict();
	};

	var _objectCreate = Object.create || function create(O, Properties) {
	  var result;
	  if (O !== null) {
	    Empty[PROTOTYPE$1] = _anObject(O);
	    result = new Empty();
	    Empty[PROTOTYPE$1] = null;
	    // add "__proto__" for Object.getPrototypeOf polyfill
	    result[IE_PROTO$1] = O;
	  } else result = createDict();
	  return Properties === undefined ? result : _objectDps(result, Properties);
	};

	var def = _objectDp.f;

	var TAG = _wks('toStringTag');

	var _setToStringTag = function (it, tag, stat) {
	  if (it && !_has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
	};

	var IteratorPrototype = {};

	// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
	_hide(IteratorPrototype, _wks('iterator'), function () { return this; });

	var _iterCreate = function (Constructor, NAME, next) {
	  Constructor.prototype = _objectCreate(IteratorPrototype, { next: _propertyDesc(1, next) });
	  _setToStringTag(Constructor, NAME + ' Iterator');
	};

	// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)


	var IE_PROTO$2 = _sharedKey('IE_PROTO');
	var ObjectProto = Object.prototype;

	var _objectGpo = Object.getPrototypeOf || function (O) {
	  O = _toObject(O);
	  if (_has(O, IE_PROTO$2)) return O[IE_PROTO$2];
	  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
	    return O.constructor.prototype;
	  } return O instanceof Object ? ObjectProto : null;
	};

	var ITERATOR = _wks('iterator');
	var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
	var FF_ITERATOR = '@@iterator';
	var KEYS = 'keys';
	var VALUES = 'values';

	var returnThis = function () { return this; };

	var _iterDefine = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
	  _iterCreate(Constructor, NAME, next);
	  var getMethod = function (kind) {
	    if (!BUGGY && kind in proto) return proto[kind];
	    switch (kind) {
	      case KEYS: return function keys() { return new Constructor(this, kind); };
	      case VALUES: return function values() { return new Constructor(this, kind); };
	    } return function entries() { return new Constructor(this, kind); };
	  };
	  var TAG = NAME + ' Iterator';
	  var DEF_VALUES = DEFAULT == VALUES;
	  var VALUES_BUG = false;
	  var proto = Base.prototype;
	  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
	  var $default = $native || getMethod(DEFAULT);
	  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
	  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
	  var methods, key, IteratorPrototype;
	  // Fix native
	  if ($anyNative) {
	    IteratorPrototype = _objectGpo($anyNative.call(new Base()));
	    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
	      // Set @@toStringTag to native iterators
	      _setToStringTag(IteratorPrototype, TAG, true);
	      // fix for some old engines
	      if (!_library && typeof IteratorPrototype[ITERATOR] != 'function') _hide(IteratorPrototype, ITERATOR, returnThis);
	    }
	  }
	  // fix Array#{values, @@iterator}.name in V8 / FF
	  if (DEF_VALUES && $native && $native.name !== VALUES) {
	    VALUES_BUG = true;
	    $default = function values() { return $native.call(this); };
	  }
	  // Define iterator
	  if ((!_library || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
	    _hide(proto, ITERATOR, $default);
	  }
	  // Plug for library
	  _iterators[NAME] = $default;
	  _iterators[TAG] = returnThis;
	  if (DEFAULT) {
	    methods = {
	      values: DEF_VALUES ? $default : getMethod(VALUES),
	      keys: IS_SET ? $default : getMethod(KEYS),
	      entries: $entries
	    };
	    if (FORCED) for (key in methods) {
	      if (!(key in proto)) _redefine(proto, key, methods[key]);
	    } else _export(_export.P + _export.F * (BUGGY || VALUES_BUG), NAME, methods);
	  }
	  return methods;
	};

	// 22.1.3.4 Array.prototype.entries()
	// 22.1.3.13 Array.prototype.keys()
	// 22.1.3.29 Array.prototype.values()
	// 22.1.3.30 Array.prototype[@@iterator]()
	var es6_array_iterator = _iterDefine(Array, 'Array', function (iterated, kind) {
	  this._t = _toIobject(iterated); // target
	  this._i = 0;                   // next index
	  this._k = kind;                // kind
	// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
	}, function () {
	  var O = this._t;
	  var kind = this._k;
	  var index = this._i++;
	  if (!O || index >= O.length) {
	    this._t = undefined;
	    return _iterStep(1);
	  }
	  if (kind == 'keys') return _iterStep(0, index);
	  if (kind == 'values') return _iterStep(0, O[index]);
	  return _iterStep(0, [index, O[index]]);
	}, 'values');

	// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
	_iterators.Arguments = _iterators.Array;

	_addToUnscopables('keys');
	_addToUnscopables('values');
	_addToUnscopables('entries');

	var ITERATOR$1 = _wks('iterator');
	var TO_STRING_TAG = _wks('toStringTag');
	var ArrayValues = _iterators.Array;

	var DOMIterables = {
	  CSSRuleList: true, // TODO: Not spec compliant, should be false.
	  CSSStyleDeclaration: false,
	  CSSValueList: false,
	  ClientRectList: false,
	  DOMRectList: false,
	  DOMStringList: false,
	  DOMTokenList: true,
	  DataTransferItemList: false,
	  FileList: false,
	  HTMLAllCollection: false,
	  HTMLCollection: false,
	  HTMLFormElement: false,
	  HTMLSelectElement: false,
	  MediaList: true, // TODO: Not spec compliant, should be false.
	  MimeTypeArray: false,
	  NamedNodeMap: false,
	  NodeList: true,
	  PaintRequestList: false,
	  Plugin: false,
	  PluginArray: false,
	  SVGLengthList: false,
	  SVGNumberList: false,
	  SVGPathSegList: false,
	  SVGPointList: false,
	  SVGStringList: false,
	  SVGTransformList: false,
	  SourceBufferList: false,
	  StyleSheetList: true, // TODO: Not spec compliant, should be false.
	  TextTrackCueList: false,
	  TextTrackList: false,
	  TouchList: false
	};

	for (var collections = _objectKeys(DOMIterables), i$1 = 0; i$1 < collections.length; i$1++) {
	  var NAME = collections[i$1];
	  var explicit = DOMIterables[NAME];
	  var Collection = _global[NAME];
	  var proto$1 = Collection && Collection.prototype;
	  var key;
	  if (proto$1) {
	    if (!proto$1[ITERATOR$1]) _hide(proto$1, ITERATOR$1, ArrayValues);
	    if (!proto$1[TO_STRING_TAG]) _hide(proto$1, TO_STRING_TAG, NAME);
	    _iterators[NAME] = ArrayValues;
	    if (explicit) for (key in es6_array_iterator) if (!proto$1[key]) _redefine(proto$1, key, es6_array_iterator[key], true);
	  }
	}

	// most Object methods by ES6 should accept primitives



	var _objectSap = function (KEY, exec) {
	  var fn = (_core.Object || {})[KEY] || Object[KEY];
	  var exp = {};
	  exp[KEY] = exec(fn);
	  _export(_export.S + _export.F * _fails(function () { fn(1); }), 'Object', exp);
	};

	// 19.1.2.14 Object.keys(O)



	_objectSap('keys', function () {
	  return function keys(it) {
	    return _objectKeys(_toObject(it));
	  };
	});

	/*!
	 * jQuery Typeahead
	 * Copyright (C) 2018 RunningCoder.org
	 * Licensed under the MIT license
	 *
	 * @author Tom Bertrand
	 * @version 2.10.6 (2018-7-30)
	 * @link http://www.runningcoder.org/jquerytypeahead/
	 */
	//shopify
	(function ($) {

	  window.Typeahead = {
	    version: '2.10.6'
	  };
	  /**
	   * @private
	   * Default options
	   * @link http://www.runningcoder.org/jquerytypeahead/documentation/
	   */

	  var _options = {
	    input: null,
	    // *RECOMMENDED*, jQuery selector to reach Typeahead's input for initialization
	    minLength: 2,
	    // Accepts 0 to search on focus, minimum character length to perform a search
	    maxLength: false,
	    // False as "Infinity" will not put character length restriction for searching results
	    maxItem: 8,
	    // Accepts 0 / false as "Infinity" meaning all the results will be displayed
	    dynamic: false,
	    // When true, Typeahead will get a new dataset from the source option on every key press
	    delay: 300,
	    // delay in ms when dynamic option is set to true
	    order: null,
	    // "asc" or "desc" to sort results
	    offset: false,
	    // Set to true to match items starting from their first character
	    hint: false,
	    // Added support for excessive "space" characters
	    accent: false,
	    // Will allow to type accent and give letter equivalent results, also can define a custom replacement object
	    highlight: true,
	    // Added "any" to highlight any word in the template, by default true will only highlight display keys
	    multiselect: null,
	    // Multiselect configuration object, see documentation for all options
	    group: false,
	    // Improved feature, Boolean,string,object(key, template (string, function))
	    groupOrder: null,
	    // New feature, order groups "asc", "desc", Array, Function
	    maxItemPerGroup: null,
	    // Maximum number of result per Group
	    dropdownFilter: false,
	    // Take group options string and create a dropdown filter
	    dynamicFilter: null,
	    // Filter the typeahead results based on dynamic value, Ex: Players based on TeamID
	    backdrop: false,
	    // Add a backdrop behind Typeahead results
	    backdropOnFocus: false,
	    // Display the backdrop option as the Typeahead input is :focused
	    cache: false,
	    // Improved option, true OR 'localStorage' OR 'sessionStorage'
	    ttl: 3600000,
	    // Cache time to live in ms
	    compression: false,
	    // Requires LZString library
	    searchOnFocus: false,
	    // Display search results on input focus
	    blurOnTab: true,
	    // Blur Typeahead when Tab key is pressed, if false Tab will go though search results
	    resultContainer: null,
	    // List the results inside any container string or jQuery object
	    generateOnLoad: null,
	    // Forces the source to be generated on page load even if the input is not focused!
	    mustSelectItem: false,
	    // The submit function only gets called if an item is selected
	    href: null,
	    // String or Function to format the url for right-click & open in new tab on link results
	    display: ["display"],
	    // Allows search in multiple item keys ["display1", "display2"]
	    template: null,
	    // Display template of each of the result list
	    templateValue: null,
	    // Set the input value template when an item is clicked
	    groupTemplate: null,
	    // Set a custom template for the groups
	    correlativeTemplate: false,
	    // Compile display keys, enables multiple key search from the template string
	    emptyTemplate: false,
	    // Display an empty template if no result
	    cancelButton: true,
	    // If text is detected in the input, a cancel button will be available to reset the input (pressing ESC also cancels)
	    loadingAnimation: true,
	    // Display a loading animation when typeahead is doing request / searching for results
	    filter: true,
	    // Set to false or function to bypass Typeahead filtering. WARNING: accent, correlativeTemplate, offset & matcher will not be interpreted
	    matcher: null,
	    // Add an extra filtering function after the typeahead functions
	    source: null,
	    // Source of data for Typeahead to filter
	    abortAjax: true,
	    // Abort Ajax requests even if a new request is initiated
	    callback: {
	      onInit: null,
	      // When Typeahead is first initialized (happens only once)
	      onReady: null,
	      // When the Typeahead initial preparation is completed
	      onShowLayout: null,
	      // Called when the layout is shown
	      onHideLayout: null,
	      // Called when the layout is hidden
	      onSearch: null,
	      // When data is being fetched & analyzed to give search results
	      onResult: null,
	      // When the result container is displayed
	      onLayoutBuiltBefore: null,
	      // When the result HTML is build, modify it before it get showed
	      onLayoutBuiltAfter: null,
	      // Modify the dom right after the results gets inserted in the result container
	      onNavigateBefore: null,
	      // When a key is pressed to navigate the results, before the navigation happens
	      onNavigateAfter: null,
	      // When a key is pressed to navigate the results
	      onEnter: null,
	      // When an item in the result list is focused
	      onLeave: null,
	      // When an item in the result list is blurred
	      onClickBefore: null,
	      // Possibility to e.preventDefault() to prevent the Typeahead behaviors
	      onClickAfter: null,
	      // Happens after the default clicked behaviors has been executed
	      onDropdownFilter: null,
	      // When the dropdownFilter is changed, trigger this callback
	      onSendRequest: null,
	      // Gets called when the Ajax request(s) are sent
	      onReceiveRequest: null,
	      // Gets called when the Ajax request(s) are all received
	      onPopulateSource: null,
	      // Perform operation on the source data before it gets in Typeahead data
	      onCacheSave: null,
	      // Perform operation on the source data before it gets in Typeahead cache
	      onSubmit: null,
	      // When Typeahead form is submitted
	      onCancel: null // Triggered if the typeahead had text inside and is cleared

	    },
	    selector: {
	      container: "typeahead__container",
	      result: "typeahead__result",
	      list: "typeahead__list",
	      group: "typeahead__group",
	      item: "typeahead__item",
	      empty: "typeahead__empty",
	      display: "typeahead__display",
	      query: "typeahead__query",
	      filter: "typeahead__filter",
	      filterButton: "typeahead__filter-button",
	      dropdown: "typeahead__dropdown",
	      dropdownItem: "typeahead__dropdown-item",
	      labelContainer: "typeahead__label-container",
	      label: "typeahead__label",
	      button: "typeahead__button",
	      backdrop: "typeahead__backdrop",
	      hint: "typeahead__hint",
	      cancelButton: "typeahead__cancel-button"
	    },
	    debug: false // Display debug information (RECOMMENDED for dev environment)

	  };
	  /**
	   * @private
	   * Event namespace
	   */

	  var _namespace = ".typeahead";
	  /**
	   * @private
	   * Accent equivalents
	   */

	  var _accent = {
	    from: "Ã£Ã Ã¡Ã¤Ã¢áº½Ã¨Ã©Ã«ÃªÃ¬Ã­Ã¯Ã®ÃµÃ²Ã³Ã¶Ã´Ã¹ÃºÃ¼Ã»Ã±Ã§",
	    to: "aaaaaeeeeeiiiiooooouuuunc"
	  };
	  /**
	   * #62 IE9 doesn't trigger "input" event when text gets removed (backspace, ctrl+x, etc)
	   * @private
	   */

	  var _isIE9 = ~window.navigator.appVersion.indexOf("MSIE 9.");
	  /**
	   * #193 Clicking on a suggested option does not select it on IE10/11
	   * @private
	   */


	  var _isIE10 = ~window.navigator.appVersion.indexOf("MSIE 10");

	  var _isIE11 = ~window.navigator.userAgent.indexOf("Trident") ? ~window.navigator.userAgent.indexOf("rv:11") : false;
	  /**
	   * Sequence of ajax requests sent
	   * @type {number}
	   * @private
	   */


	  var _seq = 0;
	  /**
	   * The last processed sequence
	   * @type {number}
	   * @private
	   */

	  var _lastSeq = 0; // SOURCE GROUP RESERVED WORDS: ajax, data, url
	  // SOURCE ITEMS RESERVED KEYS: group, display, data, matchedKey, compiled, href

	  /**
	   * @constructor
	   * Typeahead Class
	   *
	   * @param {object} node jQuery input object
	   * @param {object} options User defined options
	   */

	  var Typeahead = function Typeahead(node, options) {
	    this.rawQuery = node.val() || ""; // Unmodified input query

	    this.query = node.val() || ""; // Input query

	    this.selector = node[0].selector; // Typeahead instance selector (to reach from window.Typeahead[SELECTOR])

	    this.deferred = null; // Promise when "input" event in triggered, this.node.triggerHandler('input').then(() => {})

	    this.tmpSource = {}; // Temp var to preserve the source order for the searchResult function

	    this.source = {}; // The generated source kept in memory

	    this.dynamicGroups = []; // Store the source groups that are defined as dynamic

	    this.hasDynamicGroups = false; // Boolean if at least one of the groups has a dynamic source

	    this.generatedGroupCount = 0; // Number of groups generated, if limit reached the search can be done

	    this.groupBy = "group"; // This option will change according to filtering or custom grouping

	    this.groups = []; // Array of all the available groups, used to build the groupTemplate

	    this.searchGroups = []; // Array of groups to generate when Typeahead searches data

	    this.generateGroups = []; // Array of groups to generate when Typeahead requests data

	    this.requestGroups = []; // Array of groups to request via Ajax

	    this.result = []; // Results based on Source-query match (only contains the displayed elements)

	    this.tmpResult = {}; // Temporary object of results, before they get passed to the buildLayout function

	    this.groupTemplate = ""; // Result template at the {{group}} level

	    this.resultHtml = null; // HTML Results (displayed elements)

	    this.resultCount = 0; // Total results based on Source-query match

	    this.resultCountPerGroup = {}; // Total results based on Source-query match per group

	    this.options = options; // Typeahead options (Merged default & user defined)

	    this.node = node; // jQuery object of the Typeahead <input>

	    this.namespace = "." + this.helper.slugify.call(this, this.selector) + _namespace; // Every Typeahead instance gets its own namespace for events

	    this.isContentEditable = typeof this.node.attr('contenteditable') !== "undefined" && this.node.attr('contenteditable') !== "false";
	    this.container = null; // Typeahead container, usually right after <form>

	    this.resultContainer = null; // Typeahead result container (html)

	    this.item = null; // Selected item

	    this.items = null; // Multiselect selected items

	    this.comparedItems = null; // Multiselect items stored for comparison

	    this.xhr = {}; // Ajax request(s) stack

	    this.hintIndex = null; // Numeric value of the hint index in the result list

	    this.filters = {
	      // Filter list for searching, dropdown and dynamic(s)
	      dropdown: {},
	      // Dropdown menu if options.dropdownFilter is set
	      dynamic: {} // Checkbox / Radio / Select to filter the source data

	    };
	    this.dropdownFilter = {
	      static: [],
	      // Objects that has a value
	      dynamic: []
	    };
	    this.dropdownFilterAll = null; // The last "all" definition

	    this.isDropdownEvent = false; // If a dropdownFilter is clicked, this will be true to trigger the callback

	    this.requests = {}; // Store the group:request instead of generating them every time

	    this.backdrop = {}; // The backdrop object

	    this.hint = {}; // The hint object

	    this.label = {}; // The label object

	    this.hasDragged = false; // Will cancel mouseend events if true

	    this.focusOnly = false; // Focus the input preventing any operations

	    this.displayEmptyTemplate; // Display the empty template in the result list

	    this.__construct();
	  };

	  Typeahead.prototype = {
	    _validateCacheMethod: function _validateCacheMethod(cache) {
	      var supportedCache = ["localStorage", "sessionStorage"],
	          supported;

	      if (cache === true) {
	        cache = "localStorage";
	      } else if (typeof cache === "string" && !~supportedCache.indexOf(cache)) {
	        // {debug}
	        if (this.options.debug) {
	          _debug.log({
	            node: this.selector,
	            function: "extendOptions()",
	            message: 'Invalid options.cache, possible options are "localStorage" or "sessionStorage"'
	          });

	          _debug.print();
	        } // {/debug}


	        return false;
	      }

	      supported = typeof window[cache] !== "undefined";

	      try {
	        window[cache].setItem("typeahead", "typeahead");
	        window[cache].removeItem("typeahead");
	      } catch (e) {
	        supported = false;
	      }

	      return supported && cache || false;
	    },
	    extendOptions: function extendOptions() {
	      this.options.cache = this._validateCacheMethod(this.options.cache);

	      if (this.options.compression) {
	        if ((typeof LZString === "undefined" ? "undefined" : _typeof_1(LZString)) !== "object" || !this.options.cache) {
	          // {debug}
	          if (this.options.debug) {
	            _debug.log({
	              node: this.selector,
	              function: "extendOptions()",
	              message: "Missing LZString Library or options.cache, no compression will occur."
	            });

	            _debug.print();
	          } // {/debug}


	          this.options.compression = false;
	        }
	      }

	      if (!this.options.maxLength || isNaN(this.options.maxLength)) {
	        this.options.maxLength = Infinity;
	      }

	      if (typeof this.options.maxItem !== "undefined" && ~[0, false].indexOf(this.options.maxItem)) {
	        this.options.maxItem = Infinity;
	      }

	      if (this.options.maxItemPerGroup && !/^\d+$/.test(this.options.maxItemPerGroup)) {
	        this.options.maxItemPerGroup = null;
	      }

	      if (this.options.display && !Array.isArray(this.options.display)) {
	        this.options.display = [this.options.display];
	      }

	      if (this.options.multiselect) {
	        this.items = [];
	        this.comparedItems = [];

	        if (typeof this.options.multiselect.matchOn === "string") {
	          this.options.multiselect.matchOn = [this.options.multiselect.matchOn];
	        }
	      }

	      if (this.options.group) {
	        if (!Array.isArray(this.options.group)) {
	          if (typeof this.options.group === "string") {
	            this.options.group = {
	              key: this.options.group
	            };
	          } else if (typeof this.options.group === "boolean") {
	            this.options.group = {
	              key: "group"
	            };
	          }

	          this.options.group.key = this.options.group.key || "group";
	        } else {
	          // {debug}
	          if (this.options.debug) {
	            _debug.log({
	              node: this.selector,
	              function: "extendOptions()",
	              message: "options.group must be a boolean|string|object as of 2.5.0"
	            });

	            _debug.print();
	          } // {/debug}

	        }
	      }

	      if (this.options.highlight && !~["any", true].indexOf(this.options.highlight)) {
	        this.options.highlight = false;
	      }

	      if (this.options.dropdownFilter && this.options.dropdownFilter instanceof Object) {
	        if (!Array.isArray(this.options.dropdownFilter)) {
	          this.options.dropdownFilter = [this.options.dropdownFilter];
	        }

	        for (var i = 0, ii = this.options.dropdownFilter.length; i < ii; ++i) {
	          this.dropdownFilter[this.options.dropdownFilter[i].value ? "static" : "dynamic"].push(this.options.dropdownFilter[i]);
	        }
	      }

	      if (this.options.dynamicFilter && !Array.isArray(this.options.dynamicFilter)) {
	        this.options.dynamicFilter = [this.options.dynamicFilter];
	      }

	      if (this.options.accent) {
	        if (_typeof_1(this.options.accent) === "object") {
	          if (this.options.accent.from && this.options.accent.to && this.options.accent.from.length !== this.options.accent.to.length) {
	            // {debug}
	            if (this.options.debug) {
	              _debug.log({
	                node: this.selector,
	                function: "extendOptions()",
	                message: 'Invalid "options.accent", from and to must be defined and same length.'
	              });

	              _debug.print();
	            } // {/debug}

	          }
	        } else {
	          this.options.accent = _accent;
	        }
	      }

	      if (this.options.groupTemplate) {
	        this.groupTemplate = this.options.groupTemplate;
	      }

	      if (this.options.resultContainer) {
	        if (typeof this.options.resultContainer === "string") {
	          this.options.resultContainer = $(this.options.resultContainer);
	        }

	        if (!(this.options.resultContainer instanceof $) || !this.options.resultContainer[0]) {
	          // {debug}
	          if (this.options.debug) {
	            _debug.log({
	              node: this.selector,
	              function: "extendOptions()",
	              message: 'Invalid jQuery selector or jQuery Object for "options.resultContainer".'
	            });

	            _debug.print();
	          } // {/debug}

	        } else {
	          this.resultContainer = this.options.resultContainer;
	        }
	      }

	      if (this.options.group && this.options.group.key) {
	        this.groupBy = this.options.group.key;
	      } // Compatibility onClick callback


	      if (this.options.callback && this.options.callback.onClick) {
	        this.options.callback.onClickBefore = this.options.callback.onClick;
	        delete this.options.callback.onClick;
	      } // Compatibility onNavigate callback


	      if (this.options.callback && this.options.callback.onNavigate) {
	        this.options.callback.onNavigateBefore = this.options.callback.onNavigate;
	        delete this.options.callback.onNavigate;
	      }

	      this.options = $.extend(true, {}, _options, this.options);
	    },
	    unifySourceFormat: function unifySourceFormat() {
	      this.dynamicGroups = []; // source: ['item1', 'item2', 'item3']

	      if (Array.isArray(this.options.source)) {
	        this.options.source = {
	          group: {
	            data: this.options.source
	          }
	        };
	      } // source: "http://www.test.com/url.json"


	      if (typeof this.options.source === "string") {
	        this.options.source = {
	          group: {
	            ajax: {
	              url: this.options.source
	            }
	          }
	        };
	      }

	      if (this.options.source.ajax) {
	        this.options.source = {
	          group: {
	            ajax: this.options.source.ajax
	          }
	        };
	      } // source: {data: ['item1', 'item2'], url: "http://www.test.com/url.json"}


	      if (this.options.source.url || this.options.source.data) {
	        this.options.source = {
	          group: this.options.source
	        };
	      }

	      var group, groupSource, tmpAjax;

	      for (group in this.options.source) {
	        if (!this.options.source.hasOwnProperty(group)) continue;
	        groupSource = this.options.source[group]; // source: {group: "http://www.test.com/url.json"}

	        if (typeof groupSource === "string") {
	          groupSource = {
	            ajax: {
	              url: groupSource
	            }
	          };
	        } // source: {group: {url: ["http://www.test.com/url.json", "json.path"]}}


	        tmpAjax = groupSource.url || groupSource.ajax;

	        if (Array.isArray(tmpAjax)) {
	          groupSource.ajax = typeof tmpAjax[0] === "string" ? {
	            url: tmpAjax[0]
	          } : tmpAjax[0];
	          groupSource.ajax.path = groupSource.ajax.path || tmpAjax[1] || null;
	          delete groupSource.url;
	        } else {
	          // source: {group: {url: {url: "http://www.test.com/url.json", method: "GET"}}}
	          // source: {group: {url: "http://www.test.com/url.json", dataType: "jsonp"}}
	          if (_typeof_1(groupSource.url) === "object") {
	            groupSource.ajax = groupSource.url;
	          } else if (typeof groupSource.url === "string") {
	            groupSource.ajax = {
	              url: groupSource.url
	            };
	          }

	          delete groupSource.url;
	        }

	        if (!groupSource.data && !groupSource.ajax) {
	          // {debug}
	          if (this.options.debug) {
	            _debug.log({
	              node: this.selector,
	              function: "unifySourceFormat()",
	              arguments: JSON.stringify(this.options.source),
	              message: 'Undefined "options.source.' + group + '.[data|ajax]" is Missing - Typeahead dropped'
	            });

	            _debug.print();
	          } // {/debug}


	          return false;
	        }

	        if (groupSource.display && !Array.isArray(groupSource.display)) {
	          groupSource.display = [groupSource.display];
	        }

	        groupSource.minLength = typeof groupSource.minLength === "number" ? groupSource.minLength : this.options.minLength;
	        groupSource.maxLength = typeof groupSource.maxLength === "number" ? groupSource.maxLength : this.options.maxLength;
	        groupSource.dynamic = typeof groupSource.dynamic === "boolean" || this.options.dynamic;

	        if (groupSource.minLength > groupSource.maxLength) {
	          groupSource.minLength = groupSource.maxLength;
	        }

	        this.options.source[group] = groupSource;

	        if (this.options.source[group].dynamic) {
	          this.dynamicGroups.push(group);
	        }

	        groupSource.cache = typeof groupSource.cache !== "undefined" ? this._validateCacheMethod(groupSource.cache) : this.options.cache;

	        if (groupSource.compression) {
	          if ((typeof LZString === "undefined" ? "undefined" : _typeof_1(LZString)) !== "object" || !groupSource.cache) {
	            // {debug}
	            if (this.options.debug) {
	              _debug.log({
	                node: this.selector,
	                function: "unifySourceFormat()",
	                message: "Missing LZString Library or group.cache, no compression will occur on group: " + group
	              });

	              _debug.print();
	            } // {/debug}


	            groupSource.compression = false;
	          }
	        }
	      }

	      this.hasDynamicGroups = this.options.dynamic || !!this.dynamicGroups.length;
	      return true;
	    },
	    init: function init() {
	      _lastSeq = 0;
	      this.helper.executeCallback.call(this, this.options.callback.onInit, [this.node]);
	      this.container = this.node.closest("." + this.options.selector.container); // {debug}

	      if (this.options.debug) {
	        _debug.log({
	          node: this.selector,
	          function: "init()",
	          //'arguments': JSON.stringify(this.options),
	          message: "OK - Typeahead activated on " + this.selector
	        });

	        _debug.print();
	      } // {/debug}

	    },
	    delegateEvents: function delegateEvents() {
	      var scope = this,
	          events = ["focus" + this.namespace, "input" + this.namespace, "propertychange" + this.namespace, // IE8 Fix
	      "keydown" + this.namespace, "keyup" + this.namespace, // IE9 Fix
	      "search" + this.namespace, "generate" + this.namespace]; // #149 - Adding support for Mobiles

	      $("html").on("touchmove", function () {
	        scope.hasDragged = true;
	      }).on("touchstart", function () {
	        scope.hasDragged = false;
	      });
	      this.node.closest("form").on("submit", function (e) {
	        if (scope.options.mustSelectItem && scope.helper.isEmpty(scope.item)) {
	          e.preventDefault();
	          return;
	        }

	        if (!scope.options.backdropOnFocus) {
	          scope.hideLayout();
	        }

	        if (scope.options.callback.onSubmit) {
	          return scope.helper.executeCallback.call(scope, scope.options.callback.onSubmit, [scope.node, this, scope.item || scope.items, e]);
	        }
	      }).on("reset", function () {
	        // #221 - Reset Typeahead on form reset.
	        // setTimeout to re-queue the `input.typeahead` event at the end
	        setTimeout(function () {
	          scope.node.trigger("input" + scope.namespace); // #243 - minLength: 0 opens the Typeahead results

	          scope.hideLayout();
	        });
	      }); // IE8 fix

	      var preventNextEvent = false; // IE10/11 fix

	      if (this.node.attr("placeholder") && (_isIE10 || _isIE11)) {
	        var preventInputEvent = true;
	        this.node.on("focusin focusout", function () {
	          preventInputEvent = !!(!this.value && this.placeholder);
	        });
	        this.node.on("input", function (e) {
	          if (preventInputEvent) {
	            e.stopImmediatePropagation();
	            preventInputEvent = false;
	          }
	        });
	      }

	      this.node.off(this.namespace).on(events.join(" "), function (e, data) {
	        switch (e.type) {
	          case "generate":
	            scope.generateSource(Object.keys(scope.options.source));
	            break;

	          case "focus":
	            if (scope.focusOnly) {
	              scope.focusOnly = false;
	              break;
	            }

	            if (scope.options.backdropOnFocus) {
	              scope.buildBackdropLayout();
	              scope.showLayout();
	            }

	            if (scope.options.searchOnFocus && !scope.item) {
	              scope.deferred = $.Deferred();
	              scope.assignQuery();
	              scope.generateSource();
	            }

	            break;

	          case "keydown":
	            if (e.keyCode === 8 && scope.options.multiselect && scope.options.multiselect.cancelOnBackspace && scope.query === '' && scope.items.length) {
	              scope.cancelMultiselectItem(scope.items.length - 1, null, e);
	            } else if (e.keyCode && ~[9, 13, 27, 38, 39, 40].indexOf(e.keyCode)) {
	              preventNextEvent = true;
	              scope.navigate(e);
	            }

	            break;

	          case "keyup":
	            if (_isIE9 && scope.node[0].value.replace(/^\s+/, "").toString().length < scope.query.length) {
	              scope.node.trigger("input" + scope.namespace);
	            }

	            break;

	          case "propertychange":
	            if (preventNextEvent) {
	              preventNextEvent = false;
	              break;
	            }

	          case "input":
	            scope.deferred = $.Deferred();
	            scope.assignQuery(); // #195 Trigger an onCancel event if the Typeahead is cleared

	            if (scope.rawQuery === "" && scope.query === "") {
	              e.originalEvent = data || {};
	              scope.helper.executeCallback.call(scope, scope.options.callback.onCancel, [scope.node, scope.item, e]);
	              scope.item = null;
	            }

	            scope.options.cancelButton && scope.toggleCancelButtonVisibility();

	            if (scope.options.hint && scope.hint.container && scope.hint.container.val() !== "") {
	              if (scope.hint.container.val().indexOf(scope.rawQuery) !== 0) {
	                scope.hint.container.val("");

	                if (scope.isContentEditable) {
	                  scope.hint.container.text("");
	                }
	              }
	            }

	            if (scope.hasDynamicGroups) {
	              scope.helper.typeWatch(function () {
	                scope.generateSource();
	              }, scope.options.delay);
	            } else {
	              scope.generateSource();
	            }

	            break;

	          case "search":
	            scope.searchResult();
	            scope.buildLayout();

	            if (scope.result.length || scope.searchGroups.length && scope.displayEmptyTemplate) {
	              scope.showLayout();
	            } else {
	              scope.hideLayout();
	            }

	            scope.deferred && scope.deferred.resolve();
	            break;
	        }

	        return scope.deferred && scope.deferred.promise();
	      });

	      if (this.options.generateOnLoad) {
	        this.node.trigger("generate" + this.namespace);
	      }
	    },
	    assignQuery: function assignQuery() {
	      if (this.isContentEditable) {
	        this.rawQuery = this.node.text();
	      } else {
	        this.rawQuery = this.node.val().toString();
	      }

	      this.rawQuery = this.rawQuery.replace(/^\s+/, "");

	      if (this.rawQuery !== this.query) {
	        this.query = this.rawQuery;
	      }
	    },
	    filterGenerateSource: function filterGenerateSource() {
	      this.searchGroups = [];
	      this.generateGroups = [];
	      if (this.focusOnly && !this.options.multiselect) return;

	      for (var group in this.options.source) {
	        if (!this.options.source.hasOwnProperty(group)) continue;

	        if (this.query.length >= this.options.source[group].minLength && this.query.length <= this.options.source[group].maxLength) {
	          if (this.filters.dropdown && this.filters.dropdown.key === 'group' && this.filters.dropdown.value !== group) {
	            continue;
	          }

	          this.searchGroups.push(group);

	          if (!this.options.source[group].dynamic && this.source[group]) {
	            continue;
	          }

	          this.generateGroups.push(group);
	        }
	      }
	    },
	    generateSource: function generateSource(generateGroups) {
	      this.filterGenerateSource();

	      if (Array.isArray(generateGroups) && generateGroups.length) {
	        this.generateGroups = generateGroups;
	      } else if (!this.generateGroups.length) {
	        this.node.trigger("search" + this.namespace);
	        return;
	      }

	      this.requestGroups = [];
	      this.generatedGroupCount = 0;
	      this.options.loadingAnimation && this.container.addClass("loading");

	      if (!this.helper.isEmpty(this.xhr)) {
	        for (var i in this.xhr) {
	          if (!this.xhr.hasOwnProperty(i)) continue;

	          if (this.options.abortAjax) {
	            this.xhr[i].abort();
	          }
	        }

	        this.xhr = {};
	      }

	      var scope = this,
	          group,
	          groupData,
	          groupSource,
	          cache,
	          compression,
	          dataInStorage,
	          isValidStorage;

	      for (var i = 0, ii = this.generateGroups.length; i < ii; ++i) {
	        group = this.generateGroups[i];
	        groupSource = this.options.source[group];
	        cache = groupSource.cache;
	        compression = groupSource.compression;

	        if (cache) {
	          dataInStorage = window[cache].getItem("TYPEAHEAD_" + this.selector + ":" + group);

	          if (dataInStorage) {
	            if (compression) {
	              dataInStorage = LZString.decompressFromUTF16(dataInStorage);
	            }

	            isValidStorage = false;

	            try {
	              dataInStorage = JSON.parse(dataInStorage + "");

	              if (dataInStorage.data && dataInStorage.ttl > new Date().getTime()) {
	                this.populateSource(dataInStorage.data, group);
	                isValidStorage = true; // {debug}

	                if (this.options.debug) {
	                  _debug.log({
	                    node: this.selector,
	                    function: "generateSource()",
	                    message: 'Source for group "' + group + '" found in ' + cache
	                  });

	                  _debug.print();
	                } // {/debug}

	              } else {
	                window[cache].removeItem("TYPEAHEAD_" + this.selector + ":" + group);
	              }
	            } catch (error) {}

	            if (isValidStorage) continue;
	          }
	        }

	        if (groupSource.data && !groupSource.ajax) {
	          // #198 Add support for async data source
	          if (typeof groupSource.data === "function") {
	            groupData = groupSource.data.call(this);

	            if (Array.isArray(groupData)) {
	              scope.populateSource(groupData, group);
	            } else if (typeof groupData.promise === "function") {
	              (function (group) {
	                $.when(groupData).then(function (deferredData) {
	                  if (deferredData && Array.isArray(deferredData)) {
	                    scope.populateSource(deferredData, group);
	                  }
	                });
	              })(group);
	            }
	          } else {
	            this.populateSource($.extend(true, [], groupSource.data), group);
	          }

	          continue;
	        }

	        if (groupSource.ajax) {
	          if (!this.requests[group]) {
	            this.requests[group] = this.generateRequestObject(group);
	          }

	          this.requestGroups.push(group);
	        }
	      }

	      if (this.requestGroups.length) {
	        this.handleRequests();
	      }

	      return !!this.generateGroups.length;
	    },
	    generateRequestObject: function generateRequestObject(group) {
	      var scope = this,
	          groupSource = this.options.source[group];
	      var xhrObject = {
	        request: {
	          url: groupSource.ajax.url || null,
	          dataType: "json",
	          beforeSend: function beforeSend(jqXHR, options) {
	            // Important to call .abort() in case of dynamic requests
	            scope.xhr[group] = jqXHR;

	            if (!scope.options.abortAjax) {
	              jqXHR.seq = _seq;
	              _seq++;
	            }

	            var beforeSend = scope.requests[group].callback.beforeSend || groupSource.ajax.beforeSend;
	            typeof beforeSend === "function" && beforeSend.apply(null, arguments);
	          }
	        },
	        callback: {
	          beforeSend: null,
	          done: null,
	          fail: null,
	          then: null,
	          always: null
	        },
	        extra: {
	          path: groupSource.ajax.path || null,
	          group: group
	        },
	        validForGroup: [group]
	      };

	      if (typeof groupSource.ajax !== "function") {
	        if (groupSource.ajax instanceof Object) {
	          xhrObject = this.extendXhrObject(xhrObject, groupSource.ajax);
	        }

	        if (Object.keys(this.options.source).length > 1) {
	          for (var _group in this.requests) {
	            if (!this.requests.hasOwnProperty(_group)) continue;
	            if (this.requests[_group].isDuplicated) continue;

	            if (xhrObject.request.url && xhrObject.request.url === this.requests[_group].request.url) {
	              this.requests[_group].validForGroup.push(group);

	              xhrObject.isDuplicated = true;
	              delete xhrObject.validForGroup;
	            }
	          }
	        }
	      }

	      return xhrObject;
	    },
	    extendXhrObject: function extendXhrObject(xhrObject, groupRequest) {
	      if (_typeof_1(groupRequest.callback) === "object") {
	        xhrObject.callback = groupRequest.callback;
	        delete groupRequest.callback;
	      } // #132 Fixed beforeSend when using a function as the request object


	      if (typeof groupRequest.beforeSend === "function") {
	        xhrObject.callback.beforeSend = groupRequest.beforeSend;
	        delete groupRequest.beforeSend;
	      } // Fixes #105 Allow user to define their beforeSend function.
	      // Fixes #181 IE8 incompatibility


	      xhrObject.request = $.extend(true, xhrObject.request, groupRequest); // JSONP needs a unique jsonpCallback to run concurrently

	      if (xhrObject.request.dataType.toLowerCase() === "jsonp" && !xhrObject.request.jsonpCallback) {
	        xhrObject.request.jsonpCallback = "callback_" + xhrObject.extra.group;
	      }

	      return xhrObject;
	    },
	    handleRequests: function handleRequests() {
	      var scope = this,
	          group,
	          requestsCount = this.requestGroups.length;

	      if (this.helper.executeCallback.call(this, this.options.callback.onSendRequest, [this.node, this.query]) === false) {
	        return;
	      }

	      for (var i = 0, ii = this.requestGroups.length; i < ii; ++i) {
	        group = this.requestGroups[i];
	        if (this.requests[group].isDuplicated) continue;

	        (function (group, xhrObject) {
	          if (typeof scope.options.source[group].ajax === "function") {
	            var _groupRequest = scope.options.source[group].ajax.call(scope, scope.query); // Fixes #271 Data is cached inside the xhrObject


	            xhrObject = scope.extendXhrObject(scope.generateRequestObject(group), _typeof_1(_groupRequest) === "object" ? _groupRequest : {});

	            if (_typeof_1(xhrObject.request) !== "object" || !xhrObject.request.url) {
	              // {debug}
	              if (scope.options.debug) {
	                _debug.log({
	                  node: scope.selector,
	                  function: "handleRequests",
	                  message: 'Source function must return an object containing ".url" key for group "' + group + '"'
	                });

	                _debug.print();
	              } // {/debug}


	              scope.populateSource([], group);
	              return;
	            }

	            scope.requests[group] = xhrObject;
	          }

	          var _request,
	              _isExtended = false,
	              // Prevent the main request from being changed
	          _groupData = {};

	          if (~xhrObject.request.url.indexOf("{{query}}")) {
	            if (!_isExtended) {
	              xhrObject = $.extend(true, {}, xhrObject);
	              _isExtended = true;
	            } // #184 Invalid encoded characters on dynamic requests for `{{query}}`


	            xhrObject.request.url = xhrObject.request.url.replace("{{query}}", encodeURIComponent(scope.query));
	          }

	          if (xhrObject.request.data) {
	            for (var i in xhrObject.request.data) {
	              if (!xhrObject.request.data.hasOwnProperty(i)) continue;

	              if (~String(xhrObject.request.data[i]).indexOf("{{query}}")) {
	                if (!_isExtended) {
	                  xhrObject = $.extend(true, {}, xhrObject);
	                  _isExtended = true;
	                } // jQuery handles encodeURIComponent when the query is inside the data object


	                xhrObject.request.data[i] = xhrObject.request.data[i].replace("{{query}}", scope.query);
	                break;
	              }
	            }
	          }

	          $.ajax(xhrObject.request).done(function (data, textStatus, jqXHR) {
	            var _group;

	            for (var i = 0, ii = xhrObject.validForGroup.length; i < ii; i++) {
	              _group = xhrObject.validForGroup[i];
	              _request = scope.requests[_group];

	              if (typeof _request.callback.done === 'function') {
	                _groupData[_group] = _request.callback.done.call(scope, data, textStatus, jqXHR); // {debug}

	                if (!Array.isArray(_groupData[_group]) || _typeof_1(_groupData[_group]) !== "object") {
	                  if (scope.options.debug) {
	                    _debug.log({
	                      node: scope.selector,
	                      function: "Ajax.callback.done()",
	                      message: "Invalid returned data has to be an Array"
	                    });

	                    _debug.print();
	                  }
	                } // {/debug}

	              }
	            }
	          }).fail(function (jqXHR, textStatus, errorThrown) {
	            for (var i = 0, ii = xhrObject.validForGroup.length; i < ii; i++) {
	              _request = scope.requests[xhrObject.validForGroup[i]];
	              _request.callback.fail instanceof Function && _request.callback.fail.call(scope, jqXHR, textStatus, errorThrown);
	            } // {debug}


	            if (scope.options.debug) {
	              _debug.log({
	                node: scope.selector,
	                function: "Ajax.callback.fail()",
	                arguments: JSON.stringify(xhrObject.request),
	                message: textStatus
	              });

	              console.log(errorThrown);

	              _debug.print();
	            } // {/debug}

	          }).always(function (data, textStatus, jqXHR) {
	            var _group;

	            for (var i = 0, ii = xhrObject.validForGroup.length; i < ii; i++) {
	              _group = xhrObject.validForGroup[i];
	              _request = scope.requests[_group];
	              _request.callback.always instanceof Function && _request.callback.always.call(scope, data, textStatus, jqXHR); // #248, #303 Aborted requests would call populate with invalid data

	              if (textStatus === 'abort') return; // If aborting ajax request is disaled, check to make sure that this request is not older than previous requests

	              if (!scope.options.abortAjax) {
	                if (jqXHR.seq < _lastSeq) {
	                  return;
	                } else {
	                  _lastSeq = jqXHR.seq;
	                }
	              } // #265 Modified data from ajax.callback.done is not being registered (use of _groupData[_group])


	              scope.populateSource(data !== null && typeof data.promise === "function" && [] || _groupData[_group] || data, _request.extra.group, _request.extra.path || _request.request.path);
	              requestsCount -= 1;

	              if (requestsCount === 0) {
	                scope.helper.executeCallback.call(scope, scope.options.callback.onReceiveRequest, [scope.node, scope.query]);
	              }
	            }
	          }).then(function (jqXHR, textStatus) {
	            for (var i = 0, ii = xhrObject.validForGroup.length; i < ii; i++) {
	              _request = scope.requests[xhrObject.validForGroup[i]];
	              _request.callback.then instanceof Function && _request.callback.then.call(scope, jqXHR, textStatus);
	            }
	          });
	        })(group, this.requests[group]);
	      }
	    },

	    /**
	     * Build the source groups to be cycled for matched results
	     *
	     * @param {Array} data Array of Strings or Array of Objects
	     * @param {String} group
	     * @param {String} [path]
	     * @return {*}
	     */
	    populateSource: function populateSource(data, group, path) {
	      var scope = this,
	          groupSource = this.options.source[group],
	          extraData = groupSource.ajax && groupSource.data;

	      if (path && typeof path === "string") {
	        data = this.helper.namespace.call(this, path, data);
	      }

	      if (typeof data === "undefined") {
	        // {debug}
	        if (this.options.debug) {
	          _debug.log({
	            node: this.selector,
	            function: "populateSource()",
	            arguments: path,
	            message: "Invalid data path."
	          });

	          _debug.print();
	        } // {/debug}

	      }

	      if (!Array.isArray(data)) {
	        // {debug}
	        if (this.options.debug) {
	          _debug.log({
	            node: this.selector,
	            function: "populateSource()",
	            arguments: JSON.stringify({
	              group: group
	            }),
	            message: "Invalid data type, must be Array type."
	          });

	          _debug.print();
	        } // {/debug}


	        data = [];
	      }

	      if (extraData) {
	        if (typeof extraData === "function") {
	          extraData = extraData();
	        }

	        if (Array.isArray(extraData)) {
	          data = data.concat(extraData);
	        } else {
	          // {debug}
	          if (this.options.debug) {
	            _debug.log({
	              node: this.selector,
	              function: "populateSource()",
	              arguments: JSON.stringify(extraData),
	              message: "WARNING - this.options.source." + group + ".data Must be an Array or a function that returns an Array."
	            });

	            _debug.print();
	          } // {/debug}

	        }
	      }

	      var tmpObj,
	          display = groupSource.display ? groupSource.display[0] === "compiled" ? groupSource.display[1] : groupSource.display[0] : this.options.display[0] === "compiled" ? this.options.display[1] : this.options.display[0];

	      for (var i = 0, ii = data.length; i < ii; i++) {
	        if (data[i] === null || typeof data[i] === "boolean") {
	          // {debug}
	          if (this.options.debug) {
	            _debug.log({
	              node: this.selector,
	              function: "populateSource()",
	              message: "WARNING - NULL/BOOLEAN value inside " + group + "! The data was skipped."
	            });

	            _debug.print();
	          } // {/debug}


	          continue;
	        }

	        if (typeof data[i] === "string") {
	          tmpObj = {};
	          tmpObj[display] = data[i];
	          data[i] = tmpObj;
	        }

	        data[i].group = group;
	      }

	      if (!this.hasDynamicGroups && this.dropdownFilter.dynamic.length) {
	        var key,
	            value,
	            tmpValues = {};

	        for (var i = 0, ii = data.length; i < ii; i++) {
	          for (var k = 0, kk = this.dropdownFilter.dynamic.length; k < kk; k++) {
	            key = this.dropdownFilter.dynamic[k].key;
	            value = data[i][key];
	            if (!value) continue;

	            if (!this.dropdownFilter.dynamic[k].value) {
	              this.dropdownFilter.dynamic[k].value = [];
	            }

	            if (!tmpValues[key]) {
	              tmpValues[key] = [];
	            }

	            if (!~tmpValues[key].indexOf(value.toLowerCase())) {
	              tmpValues[key].push(value.toLowerCase());
	              this.dropdownFilter.dynamic[k].value.push(value);
	            }
	          }
	        }
	      }

	      if (this.options.correlativeTemplate) {
	        var template = groupSource.template || this.options.template,
	            compiledTemplate = "";

	        if (typeof template === "function") {
	          template = template.call(this, "", {});
	        }

	        if (!template) {
	          // {debug}
	          if (this.options.debug) {
	            _debug.log({
	              node: this.selector,
	              function: "populateSource()",
	              arguments: String(group),
	              message: "WARNING - this.options.correlativeTemplate is enabled but no template was found."
	            });

	            _debug.print();
	          } // {/debug}

	        } else {
	          // #109 correlativeTemplate can be an array of display keys instead of the complete template
	          if (Array.isArray(this.options.correlativeTemplate)) {
	            for (var i = 0, ii = this.options.correlativeTemplate.length; i < ii; i++) {
	              compiledTemplate += "{{" + this.options.correlativeTemplate[i] + "}} ";
	            }
	          } else {
	            // Strip down the html tags, #351 if the template needs "<>" use html entities instead &#60;{{email}}&#62;
	            compiledTemplate = template.replace(/<.+?>/g, " ").replace(/\s{2,}/, " ").trim();
	          }

	          for (var i = 0, ii = data.length; i < ii; i++) {
	            // Fix #351, convert htmlEntities from the template string
	            data[i].compiled = $("<textarea />").html(compiledTemplate.replace(/\{\{([\w\-\.]+)(?:\|(\w+))?}}/g, function (match, index) {
	              return scope.helper.namespace.call(scope, index, data[i], "get", "");
	            }).trim()).text();
	          }

	          if (groupSource.display) {
	            if (!~groupSource.display.indexOf("compiled")) {
	              groupSource.display.unshift("compiled");
	            }
	          } else if (!~this.options.display.indexOf("compiled")) {
	            this.options.display.unshift("compiled");
	          }
	        }
	      }

	      if (this.options.callback.onPopulateSource) {
	        data = this.helper.executeCallback.call(this, this.options.callback.onPopulateSource, [this.node, data, group, path]); // {debug}

	        if (this.options.debug) {
	          if (!data || !Array.isArray(data)) {
	            _debug.log({
	              node: this.selector,
	              function: "callback.populateSource()",
	              message: 'callback.onPopulateSource must return the "data" parameter'
	            });

	            _debug.print();
	          }
	        } // {/debug}

	      } // Save the data inside tmpSource to re-order once every requests are completed


	      this.tmpSource[group] = Array.isArray(data) && data || [];
	      var cache = this.options.source[group].cache,
	          compression = this.options.source[group].compression,
	          ttl = this.options.source[group].ttl || this.options.ttl;

	      if (cache && !window[cache].getItem("TYPEAHEAD_" + this.selector + ":" + group)) {
	        if (this.options.callback.onCacheSave) {
	          data = this.helper.executeCallback.call(this, this.options.callback.onCacheSave, [this.node, data, group, path]); // {debug}

	          if (this.options.debug) {
	            if (!data || !Array.isArray(data)) {
	              _debug.log({
	                node: this.selector,
	                function: "callback.populateSource()",
	                message: 'callback.onCacheSave must return the "data" parameter'
	              });

	              _debug.print();
	            }
	          } // {/debug}

	        }

	        var storage = JSON.stringify({
	          data: data,
	          ttl: new Date().getTime() + ttl
	        });

	        if (compression) {
	          storage = LZString.compressToUTF16(storage);
	        }

	        window[cache].setItem("TYPEAHEAD_" + this.selector + ":" + group, storage);
	      }

	      this.incrementGeneratedGroup();
	    },
	    incrementGeneratedGroup: function incrementGeneratedGroup() {
	      this.generatedGroupCount++;

	      if (!this.options.abortAjax) {
	        if (this.generatedGroupCount !== this.generateGroups.length) ;
	      }

	      this.xhr = {};

	      for (var i = 0, ii = this.generateGroups.length; i < ii; i++) {
	        this.source[this.generateGroups[i]] = this.tmpSource[this.generateGroups[i]];
	      }

	      if (!this.hasDynamicGroups) {
	        this.buildDropdownItemLayout("dynamic");
	      }

	      this.options.loadingAnimation && this.container.removeClass("loading");
	      this.node.trigger("search" + this.namespace);
	    },

	    /**
	     * Key Navigation
	     * tab 9: if option is enabled, blur Typeahead
	     * Up 38: select previous item, skip "group" item
	     * Down 40: select next item, skip "group" item
	     * Right 39: change charAt, if last char fill hint (if options is true)
	     * Esc 27: clears input (is not empty) / blur (if empty)
	     * Enter 13: Select item + submit search
	     *
	     * @param {Object} e Event object
	     * @returns {*}
	     */
	    navigate: function navigate(e) {
	      this.helper.executeCallback.call(this, this.options.callback.onNavigateBefore, [this.node, this.query, e]);

	      if (e.keyCode === 27) {
	        // #166 Different browsers do not have the same behaviors by default, lets enforce what we want instead
	        e.preventDefault();

	        if (this.query.length) {
	          this.resetInput();
	          this.node.trigger("input" + this.namespace, [e]);
	        } else {
	          this.node.blur();
	          this.hideLayout();
	        }

	        return;
	      }

	      if (!this.result.length) return;
	      var itemList = this.resultContainer.find("." + this.options.selector.item).not("[disabled]"),
	          activeItem = itemList.filter(".active"),
	          activeItemIndex = activeItem[0] ? itemList.index(activeItem) : null,
	          activeDataIndex = activeItem[0] ? activeItem.attr("data-index") : null,
	          newActiveItemIndex = null,
	          newActiveDataIndex = null;
	      this.clearActiveItem();
	      this.helper.executeCallback.call(this, this.options.callback.onLeave, [this.node, activeItemIndex !== null && itemList.eq(activeItemIndex) || undefined, activeDataIndex !== null && this.result[activeDataIndex] || undefined, e]);

	      if (e.keyCode === 13) {
	        // Chrome needs preventDefault else the input search event is triggered
	        e.preventDefault(); // select if only one item

	        if (itemList.length === 1) {
	          itemList.click();
	        }

	        if (activeItem.length > 0) {
	          // #311 When href is defined and "enter" is pressed, it needs to act as a "clicked" link
	          if (activeItem.find("a:first")[0].href === "javascript:;") {
	            activeItem.find("a:first").trigger("click", e);
	          } else {
	            activeItem.find("a:first")[0].click();
	          }
	        } else {
	          this.node.closest("form").trigger("submit");
	        }

	        return;
	      }

	      if (e.keyCode === 15802020) {
	        if (activeItemIndex !== null) {
	          itemList.eq(activeItemIndex).find("a:first")[0].click();
	        } else if (this.options.hint && this.hint.container.val() !== "" && this.helper.getCaret(this.node[0]) >= this.query.length) {
	          itemList.filter('[data-index="' + this.hintIndex + '"]').find("a:first")[0].click();
	        }

	        return;
	      } // #284 Blur Typeahead when "Tab" key is pressed
	      // #326 Improve Up / Down / Tab navigation to have only 1 "selected" item


	      if (e.keyCode === 9) {
	        if (this.options.blurOnTab) {
	          this.hideLayout();
	        } else {
	          if (activeItem.length > 0) {
	            if (activeItemIndex + 1 < itemList.length) {
	              e.preventDefault();
	              newActiveItemIndex = activeItemIndex + 1;
	              this.addActiveItem(itemList.eq(newActiveItemIndex));
	            } else {
	              this.hideLayout();
	            }
	          } else {
	            if (itemList.length) {
	              e.preventDefault();
	              newActiveItemIndex = 0;
	              this.addActiveItem(itemList.first());
	            } else {
	              this.hideLayout();
	            }
	          }
	        }
	      } else if (e.keyCode === 38) {
	        e.preventDefault();

	        if (activeItem.length > 0) {
	          if (activeItemIndex - 1 >= 0) {
	            newActiveItemIndex = activeItemIndex - 1;
	            this.addActiveItem(itemList.eq(newActiveItemIndex));
	          }
	        } else if (itemList.length) {
	          newActiveItemIndex = itemList.length - 1;
	          this.addActiveItem(itemList.last());
	        }
	      } else if (e.keyCode === 40) {
	        e.preventDefault();

	        if (activeItem.length > 0) {
	          if (activeItemIndex + 1 < itemList.length) {
	            newActiveItemIndex = activeItemIndex + 1;
	            this.addActiveItem(itemList.eq(newActiveItemIndex));
	          }
	        } else if (itemList.length) {
	          newActiveItemIndex = 0;
	          this.addActiveItem(itemList.first());
	        }
	      }

	      newActiveDataIndex = newActiveItemIndex !== null ? itemList.eq(newActiveItemIndex).attr("data-index") : null;
	      this.helper.executeCallback.call(this, this.options.callback.onEnter, [this.node, newActiveItemIndex !== null && itemList.eq(newActiveItemIndex) || undefined, newActiveDataIndex !== null && this.result[newActiveDataIndex] || undefined, e]); // #115 Prevent the input from changing when navigating (arrow up / down) the results

	      if (e.preventInputChange && ~[38, 40].indexOf(e.keyCode)) {
	        this.buildHintLayout(newActiveDataIndex !== null && newActiveDataIndex < this.result.length ? [this.result[newActiveDataIndex]] : null);
	      }

	      if (this.options.hint && this.hint.container) {
	        this.hint.container.css("color", e.preventInputChange ? this.hint.css.color : newActiveDataIndex === null && this.hint.css.color || this.hint.container.css("background-color") || "fff");
	      }

	      var nodeValue = newActiveDataIndex === null || e.preventInputChange ? this.rawQuery : this.getTemplateValue.call(this, this.result[newActiveDataIndex]);
	      this.node.val(nodeValue);

	      if (this.isContentEditable) {
	        this.node.text(nodeValue);
	      }

	      this.helper.executeCallback.call(this, this.options.callback.onNavigateAfter, [this.node, itemList, newActiveItemIndex !== null && itemList.eq(newActiveItemIndex).find("a:first") || undefined, newActiveDataIndex !== null && this.result[newActiveDataIndex] || undefined, this.query, e]);
	    },
	    getTemplateValue: function getTemplateValue(item) {
	      if (!item) return;
	      var templateValue = item.group && this.options.source[item.group].templateValue || this.options.templateValue;

	      if (typeof templateValue === "function") {
	        templateValue = templateValue.call(this);
	      }

	      if (!templateValue) {
	        return this.helper.namespace.call(this, item.matchedKey, item).toString();
	      }

	      var scope = this;
	      return templateValue.replace(/\{\{([\w\-.]+)}}/gi, function (match, index) {
	        return scope.helper.namespace.call(scope, index, item, "get", "");
	      });
	    },
	    clearActiveItem: function clearActiveItem() {
	      this.resultContainer.find("." + this.options.selector.item).removeClass("active");
	    },
	    addActiveItem: function addActiveItem(item) {
	      item.addClass("active");
	    },
	    searchResult: function searchResult() {
	      this.resetLayout();
	      if (this.helper.executeCallback.call(this, this.options.callback.onSearch, [this.node, this.query]) === false) return;

	      if (this.searchGroups.length && !(this.options.multiselect && this.options.multiselect.limit && this.items.length >= this.options.multiselect.limit)) {
	        this.searchResultData();
	      }

	      this.helper.executeCallback.call(this, this.options.callback.onResult, [this.node, this.query, this.result, this.resultCount, this.resultCountPerGroup]);

	      if (this.isDropdownEvent) {
	        this.helper.executeCallback.call(this, this.options.callback.onDropdownFilter, [this.node, this.query, this.filters.dropdown, this.result]);
	        this.isDropdownEvent = false;
	      }
	    },
	    searchResultData: function searchResultData() {
	      var scope = this,
	          group,
	          groupBy = this.groupBy,
	          groupReference = null,
	          item,
	          match,
	          comparedDisplay,
	          comparedQuery = this.query.toLowerCase(),
	          maxItem = this.options.maxItem,
	          maxItemPerGroup = this.options.maxItemPerGroup,
	          hasDynamicFilters = this.filters.dynamic && !this.helper.isEmpty(this.filters.dynamic),
	          displayKeys,
	          displayValue,
	          missingDisplayKey = {},
	          groupFilter,
	          groupFilterResult,
	          groupMatcher,
	          groupMatcherResult,
	          matcher = typeof this.options.matcher === "function" && this.options.matcher,
	          correlativeMatch,
	          correlativeQuery,
	          correlativeDisplay;

	      if (this.options.accent) {
	        comparedQuery = this.helper.removeAccent.call(this, comparedQuery);
	      }

	      for (var i = 0, ii = this.searchGroups.length; i < ii; ++i) {
	        group = this.searchGroups[i];
	        if (this.filters.dropdown && this.filters.dropdown.key === "group" && this.filters.dropdown.value !== group) continue;
	        groupFilter = typeof this.options.source[group].filter !== "undefined" ? this.options.source[group].filter : this.options.filter;
	        groupMatcher = typeof this.options.source[group].matcher === "function" && this.options.source[group].matcher || matcher;

	        for (var k = 0, kk = this.source[group].length; k < kk; k++) {
	          if (this.resultItemCount >= maxItem && !this.options.callback.onResult) break;
	          if (hasDynamicFilters && !this.dynamicFilter.validate.apply(this, [this.source[group][k]])) continue;
	          item = this.source[group][k]; // Validation over null item

	          if (item === null || typeof item === "boolean") continue;
	          if (this.options.multiselect && !this.isMultiselectUniqueData(item)) continue; // dropdownFilter by custom groups

	          if (this.filters.dropdown && (item[this.filters.dropdown.key] || "").toLowerCase() !== (this.filters.dropdown.value || "").toLowerCase()) {
	            continue;
	          }

	          groupReference = groupBy === "group" ? group : item[groupBy] ? item[groupBy] : item.group;

	          if (groupReference && !this.tmpResult[groupReference]) {
	            this.tmpResult[groupReference] = [];
	            this.resultCountPerGroup[groupReference] = 0;
	          }

	          if (maxItemPerGroup) {
	            if (groupBy === "group" && this.tmpResult[groupReference].length >= maxItemPerGroup && !this.options.callback.onResult) {
	              break;
	            }
	          }

	          displayKeys = this.options.source[group].display || this.options.display;

	          for (var v = 0, vv = displayKeys.length; v < vv; ++v) {
	            // #286 option.filter: false shouldn't bother about the option.display keys
	            if (groupFilter !== false) {
	              // #183 Allow searching for deep source object keys
	              displayValue = /\./.test(displayKeys[v]) ? this.helper.namespace.call(this, displayKeys[v], item) : item[displayKeys[v]]; // #182 Continue looping if empty or undefined key

	              if (typeof displayValue === "undefined" || displayValue === "") {
	                // {debug}
	                if (this.options.debug) {
	                  missingDisplayKey[v] = {
	                    display: displayKeys[v],
	                    data: item
	                  };
	                } // {/debug}


	                continue;
	              }

	              displayValue = this.helper.cleanStringFromScript(displayValue);
	            }

	            if (typeof groupFilter === "function") {
	              groupFilterResult = groupFilter.call(this, item, displayValue); // return undefined to skip to next item
	              // return false to attempt the matching function on the next displayKey
	              // return true to add the item to the result list
	              // return item object to modify the item and add it to the result list

	              if (groupFilterResult === undefined) break;
	              if (!groupFilterResult) continue;

	              if (_typeof_1(groupFilterResult) === "object") {
	                item = groupFilterResult;
	              }
	            }

	            if (~[undefined, true].indexOf(groupFilter)) {
	              if (displayValue === null) continue;
	              comparedDisplay = displayValue;
	              comparedDisplay = comparedDisplay.toString().toLowerCase();

	              if (this.options.accent) {
	                comparedDisplay = this.helper.removeAccent.call(this, comparedDisplay);
	              }

	              match = comparedDisplay.indexOf(comparedQuery);

	              if (this.options.correlativeTemplate && displayKeys[v] === "compiled" && match < 0 && /\s/.test(comparedQuery)) {
	                correlativeMatch = true;
	                correlativeQuery = comparedQuery.split(" ");
	                correlativeDisplay = comparedDisplay;

	                for (var x = 0, xx = correlativeQuery.length; x < xx; x++) {
	                  if (correlativeQuery[x] === "") continue;

	                  if (!~correlativeDisplay.indexOf(correlativeQuery[x])) {
	                    correlativeMatch = false;
	                    break;
	                  }

	                  correlativeDisplay = correlativeDisplay.replace(correlativeQuery[x], "");
	                }
	              }

	              if (match < 0 && !correlativeMatch) continue;
	              if (this.options.offset && match !== 0) continue;

	              if (groupMatcher) {
	                groupMatcherResult = groupMatcher.call(this, item, displayValue); // return undefined to skip to next item
	                // return false to attempt the matching function on the next displayKey
	                // return true to add the item to the result list
	                // return item object to modify the item and add it to the result list

	                if (groupMatcherResult === undefined) break;
	                if (!groupMatcherResult) continue;

	                if (_typeof_1(groupMatcherResult) === "object") {
	                  item = groupMatcherResult;
	                }
	              }
	            }

	            this.resultCount++;
	            this.resultCountPerGroup[groupReference]++;

	            if (this.resultItemCount < maxItem) {
	              if (maxItemPerGroup && this.tmpResult[groupReference].length >= maxItemPerGroup) {
	                break;
	              }

	              this.tmpResult[groupReference].push($.extend(true, {
	                matchedKey: displayKeys[v]
	              }, item));
	              this.resultItemCount++;
	            }

	            break;
	          }

	          if (!this.options.callback.onResult) {
	            if (this.resultItemCount >= maxItem) {
	              break;
	            }

	            if (maxItemPerGroup && this.tmpResult[groupReference].length >= maxItemPerGroup) {
	              if (groupBy === "group") {
	                break;
	              }
	            }
	          }
	        }
	      } // {debug}


	      if (this.options.debug) {
	        if (!this.helper.isEmpty(missingDisplayKey)) {
	          _debug.log({
	            node: this.selector,
	            function: "searchResult()",
	            arguments: JSON.stringify(missingDisplayKey),
	            message: "Missing keys for display, make sure options.display is set properly."
	          });

	          _debug.print();
	        }
	      } // {/debug}


	      if (this.options.order) {
	        var displayKeys = [],
	            displayKey;

	        for (var group in this.tmpResult) {
	          if (!this.tmpResult.hasOwnProperty(group)) continue;

	          for (var i = 0, ii = this.tmpResult[group].length; i < ii; i++) {
	            displayKey = this.options.source[this.tmpResult[group][i].group].display || this.options.display;

	            if (!~displayKeys.indexOf(displayKey[0])) {
	              displayKeys.push(displayKey[0]);
	            }
	          }

	          this.tmpResult[group].sort(scope.helper.sort(displayKeys, scope.options.order === "asc", function (a) {
	            return a.toString().toUpperCase();
	          }));
	        }
	      }

	      var concatResults = [],
	          groupOrder = [];

	      if (typeof this.options.groupOrder === "function") {
	        groupOrder = this.options.groupOrder.apply(this, [this.node, this.query, this.tmpResult, this.resultCount, this.resultCountPerGroup]);
	      } else if (Array.isArray(this.options.groupOrder)) {
	        groupOrder = this.options.groupOrder;
	      } else if (typeof this.options.groupOrder === "string" && ~["asc", "desc"].indexOf(this.options.groupOrder)) {
	        groupOrder = Object.keys(this.tmpResult).sort(scope.helper.sort([], scope.options.groupOrder === "asc", function (a) {
	          return a.toString().toUpperCase();
	        }));
	      } else {
	        groupOrder = Object.keys(this.tmpResult);
	      }

	      for (var i = 0, ii = groupOrder.length; i < ii; i++) {
	        concatResults = concatResults.concat(this.tmpResult[groupOrder[i]] || []);
	      } // #286 groupTemplate option was deleting group reference Array


	      this.groups = JSON.parse(JSON.stringify(groupOrder));
	      this.result = concatResults;
	    },
	    buildLayout: function buildLayout() {
	      this.buildHtmlLayout();
	      this.buildBackdropLayout();
	      this.buildHintLayout();

	      if (this.options.callback.onLayoutBuiltBefore) {
	        this.tmpResultHtml = this.helper.executeCallback.call(this, this.options.callback.onLayoutBuiltBefore, [this.node, this.query, this.result, this.resultHtml]);
	      }

	      if (this.tmpResultHtml instanceof $) {
	        this.resultContainer.html(this.tmpResultHtml);
	      } else if (this.resultHtml instanceof $) {
	        this.resultContainer.html(this.resultHtml);
	      }

	      if (this.options.callback.onLayoutBuiltAfter) {
	        this.helper.executeCallback.call(this, this.options.callback.onLayoutBuiltAfter, [this.node, this.query, this.result]);
	      }
	    },
	    buildHtmlLayout: function buildHtmlLayout() {
	      // #150 Add the option to have no resultList but still perform the search and trigger the callbacks
	      if (this.options.resultContainer === false) return;

	      if (!this.resultContainer) {
	        this.resultContainer = $("<div/>", {
	          class: this.options.selector.result
	        });
	        this.container.append(this.resultContainer);
	      }

	      var emptyTemplate;

	      if (!this.result.length) {
	        if (this.options.multiselect && this.options.multiselect.limit && this.items.length >= this.options.multiselect.limit) {
	          if (this.options.multiselect.limitTemplate) {
	            emptyTemplate = typeof this.options.multiselect.limitTemplate === "function" ? this.options.multiselect.limitTemplate.call(this, this.query) : this.options.multiselect.limitTemplate.replace(/\{\{query}}/gi, $("<div>").text(this.helper.cleanStringFromScript(this.query)).html());
	          } else {
	            emptyTemplate = "Can't select more than " + this.items.length + " items.";
	          }
	        } else if (this.options.emptyTemplate && this.query !== "") {
	          emptyTemplate = typeof this.options.emptyTemplate === "function" ? this.options.emptyTemplate.call(this, this.query) : this.options.emptyTemplate.replace(/\{\{query}}/gi, $("<div>").text(this.helper.cleanStringFromScript(this.query)).html());
	        } else {
	          return;
	        }
	      }

	      this.displayEmptyTemplate = !!emptyTemplate;

	      var _query = this.query.toLowerCase();

	      if (this.options.accent) {
	        _query = this.helper.removeAccent.call(this, _query);
	      }

	      var scope = this,
	          groupTemplate = this.groupTemplate || "<ul></ul>",
	          hasEmptyTemplate = false;

	      if (this.groupTemplate) {
	        groupTemplate = $(groupTemplate.replace(/<([^>]+)>\{\{(.+?)}}<\/[^>]+>/g, function (match, tag, group, offset, string) {
	          var template = "",
	              groups = group === "group" ? scope.groups : [group];

	          if (!scope.result.length) {
	            if (hasEmptyTemplate === true) return "";
	            hasEmptyTemplate = true;
	            return "<" + tag + ' class="' + scope.options.selector.empty + '">' + emptyTemplate + "</" + tag + ">";
	          }

	          for (var i = 0, ii = groups.length; i < ii; ++i) {
	            template += "<" + tag + ' data-group-template="' + groups[i] + '"><ul></ul></' + tag + ">";
	          }

	          return template;
	        }));
	      } else {
	        groupTemplate = $(groupTemplate);

	        if (!this.result.length) {
	          groupTemplate.append(emptyTemplate instanceof $ ? emptyTemplate : '<li class="' + scope.options.selector.empty + '">' + emptyTemplate + "</li>");
	        }
	      }

	      groupTemplate.addClass(this.options.selector.list + (this.helper.isEmpty(this.result) ? " empty" : ""));

	      var _group,
	          _groupTemplate,
	          _item,
	          _href,
	          _liHtml,
	          _template,
	          _aHtml,
	          _display,
	          _displayKeys,
	          _displayValue,
	          _unusedGroups = this.groupTemplate && this.result.length && scope.groups || [],
	          _tmpIndexOf;

	      for (var i = 0, ii = this.result.length; i < ii; ++i) {
	        _item = this.result[i];
	        _group = _item.group;
	        _href = !this.options.multiselect && this.options.source[_item.group].href || this.options.href;
	        _display = [];
	        _displayKeys = this.options.source[_item.group].display || this.options.display;

	        if (this.options.group) {
	          _group = _item[this.options.group.key];

	          if (this.options.group.template) {
	            if (typeof this.options.group.template === "function") {
	              _groupTemplate = this.options.group.template.call(this, _item);
	            } else if (typeof this.options.group.template === "string") {
	              _groupTemplate = this.options.group.template.replace(/\{\{([\w\-\.]+)}}/gi, function (match, index) {
	                return scope.helper.namespace.call(scope, index, _item, "get", "");
	              });
	            }
	          }

	          if (!groupTemplate.find('[data-search-group="' + _group + '"]')[0]) {
	            (this.groupTemplate ? groupTemplate.find('[data-group-template="' + _group + '"] ul') : groupTemplate).append($("<li/>", {
	              class: scope.options.selector.group,
	              html: $("<a/>", {
	                href: "javascript:;",
	                html: _groupTemplate || _group,
	                tabindex: -1
	              }),
	              "data-search-group": _group
	            }));
	          }
	        }

	        if (this.groupTemplate && _unusedGroups.length) {
	          _tmpIndexOf = _unusedGroups.indexOf(_group || _item.group);

	          if (~_tmpIndexOf) {
	            _unusedGroups.splice(_tmpIndexOf, 1);
	          }
	        }

	        _liHtml = $("<li/>", {
	          class: scope.options.selector.item + " " + scope.options.selector.group + "-" + this.helper.slugify.call(this, _group),
	          disabled: _item.disabled ? true : false,
	          "data-group": _group,
	          "data-index": i,
	          html: $("<a/>", {
	            href: _href && !_item.disabled ? function (href, item) {
	              return item.href = scope.generateHref.call(scope, href, item);
	            }(_href, _item) : "javascript:;",
	            html: function html() {
	              _template = _item.group && scope.options.source[_item.group].template || scope.options.template;

	              if (_template) {
	                if (typeof _template === "function") {
	                  _template = _template.call(scope, scope.query, _item);
	                }

	                _aHtml = _template.replace(/\{\{([^\|}]+)(?:\|([^}]+))*}}/gi, function (match, index, options) {
	                  var value = scope.helper.cleanStringFromScript(String(scope.helper.namespace.call(scope, index, _item, "get", ""))); // #151 Slugify should be an option, not enforced

	                  options = options && options.split("|") || [];

	                  if (~options.indexOf("slugify")) {
	                    value = scope.helper.slugify.call(scope, value);
	                  }

	                  if (!~options.indexOf("raw")) {
	                    if (scope.options.highlight === true && _query && ~_displayKeys.indexOf(index)) {
	                      value = scope.helper.highlight.call(scope, value, _query.split(" "), scope.options.accent);
	                    }
	                  }

	                  return value;
	                });
	              } else {
	                for (var i = 0, ii = _displayKeys.length; i < ii; i++) {
	                  _displayValue = /\./.test(_displayKeys[i]) ? scope.helper.namespace.call(scope, _displayKeys[i], _item, "get", "") : _item[_displayKeys[i]];
	                  if (typeof _displayValue === "undefined" || _displayValue === "") continue;

	                  _display.push(_displayValue);
	                }

	                _aHtml = '<span class="' + scope.options.selector.display + '">' + scope.helper.cleanStringFromScript(String(_display.join(" "))) + "</span>";
	              }

	              if (scope.options.highlight === true && _query && !_template || scope.options.highlight === "any") {
	                _aHtml = scope.helper.highlight.call(scope, _aHtml, _query.split(" "), scope.options.accent);
	              }

	              $(this).append(_aHtml);
	            }
	          })
	        });

	        (function (i, item, liHtml) {
	          liHtml.on("click", function (e, originalEvent) {
	            if (item.disabled) {
	              e.preventDefault();
	              return;
	            } // #208 - Attach "keyboard Enter" original event


	            if (originalEvent && _typeof_1(originalEvent) === "object") {
	              e.originalEvent = originalEvent;
	            }

	            if (scope.options.mustSelectItem && scope.helper.isEmpty(item)) {
	              e.preventDefault();
	              return;
	            }

	            if (!scope.options.multiselect) {
	              scope.item = item;
	            }

	            if (scope.helper.executeCallback.call(scope, scope.options.callback.onClickBefore, [scope.node, $(this), item, e]) === false) return;
	            if (e.originalEvent && e.originalEvent.defaultPrevented || e.isDefaultPrevented()) return;

	            if (scope.options.multiselect) {
	              scope.query = scope.rawQuery = "";
	              scope.addMultiselectItemLayout(item);
	            } else {
	              scope.focusOnly = true;
	              scope.query = scope.rawQuery = scope.getTemplateValue.call(scope, item);

	              if (scope.isContentEditable) {
	                scope.node.text(scope.query);
	                scope.helper.setCaretAtEnd(scope.node[0]);
	              }
	            }

	            scope.hideLayout();
	            scope.node.val(scope.query); // .focus();

	            scope.options.cancelButton && scope.toggleCancelButtonVisibility();
	            scope.helper.executeCallback.call(scope, scope.options.callback.onClickAfter, [scope.node, $(this), item, e]);
	          });
	          liHtml.on("mouseenter", function (e) {
	            if (!item.disabled) {
	              scope.clearActiveItem();
	              scope.addActiveItem($(this));
	            }

	            scope.helper.executeCallback.call(scope, scope.options.callback.onEnter, [scope.node, $(this), item, e]);
	          });
	          liHtml.on("mouseleave", function (e) {
	            if (!item.disabled) {
	              scope.clearActiveItem();
	            }

	            scope.helper.executeCallback.call(scope, scope.options.callback.onLeave, [scope.node, $(this), item, e]);
	          });
	        })(i, _item, _liHtml);

	        (this.groupTemplate ? groupTemplate.find('[data-group-template="' + _group + '"] ul') : groupTemplate).append(_liHtml);
	      }

	      if (this.result.length && _unusedGroups.length) {
	        for (var i = 0, ii = _unusedGroups.length; i < ii; ++i) {
	          groupTemplate.find('[data-group-template="' + _unusedGroups[i] + '"]').remove();
	        }
	      }

	      this.resultHtml = groupTemplate;
	    },
	    generateHref: function generateHref(href, item) {
	      var scope = this;

	      if (typeof href === "string") {
	        href = href.replace(/\{\{([^\|}]+)(?:\|([^}]+))*}}/gi, function (match, index, options) {
	          var value = scope.helper.namespace.call(scope, index, item, "get", ""); // #151 Slugify should be an option, not enforced

	          options = options && options.split("|") || [];

	          if (~options.indexOf("slugify")) {
	            value = scope.helper.slugify.call(scope, value);
	          }

	          return value;
	        });
	      } else if (typeof href === "function") {
	        href = href.call(this, item);
	      }

	      return href;
	    },
	    getMultiselectComparedData: function getMultiselectComparedData(item) {
	      var uniqueComparedItem = "";

	      if (Array.isArray(this.options.multiselect.matchOn)) {
	        for (var i = 0, ii = this.options.multiselect.matchOn.length; i < ii; ++i) {
	          uniqueComparedItem += typeof item[this.options.multiselect.matchOn[i]] !== "undefined" ? item[this.options.multiselect.matchOn[i]] : "";
	        }
	      } else {
	        var tmpItem = JSON.parse(JSON.stringify(item)),
	            extraKeys = ["group", "matchedKey", "compiled", "href"];

	        for (var i = 0, ii = extraKeys.length; i < ii; ++i) {
	          delete tmpItem[extraKeys[i]];
	        }

	        uniqueComparedItem = JSON.stringify(tmpItem);
	      }

	      return uniqueComparedItem;
	    },
	    buildBackdropLayout: function buildBackdropLayout() {
	      if (!this.options.backdrop) return;

	      if (!this.backdrop.container) {
	        this.backdrop.css = $.extend({
	          opacity: 0.6,
	          filter: "alpha(opacity=60)",
	          position: "fixed",
	          top: 0,
	          right: 0,
	          bottom: 0,
	          left: 0,
	          "z-index": 1040,
	          "background-color": "#000"
	        }, this.options.backdrop);
	        this.backdrop.container = $("<div/>", {
	          class: this.options.selector.backdrop,
	          css: this.backdrop.css
	        }).insertAfter(this.container);
	      }

	      this.container.addClass("backdrop").css({
	        "z-index": this.backdrop.css["z-index"] + 1,
	        position: "relative"
	      });
	    },
	    buildHintLayout: function buildHintLayout(result) {
	      if (!this.options.hint) return; // #144 hint doesn't overlap with the input when the query is too long

	      if (this.node[0].scrollWidth > Math.ceil(this.node.innerWidth())) {
	        this.hint.container && this.hint.container.val("");
	        return;
	      }

	      var scope = this,
	          hint = "",
	          result = result || this.result,
	          query = this.query.toLowerCase();

	      if (this.options.accent) {
	        query = this.helper.removeAccent.call(this, query);
	      }

	      this.hintIndex = null;

	      if (this.searchGroups.length) {
	        if (!this.hint.container) {
	          this.hint.css = $.extend({
	            "border-color": "transparent",
	            position: "absolute",
	            top: 0,
	            display: "inline",
	            "z-index": -1,
	            float: "none",
	            color: "silver",
	            "box-shadow": "none",
	            cursor: "default",
	            "-webkit-user-select": "none",
	            "-moz-user-select": "none",
	            "-ms-user-select": "none",
	            "user-select": "none"
	          }, this.options.hint);
	          this.hint.container = $("<" + this.node[0].nodeName + "/>", {
	            type: this.node.attr("type"),
	            class: this.node.attr("class"),
	            readonly: true,
	            unselectable: "on",
	            "aria-hidden": "true",
	            tabindex: -1,
	            click: function click() {
	              // IE8 Fix
	              scope.node.focus();
	            }
	          }).addClass(this.options.selector.hint).css(this.hint.css).insertAfter(this.node);
	          this.node.parent().css({
	            position: "relative"
	          });
	        }

	        this.hint.container.css("color", this.hint.css.color); // Do not display hint for empty query

	        if (query) {
	          var _displayKeys, _group, _comparedValue;

	          for (var i = 0, ii = result.length; i < ii; i++) {
	            if (result[i].disabled) continue;
	            _group = result[i].group;
	            _displayKeys = this.options.source[_group].display || this.options.display;

	            for (var k = 0, kk = _displayKeys.length; k < kk; k++) {
	              _comparedValue = String(result[i][_displayKeys[k]]).toLowerCase();

	              if (this.options.accent) {
	                _comparedValue = this.helper.removeAccent.call(this, _comparedValue);
	              }

	              if (_comparedValue.indexOf(query) === 0) {
	                hint = String(result[i][_displayKeys[k]]);
	                this.hintIndex = i;
	                break;
	              }
	            }

	            if (this.hintIndex !== null) {
	              break;
	            }
	          }
	        }

	        var hintValue = hint.length > 0 && this.rawQuery + hint.substring(this.query.length) || "";
	        this.hint.container.val(hintValue);

	        if (this.isContentEditable) {
	          this.hint.container.text(hintValue);
	        }
	      }
	    },
	    buildDropdownLayout: function buildDropdownLayout() {
	      if (!this.options.dropdownFilter) return;
	      var scope = this;
	      $("<span/>", {
	        class: this.options.selector.filter,
	        html: function html() {
	          $(this).append($("<button/>", {
	            type: "button",
	            class: scope.options.selector.filterButton,
	            style: "display: none;",
	            click: function click() {
	              scope.container.toggleClass("filter");

	              var _ns = scope.namespace + "-dropdown-filter";

	              $("html").off(_ns);

	              if (scope.container.hasClass("filter")) {
	                $("html").on("click" + _ns + " touchend" + _ns, function (e) {
	                  if ($(e.target).closest("." + scope.options.selector.filter)[0] && $(e.target).closest(scope.container)[0] || scope.hasDragged) return;
	                  scope.container.removeClass("filter");
	                  $("html").off(_ns);
	                });
	              }
	            }
	          }));
	          $(this).append($("<ul/>", {
	            class: scope.options.selector.dropdown
	          }));
	        }
	      }).insertAfter(scope.container.find("." + scope.options.selector.query));
	    },
	    buildDropdownItemLayout: function buildDropdownItemLayout(type) {
	      if (!this.options.dropdownFilter) return;
	      var scope = this,
	          template,
	          all = typeof this.options.dropdownFilter === "string" && this.options.dropdownFilter || "All",
	          ulScope = this.container.find("." + this.options.selector.dropdown),
	          filter; // Use regular groups defined in options.source

	      if (type === "static" && (this.options.dropdownFilter === true || typeof this.options.dropdownFilter === "string")) {
	        this.dropdownFilter.static.push({
	          key: "group",
	          template: "{{group}}",
	          all: all,
	          value: Object.keys(this.options.source)
	        });
	      }

	      for (var i = 0, ii = this.dropdownFilter[type].length; i < ii; i++) {
	        filter = this.dropdownFilter[type][i];

	        if (!Array.isArray(filter.value)) {
	          filter.value = [filter.value];
	        }

	        if (filter.all) {
	          this.dropdownFilterAll = filter.all;
	        }

	        for (var k = 0, kk = filter.value.length; k <= kk; k++) {
	          // Only add "all" at the last filter iteration
	          if (k === kk && i !== ii - 1) {
	            continue;
	          } else if (k === kk && i === ii - 1) {
	            if (type === "static" && this.dropdownFilter.dynamic.length) {
	              continue;
	            }
	          }

	          template = this.dropdownFilterAll || all;

	          if (filter.value[k]) {
	            if (filter.template) {
	              template = filter.template.replace(new RegExp("{{" + filter.key + "}}", "gi"), filter.value[k]);
	            } else {
	              template = filter.value[k];
	            }
	          } else {
	            this.container.find("." + scope.options.selector.filterButton).html(template);
	          }

	          (function (k, filter, template) {
	            ulScope.append($("<li/>", {
	              class: scope.options.selector.dropdownItem + " " + scope.helper.slugify.call(scope, filter.key + "-" + (filter.value[k] || all)),
	              html: $("<a/>", {
	                href: "javascript:;",
	                html: template,
	                click: function click(e) {
	                  e.preventDefault();

	                  _selectFilter.call(scope, {
	                    key: filter.key,
	                    value: filter.value[k] || "*",
	                    template: template
	                  });
	                }
	              })
	            }));
	          })(k, filter, template);
	        }
	      }

	      if (this.dropdownFilter[type].length) {
	        this.container.find("." + scope.options.selector.filterButton).removeAttr("style");
	      }
	      /**
	       * @private
	       * Select the filter and rebuild the result group
	       *
	       * @param {object} item
	       */


	      function _selectFilter(item) {
	        if (item.value === "*") {
	          delete this.filters.dropdown;
	        } else {
	          this.filters.dropdown = item;
	        }

	        this.container.removeClass("filter").find("." + this.options.selector.filterButton).html(item.template);
	        this.isDropdownEvent = true;
	        this.node.trigger("input" + this.namespace);

	        if (this.options.multiselect) {
	          this.adjustInputSize();
	        }

	        this.node.focus();
	      }
	    },
	    dynamicFilter: {
	      isEnabled: false,
	      init: function init() {
	        if (!this.options.dynamicFilter) return;
	        this.dynamicFilter.bind.call(this);
	        this.dynamicFilter.isEnabled = true;
	      },
	      validate: function validate(item) {
	        var isValid,
	            softValid = null,
	            hardValid = null,
	            itemValue;

	        for (var key in this.filters.dynamic) {
	          if (!this.filters.dynamic.hasOwnProperty(key)) continue;

	          if (!!~key.indexOf(".")) {
	            itemValue = this.helper.namespace.call(this, key, item, "get");
	          } else {
	            itemValue = item[key];
	          }

	          if (this.filters.dynamic[key].modifier === "|" && !softValid) {
	            softValid = itemValue == this.filters.dynamic[key].value || false;
	          }

	          if (this.filters.dynamic[key].modifier === "&") {
	            // Leaving "==" in case of comparing number with string
	            if (itemValue == this.filters.dynamic[key].value) {
	              hardValid = true;
	            } else {
	              hardValid = false;
	              break;
	            }
	          }
	        }

	        isValid = softValid;

	        if (hardValid !== null) {
	          isValid = hardValid;

	          if (hardValid === true && softValid !== null) {
	            isValid = softValid;
	          }
	        }

	        return !!isValid;
	      },
	      set: function set(key, value) {
	        var matches = key.match(/^([|&])?(.+)/);

	        if (!value) {
	          delete this.filters.dynamic[matches[2]];
	        } else {
	          this.filters.dynamic[matches[2]] = {
	            modifier: matches[1] || "|",
	            value: value
	          };
	        }

	        if (this.dynamicFilter.isEnabled) {
	          this.generateSource();
	        }
	      },
	      bind: function bind() {
	        var scope = this,
	            filter;

	        for (var i = 0, ii = this.options.dynamicFilter.length; i < ii; i++) {
	          filter = this.options.dynamicFilter[i];

	          if (typeof filter.selector === "string") {
	            filter.selector = $(filter.selector);
	          }

	          if (!(filter.selector instanceof $) || !filter.selector[0] || !filter.key) {
	            // {debug}
	            if (this.options.debug) {
	              _debug.log({
	                node: this.selector,
	                function: "buildDynamicLayout()",
	                message: 'Invalid jQuery selector or jQuery Object for "filter.selector" or missing filter.key'
	              });

	              _debug.print();
	            } // {/debug}


	            continue;
	          }

	          (function (filter) {
	            filter.selector.off(scope.namespace).on("change" + scope.namespace, function () {
	              scope.dynamicFilter.set.apply(scope, [filter.key, scope.dynamicFilter.getValue(this)]);
	            }).trigger("change" + scope.namespace);
	          })(filter);
	        }
	      },
	      getValue: function getValue(tag) {
	        var value;

	        if (tag.tagName === "SELECT") {
	          value = tag.value;
	        } else if (tag.tagName === "INPUT") {
	          if (tag.type === "checkbox") {
	            value = tag.checked && tag.getAttribute("value") || tag.checked || null;
	          } else if (tag.type === "radio" && tag.checked) {
	            value = tag.value;
	          }
	        }

	        return value;
	      }
	    },
	    buildMultiselectLayout: function buildMultiselectLayout() {
	      if (!this.options.multiselect) return;
	      var scope = this;
	      var multiselectData;
	      this.label.container = $("<span/>", {
	        class: this.options.selector.labelContainer,
	        "data-padding-left": parseFloat(this.node.css("padding-left")) || 0,
	        "data-padding-right": parseFloat(this.node.css("padding-right")) || 0,
	        "data-padding-top": parseFloat(this.node.css("padding-top")) || 0,
	        click: function click(e) {
	          if ($(e.target).hasClass(scope.options.selector.labelContainer)) {
	            scope.node.focus();
	          }
	        }
	      });
	      this.node.closest("." + this.options.selector.query).prepend(this.label.container);
	      if (!this.options.multiselect.data) return;

	      if (Array.isArray(this.options.multiselect.data)) {
	        this.populateMultiselectData(this.options.multiselect.data);
	      } else if (typeof this.options.multiselect.data === 'function') {
	        multiselectData = this.options.multiselect.data.call(this);

	        if (Array.isArray(multiselectData)) {
	          this.populateMultiselectData(multiselectData);
	        } else if (typeof multiselectData.promise === "function") {
	          $.when(multiselectData).then(function (deferredData) {
	            if (deferredData && Array.isArray(deferredData)) {
	              scope.populateMultiselectData(deferredData);
	            }
	          });
	        }
	      }
	    },
	    isMultiselectUniqueData: function isMultiselectUniqueData(data) {
	      var isUniqueData = true;

	      for (var x = 0, xx = this.comparedItems.length; x < xx; ++x) {
	        if (this.comparedItems[x] === this.getMultiselectComparedData(data)) {
	          isUniqueData = false;
	          break;
	        }
	      }

	      return isUniqueData;
	    },
	    populateMultiselectData: function populateMultiselectData(data) {
	      for (var i = 0, ii = data.length; i < ii; ++i) {
	        this.addMultiselectItemLayout(data[i]);
	      }

	      this.node.trigger("search" + this.namespace, {
	        origin: 'populateMultiselectData'
	      });
	    },
	    addMultiselectItemLayout: function addMultiselectItemLayout(item) {
	      if (!this.isMultiselectUniqueData(item)) return;
	      this.items.push(item);
	      this.comparedItems.push(this.getMultiselectComparedData(item));
	      var templateValue = this.getTemplateValue(item);
	      var scope = this,
	          htmlTag = this.options.multiselect.href ? "a" : "span";
	      var label = $("<span/>", {
	        class: this.options.selector.label,
	        html: $("<" + htmlTag + "/>", {
	          text: templateValue,
	          click: function click(e) {
	            var currentLabel = $(this).closest("." + scope.options.selector.label),
	                index = scope.label.container.find("." + scope.options.selector.label).index(currentLabel);
	            scope.options.multiselect.callback && scope.helper.executeCallback.call(scope, scope.options.multiselect.callback.onClick, [scope.node, scope.items[index], e]);
	          },
	          href: this.options.multiselect.href ? function (item) {
	            return scope.generateHref.call(scope, scope.options.multiselect.href, item);
	          }(scope.items[scope.items.length - 1]) : null
	        })
	      });
	      label.append($("<span/>", {
	        class: this.options.selector.cancelButton,
	        html: "Ã",
	        click: function click(e) {
	          var label = $(this).closest("." + scope.options.selector.label),
	              index = scope.label.container.find("." + scope.options.selector.label).index(label);
	          scope.cancelMultiselectItem(index, label, e);
	        }
	      }));
	      this.label.container.append(label);
	      this.adjustInputSize();
	      return true;
	    },
	    cancelMultiselectItem: function cancelMultiselectItem(index, label, e) {
	      var item = this.items[index];
	      label = label || this.label.container.find('.' + this.options.selector.label).eq(index);
	      label.remove();
	      this.items.splice(index, 1);
	      this.comparedItems.splice(index, 1);
	      this.options.multiselect.callback && this.helper.executeCallback.call(this, this.options.multiselect.callback.onCancel, [this.node, item, e]);
	      this.adjustInputSize();
	      this.focusOnly = true;
	      this.node.focus().trigger('input' + this.namespace, {
	        origin: 'cancelMultiselectItem'
	      });
	    },
	    adjustInputSize: function adjustInputSize() {
	      var nodeWidth = this.node[0].getBoundingClientRect().width - (parseFloat(this.label.container.data("padding-right")) || 0) - (parseFloat(this.label.container.css("padding-left")) || 0);
	      var labelOuterWidth = 0,
	          numberOfRows = 0,
	          currentRowWidth = 0,
	          isRowAdded = false,
	          labelOuterHeight = 0;
	      this.label.container.find("." + this.options.selector.label).filter(function (i, v) {
	        if (i === 0) {
	          labelOuterHeight = $(v)[0].getBoundingClientRect().height + parseFloat($(v).css("margin-bottom") || 0);
	        } // labelOuterWidth = Math.round($(v)[0].getBoundingClientRect().width * 100) / 100 + parseFloat($(v).css('margin-right'));


	        labelOuterWidth = $(v)[0].getBoundingClientRect().width + parseFloat($(v).css("margin-right") || 0);

	        if (currentRowWidth + labelOuterWidth > nodeWidth * 0.7 && !isRowAdded) {
	          numberOfRows++;
	          isRowAdded = true;
	        }

	        if (currentRowWidth + labelOuterWidth < nodeWidth) {
	          currentRowWidth += labelOuterWidth;
	        } else {
	          isRowAdded = false;
	          currentRowWidth = labelOuterWidth;
	        }
	      });
	      var paddingLeft = parseFloat(this.label.container.data("padding-left") || 0) + (isRowAdded ? 0 : currentRowWidth);
	      var paddingTop = numberOfRows * labelOuterHeight + parseFloat(this.label.container.data("padding-top") || 0);
	      this.container.find("." + this.options.selector.query).find("input, textarea, [contenteditable], .typeahead__hint").css({
	        paddingLeft: paddingLeft,
	        paddingTop: paddingTop
	      });
	    },
	    showLayout: function showLayout() {
	      if (this.container.hasClass("result") || !this.result.length && !this.displayEmptyTemplate && !this.options.backdropOnFocus) return;

	      _addHtmlListeners.call(this);

	      this.container.addClass([this.result.length || this.searchGroups.length && this.displayEmptyTemplate ? "result " : "", this.options.hint && this.searchGroups.length ? "hint" : "", this.options.backdrop || this.options.backdropOnFocus ? "backdrop" : ""].join(" "));
	      this.helper.executeCallback.call(this, this.options.callback.onShowLayout, [this.node, this.query]);

	      function _addHtmlListeners() {
	        var scope = this; // If Typeahead is blured by pressing the "Tab" Key, hide the results

	        $("html").off("keydown" + this.namespace).on("keydown" + this.namespace, function (e) {
	          if (!e.keyCode || e.keyCode !== 9) return;
	          setTimeout(function () {
	            if (!$(":focus").closest(scope.container).find(scope.node)[0]) {
	              scope.hideLayout();
	            }
	          }, 0);
	        }); // If Typeahead is blured by clicking outside, hide the results

	        $("html").off("click" + this.namespace + " touchend" + this.namespace).on("click" + this.namespace + " touchend" + this.namespace, function (e) {
	          if ($(e.target).closest(scope.container)[0] || $(e.target).closest('.' + scope.options.selector.item)[0] || e.target.className === scope.options.selector.cancelButton || scope.hasDragged) return;
	          scope.hideLayout();
	        });
	      }
	    },
	    hideLayout: function hideLayout() {
	      // Means the container is already hidden
	      if (!this.container.hasClass("result") && !this.container.hasClass("backdrop")) return;
	      this.container.removeClass("result hint filter" + (this.options.backdropOnFocus && $(this.node).is(":focus") ? "" : " backdrop"));
	      if (this.options.backdropOnFocus && this.container.hasClass("backdrop")) return; // Make sure the event HTML gets cleared

	      $("html").off(this.namespace);
	      this.helper.executeCallback.call(this, this.options.callback.onHideLayout, [this.node, this.query]);
	    },
	    resetLayout: function resetLayout() {
	      this.result = [];
	      this.tmpResult = {};
	      this.groups = [];
	      this.resultCount = 0;
	      this.resultCountPerGroup = {};
	      this.resultItemCount = 0;
	      this.resultHtml = null;

	      if (this.options.hint && this.hint.container) {
	        this.hint.container.val("");

	        if (this.isContentEditable) {
	          this.hint.container.text("");
	        }
	      }
	    },
	    resetInput: function resetInput() {
	      this.node.val("");

	      if (this.isContentEditable) {
	        this.node.text("");
	      }

	      this.query = "";
	      this.rawQuery = "";
	    },
	    buildCancelButtonLayout: function buildCancelButtonLayout() {
	      if (!this.options.cancelButton) return;
	      var scope = this;
	      $("<span/>", {
	        class: this.options.selector.cancelButton,
	        html: "Ã",
	        mousedown: function mousedown(e) {
	          // Don't blur the input
	          e.stopImmediatePropagation();
	          e.preventDefault();
	          scope.resetInput();
	          scope.node.trigger("input" + scope.namespace, [e]);
	        }
	      }).insertBefore(this.node);
	    },
	    toggleCancelButtonVisibility: function toggleCancelButtonVisibility() {
	      this.container.toggleClass("cancel", !!this.query.length);
	    },
	    __construct: function __construct() {
	      this.extendOptions();

	      if (!this.unifySourceFormat()) {
	        return;
	      }

	      this.dynamicFilter.init.apply(this);
	      this.init();
	      this.buildDropdownLayout();
	      this.buildDropdownItemLayout("static");
	      this.buildMultiselectLayout();
	      this.delegateEvents();
	      this.buildCancelButtonLayout();
	      this.helper.executeCallback.call(this, this.options.callback.onReady, [this.node]);
	    },
	    helper: {
	      isEmpty: function isEmpty(obj) {
	        for (var prop in obj) {
	          if (obj.hasOwnProperty(prop)) return false;
	        }

	        return true;
	      },

	      /**
	       * Remove every accent(s) from a string
	       *
	       * @param {String} string
	       * @returns {*}
	       */
	      removeAccent: function removeAccent(string) {
	        if (typeof string !== "string") {
	          return;
	        }

	        var accent = _accent;

	        if (_typeof_1(this.options.accent) === "object") {
	          accent = this.options.accent;
	        }

	        string = string.toLowerCase().replace(new RegExp("[" + accent.from + "]", "g"), function (match) {
	          return accent.to[accent.from.indexOf(match)];
	        });
	        return string;
	      },

	      /**
	       * Creates a valid url from string
	       *
	       * @param {String} string
	       * @returns {string}
	       */
	      slugify: function slugify(string) {
	        string = String(string);

	        if (string !== "") {
	          string = this.helper.removeAccent.call(this, string);
	          string = string.replace(/[^-a-z0-9]+/g, "-").replace(/-+/g, "-").replace(/^-|-$/g, "");
	        }

	        return string;
	      },

	      /**
	       * Sort list of object by key
	       *
	       * @param {String|Array} field
	       * @param {Boolean} reverse
	       * @param {Function} primer
	       * @returns {Function}
	       */
	      sort: function sort(field, reverse, primer) {
	        var key = function key(x) {
	          for (var i = 0, ii = field.length; i < ii; i++) {
	            if (typeof x[field[i]] !== "undefined") {
	              return primer(x[field[i]]);
	            }
	          }

	          return x;
	        };

	        reverse = [-1, 1][+!!reverse];
	        return function (a, b) {
	          return a = key(a), b = key(b), reverse * ((a > b) - (b > a));
	        };
	      },

	      /**
	       * Replace a string from-to index
	       *
	       * @param {String} string The complete string to replace into
	       * @param {Number} offset The cursor position to start replacing from
	       * @param {Number} length The length of the replacing string
	       * @param {String} replace The replacing string
	       * @returns {String}
	       */
	      replaceAt: function replaceAt(string, offset, length, replace) {
	        return string.substring(0, offset) + replace + string.substring(offset + length);
	      },

	      /**
	       * Adds <strong> html around a matched string
	       *
	       * @param {String} string The complete string to match from
	       * @param {String} key
	       * @param {Boolean} [accents]
	       * @returns {*}
	       */
	      highlight: function highlight(string, keys, accents) {
	        string = String(string);
	        var searchString = accents && this.helper.removeAccent.call(this, string) || string,
	            matches = [];

	        if (!Array.isArray(keys)) {
	          keys = [keys];
	        }

	        keys.sort(function (a, b) {
	          return b.length - a.length;
	        }); // Make sure the '|' join will be safe!

	        for (var i = keys.length - 1; i >= 0; i--) {
	          if (keys[i].trim() === "") {
	            keys.splice(i, 1);
	            continue;
	          }

	          keys[i] = keys[i].replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
	        }

	        searchString.replace(new RegExp("(?:" + keys.join("|") + ")(?!([^<]+)?>)", "gi"), function (match, index, offset) {
	          matches.push({
	            offset: offset,
	            length: match.length
	          });
	        });

	        for (var i = matches.length - 1; i >= 0; i--) {
	          string = this.helper.replaceAt(string, matches[i].offset, matches[i].length, "<strong>" + string.substr(matches[i].offset, matches[i].length) + "</strong>");
	        }

	        return string;
	      },

	      /**
	       * Get caret position, used for right arrow navigation
	       * when hint option is enabled
	       * @param {Node} element
	       * @returns {Number} Caret position
	       */
	      getCaret: function getCaret(element) {
	        var caretPos = 0;

	        if (element.selectionStart) {
	          // Input & Textarea
	          return element.selectionStart;
	        } else if (document.selection) {
	          var r = document.selection.createRange();

	          if (r === null) {
	            return caretPos;
	          }

	          var re = element.createTextRange(),
	              rc = re.duplicate();
	          re.moveToBookmark(r.getBookmark());
	          rc.setEndPoint("EndToStart", re);
	          caretPos = rc.text.length;
	        } else if (window.getSelection) {
	          // Contenteditable
	          var sel = window.getSelection();

	          if (sel.rangeCount) {
	            var range = sel.getRangeAt(0);

	            if (range.commonAncestorContainer.parentNode == element) {
	              caretPos = range.endOffset;
	            }
	          }
	        }

	        return caretPos;
	      },

	      /**
	       * For [contenteditable] typeahead node only,
	       * when an item is clicked set the cursor at the end
	       * @param {Node} element
	       */
	      setCaretAtEnd: function setCaretAtEnd(element) {
	        if (typeof window.getSelection !== "undefined" && typeof document.createRange !== "undefined") {
	          var range = document.createRange();
	          range.selectNodeContents(element);
	          range.collapse(false);
	          var sel = window.getSelection();
	          sel.removeAllRanges();
	          sel.addRange(range);
	        } else if (typeof document.body.createTextRange !== "undefined") {
	          var textRange = document.body.createTextRange();
	          textRange.moveToElementText(element);
	          textRange.collapse(false);
	          textRange.select();
	        }
	      },

	      /**
	       * Clean strings from possible XSS (script and iframe tags)
	       * @param string
	       * @returns {string}
	       */
	      cleanStringFromScript: function cleanStringFromScript(string) {
	        return typeof string === "string" && string.replace(/<\/?(?:script|iframe)\b[^>]*>/gm, "") || string;
	      },

	      /**
	       * Executes an anonymous function or a string reached from the window scope.
	       *
	       * @example
	       * Note: These examples works with every configuration callbacks
	       *
	       * // An anonymous function inside the "onInit" option
	       * onInit: function() { console.log(':D'); };
	       *
	       * // myFunction() located on window.coucou scope
	       * onInit: 'window.coucou.myFunction'
	       *
	       * // myFunction(a,b) located on window.coucou scope passing 2 parameters
	       * onInit: ['window.coucou.myFunction', [':D', ':)']];
	       *
	       * // Anonymous function to execute a local function
	       * onInit: function () { myFunction(':D'); }
	       *
	       * @param {String|Array} callback The function to be called
	       * @param {Array} [extraParams] In some cases the function can be called with Extra parameters (onError)
	       * @returns {*}
	       */
	      executeCallback: function executeCallback(callback, extraParams) {
	        if (!callback) {
	          return;
	        }

	        var _callback;

	        if (typeof callback === "function") {
	          _callback = callback;
	        } else if (typeof callback === "string" || Array.isArray(callback)) {
	          if (typeof callback === "string") {
	            callback = [callback, []];
	          }

	          _callback = this.helper.namespace.call(this, callback[0], window);

	          if (typeof _callback !== "function") {
	            // {debug}
	            if (this.options.debug) {
	              _debug.log({
	                node: this.selector,
	                function: "executeCallback()",
	                arguments: JSON.stringify(callback),
	                message: 'WARNING - Invalid callback function"'
	              });

	              _debug.print();
	            } // {/debug}


	            return;
	          }
	        }

	        return _callback.apply(this, (callback[1] || []).concat(extraParams ? extraParams : []));
	      },
	      namespace: function namespace(string, object, method, defaultValue) {
	        if (typeof string !== "string" || string === "") {
	          // {debug}
	          if (this.options.debug) {
	            _debug.log({
	              node: this.options.input || this.selector,
	              function: "helper.namespace()",
	              arguments: string,
	              message: 'ERROR - Missing string"'
	            });

	            _debug.print();
	          } // {/debug}


	          return false;
	        }

	        var value = typeof defaultValue !== "undefined" ? defaultValue : undefined; // Exit before looping if the string doesn't contain an object reference

	        if (!~string.indexOf(".")) {
	          return object[string] || value;
	        }

	        var parts = string.split("."),
	            parent = object || window,
	            method = method || "get",
	            currentPart = "";

	        for (var i = 0, length = parts.length; i < length; i++) {
	          currentPart = parts[i];

	          if (typeof parent[currentPart] === "undefined") {
	            if (~["get", "delete"].indexOf(method)) {
	              return typeof defaultValue !== "undefined" ? defaultValue : undefined;
	            }

	            parent[currentPart] = {};
	          }

	          if (~["set", "create", "delete"].indexOf(method)) {
	            if (i === length - 1) {
	              if (method === "set" || method === "create") {
	                parent[currentPart] = value;
	              } else {
	                delete parent[currentPart];
	                return true;
	              }
	            }
	          }

	          parent = parent[currentPart];
	        }

	        return parent;
	      },
	      typeWatch: function () {
	        var timer = 0;
	        return function (callback, ms) {
	          clearTimeout(timer);
	          timer = setTimeout(callback, ms);
	        };
	      }()
	    }
	  };
	  /**
	   * @public
	   * Implement Typeahead on the selected input node.
	   *
	   * @param {Object} options
	   * @return {Object} Modified DOM element
	   */

	  $.fn.typeahead = $.typeahead = function (options) {
	    return _api.typeahead(this, options);
	  };
	  /**
	   * @private
	   * API to handles Typeahead methods via jQuery.
	   */


	  var _api = {
	    /**
	     * Enable Typeahead
	     *
	     * @param {Object} node
	     * @param {Object} options
	     * @returns {*}
	     */
	    typeahead: function typeahead(node, options) {
	      if (!options || !options.source || _typeof_1(options.source) !== "object") {
	        // {debug}
	        _debug.log({
	          node: node.selector || options && options.input,
	          function: "$.typeahead()",
	          arguments: JSON.stringify(options && options.source || ""),
	          message: 'Undefined "options" or "options.source" or invalid source type - Typeahead dropped'
	        });

	        _debug.print(); // {/debug}


	        return;
	      }

	      if (typeof node === "function") {
	        if (!options.input) {
	          // {debug}
	          _debug.log({
	            node: node.selector,
	            function: "$.typeahead()",
	            //'arguments': JSON.stringify(options),
	            message: 'Undefined "options.input" - Typeahead dropped'
	          });

	          _debug.print(); // {/debug}


	          return;
	        }

	        node = $(options.input);
	      }

	      if (typeof node[0].value === "undefined") {
	        node[0].value = node.text();
	      }

	      if (!node.length) {
	        // {debug}
	        _debug.log({
	          node: node.selector,
	          function: "$.typeahead()",
	          arguments: JSON.stringify(options.input),
	          message: "Unable to find jQuery input element - Typeahead dropped"
	        });

	        _debug.print(); // {/debug}


	        return;
	      } // #270 Forcing node.selector, the property was deleted from jQuery3
	      // In case of multiple init, each of the instances needs it's own selector!


	      if (node.length === 1) {
	        node[0].selector = node.selector || options.input || node[0].nodeName.toLowerCase();
	        /*jshint boss:true */

	        return window.Typeahead[node[0].selector] = new Typeahead(node, options);
	      } else {
	        var instances = {},
	            instanceName;

	        for (var i = 0, ii = node.length; i < ii; ++i) {
	          instanceName = node[i].nodeName.toLowerCase();

	          if (typeof instances[instanceName] !== "undefined") {
	            instanceName += i;
	          }

	          node[i].selector = instanceName;
	          window.Typeahead[instanceName] = instances[instanceName] = new Typeahead(node.eq(i), options);
	        }

	        return instances;
	      }
	    }
	  }; // {debug}

	  var _debug = {
	    table: {},
	    log: function log(debugObject) {
	      if (!debugObject.message || typeof debugObject.message !== "string") {
	        return;
	      }

	      this.table[debugObject.message] = $.extend({
	        node: "",
	        function: "",
	        arguments: ""
	      }, debugObject);
	    },
	    print: function print() {
	      if (Typeahead.prototype.helper.isEmpty(this.table) || !console || !console.table) {
	        return;
	      }

	      if (console.group !== undefined || console.table !== undefined) ;

	      this.table = {};
	    }
	  };

	  _debug.log({
	    message: "WARNING - You are using the DEBUG version. Use /dist/jquery.typeahead.min.js in production."
	  });

	  _debug.print(); // {/debug}
	  // IE8 Shims


	  window.console = window.console || {
	    log: function log() {}
	  };

	  if (!Array.isArray) {
	    Array.isArray = function (arg) {
	      return Object.prototype.toString.call(arg) === "[object Array]";
	    };
	  }

	  if (!("trim" in String.prototype)) {
	    String.prototype.trim = function () {
	      return this.replace(/^\s+/, "").replace(/\s+$/, "");
	    };
	  }

	  if (!("indexOf" in Array.prototype)) {
	    Array.prototype.indexOf = function (find, i
	    /*opt*/
	    ) {
	      if (i === undefined) i = 0;
	      if (i < 0) i += this.length;
	      if (i < 0) i = 0;

	      for (var n = this.length; i < n; i++) {
	        if (i in this && this[i] === find) return i;
	      }

	      return -1;
	    };
	  }

	  if (!Object.keys) {
	    Object.keys = function (obj) {
	      var keys = [],
	          k;

	      for (k in obj) {
	        if (Object.prototype.hasOwnProperty.call(obj, k)) {
	          keys.push(k);
	        }
	      }

	      return keys;
	    };
	  }

	  return Typeahead;
	})($);

	var AfdTypeahead =
	/*#__PURE__*/
	function (_addressToolsMixin) {
	  inherits(AfdTypeahead, _addressToolsMixin);

	  function AfdTypeahead($element, options) {
	    var _this;

	    classCallCheck(this, AfdTypeahead);

	    _this = possibleConstructorReturn(this, getPrototypeOf(AfdTypeahead).call(this, $element, options));

	    defineProperty(assertThisInitialized(assertThisInitialized(_this)), "init", function () {
	      // events
	      var event = _this.eventHandler;
	      event(_this.$element, 'input', _this.onInput);
	      event(_this.$element, 'keydown', _this.uniqueIDTimer);
	      event($(document), 'afd:initFields', _this.onAfdInitFields);
	      event($(document), 'afd:countryChanged', _this.onAfdCountryChanged);
	      event(_this.$searchAgainButton, 'click', _this.onAfdSearchAgainButtonClick);
	      _this.options.typeahead.manualInputButton && event(_this.$manualInputButton, 'click', _this.onAfdManualInputButtonClick);
	      _this.options.typeahead.manualInputButton && event(_this.$manualInputSearchButton, 'click', _this.onAfdManualInputSearchButtonClick);

	      try {
	        _this.initFields();

	        _this.$element.typeahead(_this.typeaheadOptions);
	      } catch (err) {
	        console.error('Error initisalising typeahead control');
	        console.error(err);
	      }

	      _this.getInitialCountry();
	    });

	    defineProperty(assertThisInitialized(assertThisInitialized(_this)), "setupTypeaheadRequestOptions", function () {
	      // setup the request sequencing
	      _this.initRequestSequence();

	      _this.requestOptions = _this.setupParams({
	        data: 'address',
	        fields: _this.options.typeahead.postcodeFirst ? 'list' : 'fflist',
	        task: 'fastfindv4',
	        lookup: '{{query}}',
	        allpc: '1',
	        matchPositions: _this.options.typeahead.matchPositions ? 1 : 0,
	        maxquantity: _this.options.typeahead.maxItems,
	        uniqueid: _this.uniqueID
	      });
	      _this.requestOptions.path = 'Item';
	    });

	    defineProperty(assertThisInitialized(assertThisInitialized(_this)), "prepareTypeaheadOptions", function () {
	      return {
	        dynamic: true,
	        source: {
	          lookup: {
	            ajax: _this.requestOptions
	          }
	        },
	        template: '<span>{{List}}</span>',
	        templateValue: '{{List}}',
	        cancelButton: false,
	        emptyTemplate: 'No results found for {{query}}',
	        filter: false,
	        maxItem: 0,
	        minLength: _this.options.typeahead.minLength,
	        delay: 20,
	        abortAjax: false,
	        selector: _this.getTypeaheadSelectors(),
	        callback: {
	          onResult: _this.onResult,
	          onShowLayout: _this.onShowLayout,
	          onHideLayout: _this.onHideLayout,
	          onLayoutBuiltBefore: _this.onLayoutBuiltBefore,
	          onSearch: _this.onSearch,
	          onNavigateBefore: _this.onNavigateBefore,
	          onClickAfter: _this.onClickAfter
	        }
	      };
	    });

	    defineProperty(assertThisInitialized(assertThisInitialized(_this)), "onInput", function (e) {
	      $(document).trigger('afd:typeaheadInput', [e.target.value]);
	    });

	    defineProperty(assertThisInitialized(assertThisInitialized(_this)), "onAfdCountryChanged", function (e, country) {
	      _this.typeaheadOptions.source.lookup.ajax.data.countryiso = country;

	      _this.$resultFields.val('');

	      _this.$element.typeahead(_this.typeaheadOptions);
	    });

	    defineProperty(assertThisInitialized(assertThisInitialized(_this)), "onAfdInitFields", function () {
	      _this.$element.typeahead(_this.typeaheadOptions); // in case the elements were loaded after initialisation re declare variables


	      _this.setFields();

	      _this.initFields();
	    });

	    defineProperty(assertThisInitialized(assertThisInitialized(_this)), "onResult", function (node, query, result, resultHtmlList) {
	      // if results are less than the max ask about manual input
	      if (_this.options.typeahead.beforeHideResults && _this.options.typeahead.fewResultsManualInput) {
	        if (result.length < _this.options.typeahead.maxItems && query.length > 3) {
	          window.Typeahead.input.result.push({
	            List: _this.options.typeahead.fewResultsManualInputText,
	            Key: null,
	            group: 'lookup',
	            matchedKey: 'display'
	          });
	        }
	      }
	    });

	    defineProperty(assertThisInitialized(assertThisInitialized(_this)), "onShowLayout", function (node, query) {
	      // let container = node.closest(this.containers);
	      // let _$manualInputButton = !this.multiForms ?
	      //  this.$manualInputButton :
	      //  container.find('.afd-manual-input-button');
	      // hide the manual input button if enabled
	      _this.$manualInputButton.hide();
	    });

	    defineProperty(assertThisInitialized(assertThisInitialized(_this)), "onHideLayout", function (node, query) {
	      var container = node.closest(_this.containers);
	      /*let _$manualInputButton = !this.multiForms ?
	          this.$manualInputButton :
	          container.find('.afd-manual-input-button');
	      */
	      // show the manual input button if enabled and not all visible

	      var allVisible = !_this.multiForms ? $('[data-afd-result]:hidden').length === 0 : container.find('[data-afd-result]:hidden').length === 0;

	      if (!allVisible && _this.options.typeahead.manualInputButton) {
	        _this.$manualInputButton.show();
	      }
	    });

	    defineProperty(assertThisInitialized(assertThisInitialized(_this)), "onLayoutBuiltBefore", function (node, query, result, resultHtmlList) {
	      if (result.length === 0) {
	        return resultHtmlList;
	      }

	      if (_this.options.typeahead.matchPositions && typeof result[0].matchPositions !== 'undefined') {
	        var openingTag = '<span class="afd-matched-highlight">';
	        var closingTag = '</span>';
	        var tagLengths = openingTag.length + closingTag.length;

	        for (var i = 0; i < result.length; i++) {
	          var item = result[i];
	          var resultItem = $(resultHtmlList.children().eq(i));
	          var holder = resultItem.text();

	          if (typeof item.matchPositions !== 'undefined') {
	            for (var j = 0; j < item.matchPositions.length; j++) {
	              var position = item.matchPositions[j];
	              var offset = j * tagLengths;
	              var inner = '';
	              inner += holder.substr(0, position[0] + offset);
	              inner += openingTag;
	              inner += holder.substr(position[0] + offset, position[1] - position[0]);
	              inner += closingTag;
	              inner += holder.substr(position[1] + offset);
	              holder = inner;
	            }
	          }

	          var output = '<a href="javascript:;">';
	          output += holder;
	          output += '</a>';
	          resultHtmlList.children().eq(i).html(output);
	        }
	      }

	      if (result.length === 1) {
	        resultHtmlList.children().addClass('active');
	      }

	      return resultHtmlList;
	    });

	    defineProperty(assertThisInitialized(assertThisInitialized(_this)), "onSearch", function (node, query) {
	      $('.' + _this.typeaheadOptions.selector.result).empty();
	    });

	    defineProperty(assertThisInitialized(assertThisInitialized(_this)), "onNavigateBefore", function (node, query, e) {
	      if (~[38, 40].indexOf(event.keyCode)) {
	        e.preventInputChange = true;
	      }
	    });

	    defineProperty(assertThisInitialized(assertThisInitialized(_this)), "onClickAfter", function (node, a, item, event) {
	      _this.handleMultiForms();

	      $('.afd-typeahead-field input').val('');

	      if (!item.Key) {
	        _this.showResultFields();

	        _this.$fieldSets.show();

	        _this.$manualInputButton.hide();

	        _this.$manualInputSearchButton.show();

	        _this.$typeaheadFieldandLabel.hide();

	        return;
	      }

	      _this.addressRetrieve(item.Key).then(_this.handleAddressRetrieve).fail(function (err) {
	        return console.error(err);
	      });
	    });

	    defineProperty(assertThisInitialized(assertThisInitialized(_this)), "getTypeaheadSelectors", function (e) {
	      return {
	        container: 'afd-typeahead-container',
	        result: 'afd-typeahead-result',
	        list: 'afd-typeahead-list',
	        group: 'afd-typeahead-group',
	        item: 'afd-typeahead-item',
	        empty: 'afd-typeahead-empty',
	        display: 'afd-typeahead-display',
	        query: 'afd-typeahead-query',
	        filter: 'afd-typeahead-filter',
	        filterButton: 'afd-typeahead-filterButton',
	        dropdown: 'afd-typeahead-dropdown',
	        dropdownItem: 'afd-typeahead-dropdownItem',
	        button: 'afd-typeahead-button',
	        backdrop: 'afd-typeahead-backdrop',
	        hint: 'afd-typeahead-hint',
	        cancelButton: 'afd-typeahead-cancelButton'
	      };
	    });

	    _this.controlType = 'typeahead';
	    _this.timer = null;
	    _this.$reverseGeocodeButton = $element.siblings('.afd-typeahead-reverse-geocode-button');

	    _this.setFields(); // specifying controltype is important for the options that the addressTools Mixin uses


	    _this.refreshUniqeID();

	    _this.setupTypeaheadRequestOptions();

	    _this.typeaheadOptions = _this.prepareTypeaheadOptions();
	    return _this;
	  }

	  return AfdTypeahead;
	}(addressToolsMixin(AfdControl));
	//afdOptions.typeahead.containers = ['#new_address','#old_address'];
	function initTypeahead () {

	  var options = $.extend(true, {}, defaults, afdOptions); // assign typeahead field field
		
	  var $typeahead = $(this); // find out whether or not there is a container in which all elements should be present
	 // alert(options.reverseGeocode.containers.length);

	  var $containerScope = options.reverseGeocode.containers.length === 0 ? $(document) : $typeahead.closest(afdOptions.typeahead.containers); // Validate that there is only one button in container scope
	  if ($containerScope.find('[data-afd-control="typeahead"]').length > 1) {
	    throw 'More than one instance of `typeahead` detected.  If these are in separate containers please define the containers in `afdOptions.typeahead.containers';
	  } // Validate that field is <input>


	  if (!$typeahead.is('input')) {
	    throw '<' + $typeahead.prop('tagName').toLowerCase() + '> is not a valid tag for `[data-afd-control="typeahead"]`, use <input>';
	  } // initialise the control


	  var typeahead = new AfdTypeahead($typeahead, options);
	  $(document).off('afd:init.afd').on('afd:init.afd', function () {
	    typeahead.init();
	  });
	  typeahead.init();
	}

	var dP$2 = _objectDp.f;
	var FProto = Function.prototype;
	var nameRE = /^\s*function ([^ (]*)/;
	var NAME$1 = 'name';

	// 19.2.4.2 name
	NAME$1 in FProto || _descriptors && dP$2(FProto, NAME$1, {
	  configurable: true,
	  get: function () {
	    try {
	      return ('' + this).match(nameRE)[1];
	    } catch (e) {
	      return '';
	    }
	  }
	});

	// getting tag from 19.1.3.6 Object.prototype.toString()

	var TAG$1 = _wks('toStringTag');
	// ES3 wrong here
	var ARG = _cof(function () { return arguments; }()) == 'Arguments';

	// fallback for IE11 Script Access Denied error
	var tryGet = function (it, key) {
	  try {
	    return it[key];
	  } catch (e) { /* empty */ }
	};

	var _classof = function (it) {
	  var O, T, B;
	  return it === undefined ? 'Undefined' : it === null ? 'Null'
	    // @@toStringTag case
	    : typeof (T = tryGet(O = Object(it), TAG$1)) == 'string' ? T
	    // builtinTag case
	    : ARG ? _cof(O)
	    // ES3 arguments fallback
	    : (B = _cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
	};

	var _anInstance = function (it, Constructor, name, forbiddenField) {
	  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
	    throw TypeError(name + ': incorrect invocation!');
	  } return it;
	};

	// call something on iterator step with safe closing on error

	var _iterCall = function (iterator, fn, value, entries) {
	  try {
	    return entries ? fn(_anObject(value)[0], value[1]) : fn(value);
	  // 7.4.6 IteratorClose(iterator, completion)
	  } catch (e) {
	    var ret = iterator['return'];
	    if (ret !== undefined) _anObject(ret.call(iterator));
	    throw e;
	  }
	};

	// check on default Array iterator

	var ITERATOR$2 = _wks('iterator');
	var ArrayProto$1 = Array.prototype;

	var _isArrayIter = function (it) {
	  return it !== undefined && (_iterators.Array === it || ArrayProto$1[ITERATOR$2] === it);
	};

	var ITERATOR$3 = _wks('iterator');

	var core_getIteratorMethod = _core.getIteratorMethod = function (it) {
	  if (it != undefined) return it[ITERATOR$3]
	    || it['@@iterator']
	    || _iterators[_classof(it)];
	};

	var _forOf = createCommonjsModule(function (module) {
	var BREAK = {};
	var RETURN = {};
	var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
	  var iterFn = ITERATOR ? function () { return iterable; } : core_getIteratorMethod(iterable);
	  var f = _ctx(fn, that, entries ? 2 : 1);
	  var index = 0;
	  var length, step, iterator, result;
	  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
	  // fast case for arrays with default iterator
	  if (_isArrayIter(iterFn)) for (length = _toLength(iterable.length); length > index; index++) {
	    result = entries ? f(_anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
	    if (result === BREAK || result === RETURN) return result;
	  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
	    result = _iterCall(iterator, f, step.value, entries);
	    if (result === BREAK || result === RETURN) return result;
	  }
	};
	exports.BREAK = BREAK;
	exports.RETURN = RETURN;
	});

	// 7.3.20 SpeciesConstructor(O, defaultConstructor)


	var SPECIES$2 = _wks('species');
	var _speciesConstructor = function (O, D) {
	  var C = _anObject(O).constructor;
	  var S;
	  return C === undefined || (S = _anObject(C)[SPECIES$2]) == undefined ? D : _aFunction(S);
	};

	// fast apply, http://jsperf.lnkit.com/fast-apply/5
	var _invoke = function (fn, args, that) {
	  var un = that === undefined;
	  switch (args.length) {
	    case 0: return un ? fn()
	                      : fn.call(that);
	    case 1: return un ? fn(args[0])
	                      : fn.call(that, args[0]);
	    case 2: return un ? fn(args[0], args[1])
	                      : fn.call(that, args[0], args[1]);
	    case 3: return un ? fn(args[0], args[1], args[2])
	                      : fn.call(that, args[0], args[1], args[2]);
	    case 4: return un ? fn(args[0], args[1], args[2], args[3])
	                      : fn.call(that, args[0], args[1], args[2], args[3]);
	  } return fn.apply(that, args);
	};

	var process = _global.process;
	var setTask = _global.setImmediate;
	var clearTask = _global.clearImmediate;
	var MessageChannel = _global.MessageChannel;
	var Dispatch = _global.Dispatch;
	var counter = 0;
	var queue = {};
	var ONREADYSTATECHANGE = 'onreadystatechange';
	var defer, channel, port;
	var run = function () {
	  var id = +this;
	  // eslint-disable-next-line no-prototype-builtins
	  if (queue.hasOwnProperty(id)) {
	    var fn = queue[id];
	    delete queue[id];
	    fn();
	  }
	};
	var listener = function (event) {
	  run.call(event.data);
	};
	// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
	if (!setTask || !clearTask) {
	  setTask = function setImmediate(fn) {
	    var args = [];
	    var i = 1;
	    while (arguments.length > i) args.push(arguments[i++]);
	    queue[++counter] = function () {
	      // eslint-disable-next-line no-new-func
	      _invoke(typeof fn == 'function' ? fn : Function(fn), args);
	    };
	    defer(counter);
	    return counter;
	  };
	  clearTask = function clearImmediate(id) {
	    delete queue[id];
	  };
	  // Node.js 0.8-
	  if (_cof(process) == 'process') {
	    defer = function (id) {
	      process.nextTick(_ctx(run, id, 1));
	    };
	  // Sphere (JS game engine) Dispatch API
	  } else if (Dispatch && Dispatch.now) {
	    defer = function (id) {
	      Dispatch.now(_ctx(run, id, 1));
	    };
	  // Browsers with MessageChannel, includes WebWorkers
	  } else if (MessageChannel) {
	    channel = new MessageChannel();
	    port = channel.port2;
	    channel.port1.onmessage = listener;
	    defer = _ctx(port.postMessage, port, 1);
	  // Browsers with postMessage, skip WebWorkers
	  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
	  } else if (_global.addEventListener && typeof postMessage == 'function' && !_global.importScripts) {
	    defer = function (id) {
	      _global.postMessage(id + '', '*');
	    };
	    _global.addEventListener('message', listener, false);
	  // IE8-
	  } else if (ONREADYSTATECHANGE in _domCreate('script')) {
	    defer = function (id) {
	      _html.appendChild(_domCreate('script'))[ONREADYSTATECHANGE] = function () {
	        _html.removeChild(this);
	        run.call(id);
	      };
	    };
	  // Rest old browsers
	  } else {
	    defer = function (id) {
	      setTimeout(_ctx(run, id, 1), 0);
	    };
	  }
	}
	var _task = {
	  set: setTask,
	  clear: clearTask
	};

	var macrotask = _task.set;
	var Observer = _global.MutationObserver || _global.WebKitMutationObserver;
	var process$1 = _global.process;
	var Promise$1 = _global.Promise;
	var isNode = _cof(process$1) == 'process';

	var _microtask = function () {
	  var head, last, notify;

	  var flush = function () {
	    var parent, fn;
	    if (isNode && (parent = process$1.domain)) parent.exit();
	    while (head) {
	      fn = head.fn;
	      head = head.next;
	      try {
	        fn();
	      } catch (e) {
	        if (head) notify();
	        else last = undefined;
	        throw e;
	      }
	    } last = undefined;
	    if (parent) parent.enter();
	  };

	  // Node.js
	  if (isNode) {
	    notify = function () {
	      process$1.nextTick(flush);
	    };
	  // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339
	  } else if (Observer && !(_global.navigator && _global.navigator.standalone)) {
	    var toggle = true;
	    var node = document.createTextNode('');
	    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
	    notify = function () {
	      node.data = toggle = !toggle;
	    };
	  // environments with maybe non-completely correct, but existent Promise
	  } else if (Promise$1 && Promise$1.resolve) {
	    // Promise.resolve without an argument throws an error in LG WebOS 2
	    var promise = Promise$1.resolve(undefined);
	    notify = function () {
	      promise.then(flush);
	    };
	  // for other environments - macrotask based on:
	  // - setImmediate
	  // - MessageChannel
	  // - window.postMessag
	  // - onreadystatechange
	  // - setTimeout
	  } else {
	    notify = function () {
	      // strange IE + webpack dev server bug - use .call(global)
	      macrotask.call(_global, flush);
	    };
	  }

	  return function (fn) {
	    var task = { fn: fn, next: undefined };
	    if (last) last.next = task;
	    if (!head) {
	      head = task;
	      notify();
	    } last = task;
	  };
	};

	// 25.4.1.5 NewPromiseCapability(C)


	function PromiseCapability(C) {
	  var resolve, reject;
	  this.promise = new C(function ($$resolve, $$reject) {
	    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
	    resolve = $$resolve;
	    reject = $$reject;
	  });
	  this.resolve = _aFunction(resolve);
	  this.reject = _aFunction(reject);
	}

	var f$4 = function (C) {
	  return new PromiseCapability(C);
	};

	var _newPromiseCapability = {
		f: f$4
	};

	var _perform = function (exec) {
	  try {
	    return { e: false, v: exec() };
	  } catch (e) {
	    return { e: true, v: e };
	  }
	};

	var navigator = _global.navigator;

	var _userAgent = navigator && navigator.userAgent || '';

	var _promiseResolve = function (C, x) {
	  _anObject(C);
	  if (_isObject(x) && x.constructor === C) return x;
	  var promiseCapability = _newPromiseCapability.f(C);
	  var resolve = promiseCapability.resolve;
	  resolve(x);
	  return promiseCapability.promise;
	};

	var _redefineAll = function (target, src, safe) {
	  for (var key in src) _redefine(target, key, src[key], safe);
	  return target;
	};

	var ITERATOR$4 = _wks('iterator');
	var SAFE_CLOSING = false;

	try {
	  var riter = [7][ITERATOR$4]();
	  riter['return'] = function () { SAFE_CLOSING = true; };
	} catch (e) { /* empty */ }

	var _iterDetect = function (exec, skipClosing) {
	  if (!skipClosing && !SAFE_CLOSING) return false;
	  var safe = false;
	  try {
	    var arr = [7];
	    var iter = arr[ITERATOR$4]();
	    iter.next = function () { return { done: safe = true }; };
	    arr[ITERATOR$4] = function () { return iter; };
	    exec(arr);
	  } catch (e) { /* empty */ }
	  return safe;
	};

	var task = _task.set;
	var microtask = _microtask();




	var PROMISE = 'Promise';
	var TypeError$1 = _global.TypeError;
	var process$2 = _global.process;
	var versions = process$2 && process$2.versions;
	var v8 = versions && versions.v8 || '';
	var $Promise = _global[PROMISE];
	var isNode$1 = _classof(process$2) == 'process';
	var empty = function () { /* empty */ };
	var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
	var newPromiseCapability = newGenericPromiseCapability = _newPromiseCapability.f;

	var USE_NATIVE = !!function () {
	  try {
	    // correct subclassing with @@species support
	    var promise = $Promise.resolve(1);
	    var FakePromise = (promise.constructor = {})[_wks('species')] = function (exec) {
	      exec(empty, empty);
	    };
	    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
	    return (isNode$1 || typeof PromiseRejectionEvent == 'function')
	      && promise.then(empty) instanceof FakePromise
	      // v8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
	      // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
	      // we can't detect it synchronously, so just check versions
	      && v8.indexOf('6.6') !== 0
	      && _userAgent.indexOf('Chrome/66') === -1;
	  } catch (e) { /* empty */ }
	}();

	// helpers
	var isThenable = function (it) {
	  var then;
	  return _isObject(it) && typeof (then = it.then) == 'function' ? then : false;
	};
	var notify = function (promise, isReject) {
	  if (promise._n) return;
	  promise._n = true;
	  var chain = promise._c;
	  microtask(function () {
	    var value = promise._v;
	    var ok = promise._s == 1;
	    var i = 0;
	    var run = function (reaction) {
	      var handler = ok ? reaction.ok : reaction.fail;
	      var resolve = reaction.resolve;
	      var reject = reaction.reject;
	      var domain = reaction.domain;
	      var result, then, exited;
	      try {
	        if (handler) {
	          if (!ok) {
	            if (promise._h == 2) onHandleUnhandled(promise);
	            promise._h = 1;
	          }
	          if (handler === true) result = value;
	          else {
	            if (domain) domain.enter();
	            result = handler(value); // may throw
	            if (domain) {
	              domain.exit();
	              exited = true;
	            }
	          }
	          if (result === reaction.promise) {
	            reject(TypeError$1('Promise-chain cycle'));
	          } else if (then = isThenable(result)) {
	            then.call(result, resolve, reject);
	          } else resolve(result);
	        } else reject(value);
	      } catch (e) {
	        if (domain && !exited) domain.exit();
	        reject(e);
	      }
	    };
	    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach
	    promise._c = [];
	    promise._n = false;
	    if (isReject && !promise._h) onUnhandled(promise);
	  });
	};
	var onUnhandled = function (promise) {
	  task.call(_global, function () {
	    var value = promise._v;
	    var unhandled = isUnhandled(promise);
	    var result, handler, console;
	    if (unhandled) {
	      result = _perform(function () {
	        if (isNode$1) {
	          process$2.emit('unhandledRejection', value, promise);
	        } else if (handler = _global.onunhandledrejection) {
	          handler({ promise: promise, reason: value });
	        } else if ((console = _global.console) && console.error) {
	          console.error('Unhandled promise rejection', value);
	        }
	      });
	      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
	      promise._h = isNode$1 || isUnhandled(promise) ? 2 : 1;
	    } promise._a = undefined;
	    if (unhandled && result.e) throw result.v;
	  });
	};
	var isUnhandled = function (promise) {
	  return promise._h !== 1 && (promise._a || promise._c).length === 0;
	};
	var onHandleUnhandled = function (promise) {
	  task.call(_global, function () {
	    var handler;
	    if (isNode$1) {
	      process$2.emit('rejectionHandled', promise);
	    } else if (handler = _global.onrejectionhandled) {
	      handler({ promise: promise, reason: promise._v });
	    }
	  });
	};
	var $reject = function (value) {
	  var promise = this;
	  if (promise._d) return;
	  promise._d = true;
	  promise = promise._w || promise; // unwrap
	  promise._v = value;
	  promise._s = 2;
	  if (!promise._a) promise._a = promise._c.slice();
	  notify(promise, true);
	};
	var $resolve = function (value) {
	  var promise = this;
	  var then;
	  if (promise._d) return;
	  promise._d = true;
	  promise = promise._w || promise; // unwrap
	  try {
	    if (promise === value) throw TypeError$1("Promise can't be resolved itself");
	    if (then = isThenable(value)) {
	      microtask(function () {
	        var wrapper = { _w: promise, _d: false }; // wrap
	        try {
	          then.call(value, _ctx($resolve, wrapper, 1), _ctx($reject, wrapper, 1));
	        } catch (e) {
	          $reject.call(wrapper, e);
	        }
	      });
	    } else {
	      promise._v = value;
	      promise._s = 1;
	      notify(promise, false);
	    }
	  } catch (e) {
	    $reject.call({ _w: promise, _d: false }, e); // wrap
	  }
	};

	// constructor polyfill
	if (!USE_NATIVE) {
	  // 25.4.3.1 Promise(executor)
	  $Promise = function Promise(executor) {
	    _anInstance(this, $Promise, PROMISE, '_h');
	    _aFunction(executor);
	    Internal.call(this);
	    try {
	      executor(_ctx($resolve, this, 1), _ctx($reject, this, 1));
	    } catch (err) {
	      $reject.call(this, err);
	    }
	  };
	  // eslint-disable-next-line no-unused-vars
	  Internal = function Promise(executor) {
	    this._c = [];             // <- awaiting reactions
	    this._a = undefined;      // <- checked in isUnhandled reactions
	    this._s = 0;              // <- state
	    this._d = false;          // <- done
	    this._v = undefined;      // <- value
	    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
	    this._n = false;          // <- notify
	  };
	  Internal.prototype = _redefineAll($Promise.prototype, {
	    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
	    then: function then(onFulfilled, onRejected) {
	      var reaction = newPromiseCapability(_speciesConstructor(this, $Promise));
	      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
	      reaction.fail = typeof onRejected == 'function' && onRejected;
	      reaction.domain = isNode$1 ? process$2.domain : undefined;
	      this._c.push(reaction);
	      if (this._a) this._a.push(reaction);
	      if (this._s) notify(this, false);
	      return reaction.promise;
	    },
	    // 25.4.5.1 Promise.prototype.catch(onRejected)
	    'catch': function (onRejected) {
	      return this.then(undefined, onRejected);
	    }
	  });
	  OwnPromiseCapability = function () {
	    var promise = new Internal();
	    this.promise = promise;
	    this.resolve = _ctx($resolve, promise, 1);
	    this.reject = _ctx($reject, promise, 1);
	  };
	  _newPromiseCapability.f = newPromiseCapability = function (C) {
	    return C === $Promise || C === Wrapper
	      ? new OwnPromiseCapability(C)
	      : newGenericPromiseCapability(C);
	  };
	}

	_export(_export.G + _export.W + _export.F * !USE_NATIVE, { Promise: $Promise });
	_setToStringTag($Promise, PROMISE);
	_setSpecies(PROMISE);
	Wrapper = _core[PROMISE];

	// statics
	_export(_export.S + _export.F * !USE_NATIVE, PROMISE, {
	  // 25.4.4.5 Promise.reject(r)
	  reject: function reject(r) {
	    var capability = newPromiseCapability(this);
	    var $$reject = capability.reject;
	    $$reject(r);
	    return capability.promise;
	  }
	});
	_export(_export.S + _export.F * (_library || !USE_NATIVE), PROMISE, {
	  // 25.4.4.6 Promise.resolve(x)
	  resolve: function resolve(x) {
	    return _promiseResolve(_library && this === Wrapper ? $Promise : this, x);
	  }
	});
	_export(_export.S + _export.F * !(USE_NATIVE && _iterDetect(function (iter) {
	  $Promise.all(iter)['catch'](empty);
	})), PROMISE, {
	  // 25.4.4.1 Promise.all(iterable)
	  all: function all(iterable) {
	    var C = this;
	    var capability = newPromiseCapability(C);
	    var resolve = capability.resolve;
	    var reject = capability.reject;
	    var result = _perform(function () {
	      var values = [];
	      var index = 0;
	      var remaining = 1;
	      _forOf(iterable, false, function (promise) {
	        var $index = index++;
	        var alreadyCalled = false;
	        values.push(undefined);
	        remaining++;
	        C.resolve(promise).then(function (value) {
	          if (alreadyCalled) return;
	          alreadyCalled = true;
	          values[$index] = value;
	          --remaining || resolve(values);
	        }, reject);
	      });
	      --remaining || resolve(values);
	    });
	    if (result.e) reject(result.v);
	    return capability.promise;
	  },
	  // 25.4.4.4 Promise.race(iterable)
	  race: function race(iterable) {
	    var C = this;
	    var capability = newPromiseCapability(C);
	    var reject = capability.reject;
	    var result = _perform(function () {
	      _forOf(iterable, false, function (promise) {
	        C.resolve(promise).then(capability.resolve, reject);
	      });
	    });
	    if (result.e) reject(result.v);
	    return capability.promise;
	  }
	});

	function _defineProperties(target, props) {
	  for (var i = 0; i < props.length; i++) {
	    var descriptor = props[i];
	    descriptor.enumerable = descriptor.enumerable || false;
	    descriptor.configurable = true;
	    if ("value" in descriptor) descriptor.writable = true;
	    Object.defineProperty(target, descriptor.key, descriptor);
	  }
	}

	function _createClass(Constructor, protoProps, staticProps) {
	  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
	  if (staticProps) _defineProperties(Constructor, staticProps);
	  return Constructor;
	}

	var createClass = _createClass;

	var AfdCountries =
	/*#__PURE__*/
	function (_AfdControl) {
	  inherits(AfdCountries, _AfdControl);

	  function AfdCountries($element, options) {
	    var _this;

	    classCallCheck(this, AfdCountries);

	    _this = possibleConstructorReturn(this, getPrototypeOf(AfdCountries).call(this, $element, options));

	    defineProperty(assertThisInitialized(assertThisInitialized(_this)), "onChange", function (e) {
	      $(document).trigger('afd:countryChanged', [e.target.value]);
	    });

	    defineProperty(assertThisInitialized(assertThisInitialized(_this)), "getCountries", function ($element) {
	      $(document).trigger('afd:getCountriesStart');
	      var externalResolver;
	      var outputPromise = new Promise(function (resolve) {
	        externalResolver = resolve;
	      });

	      var requestOptions = _this.setupParams({
	        data: 'list',
	        task: 'listcountries',
	        fields: 'standard',
	        countryISO: 'FRA'
	      });

	      $.ajax(requestOptions).done(_this.handleGetCountries.bind(null, externalResolver));
	      return outputPromise;
	    });

	    defineProperty(assertThisInitialized(assertThisInitialized(_this)), "handleGetCountries", function (externalResolver, data) {
	      if (data.status === -2) {
	        var err = typeof data.reason !== 'undefined' ? data.reason : '';
	        err += typeof data.other !== 'undefined' ? ' - ' + data.other : '';
	        throw err;
	      }

	      var countries = data.Item;
	      $.each(countries, function (index, country) {
	        var shouldAppend = _this.options.typeahead.availableCountries.length > 0 && _this.options.typeahead.availableCountries.indexOf(country.iso) > -1 || _this.options.country.availableCountries.length > 0 && _this.options.country.availableCountries.indexOf(country.iso) > -1 || _this.options.typeahead.availableCountries.length < 1 && _this.options.country.availableCountries.length < 1;

	        if (shouldAppend) {
	          _this.$element.append($('<option />').val(country.iso).text(country.name));
	        }
	      }); // depricated

	      if (_this.options.defaultCountry) {
	        _this.$element.val(_this.options.defaultCountry);

	        $(document).trigger('afd:countryChanged', [_this.$element.val()]);
	      } // should use this


	      if (_this.options.country.defaultCountry) {
	        _this.$element.val(_this.options.country.defaultCountry);

	        $(document).trigger('afd:countryChanged', [_this.$element.val()]);
	      }

	      $(document).trigger('afd:getCountriesComplete', countries);
	      externalResolver();
	    });

	    return _this;
	  }

	  createClass(AfdCountries, [{
	    key: "init",
	    value: function init() {
	      this.eventHandler(this.$element, 'change', this.onChange);
	      return this.getCountries();
	    }
	  }]);

	  return AfdCountries;
	}(AfdControl);

	function initCountry (controlType, resolve) {
	  var $this = $(this);

	  var options = $.extend(true, {}, defaults, afdOptions);

	  try {
	    var countries = new AfdCountries($this, options);
	    countries.init().then(function () {
	      resolve();
	    });
	  } catch (e) {
	    console.error('Error initialising country control');
	    console.error(e);
	  }
	}

	function dataDefinition() {
	  // prevent the init script from running several times if multiple modules are loaded
	  if (typeof window.afdDataInit === 'undefined') {
	    window.afdDataInit = false;
	  } // Data API definitions


	  $(document).ready(function () {
	    if (!window.afdDataInit) {
	      window.afdDataInit = true;
	      $(document).trigger('afd::page_ready');
	    }
	  }); // Set page_ready listener for data definitions

	  $(document).off('afd::page_ready').on('afd::page_ready', function () {
	    // Fields that need to perform ajax requests before the rest of the controls can be initialised
	    var dependantFields = ['country']; // create an array of promises for dependent requests

	    var dependantRequests = []; //First only initialise the controls that other controls are dependant on

	    $('[data-afd-control]').each(function () {
	      var $this = $(this);
	      var controlType = $this.data('afd-control'); // check if this is a control that needs to be initialised before the rest

	      if (dependantFields.indexOf(controlType) > -1) {
	        // add a new promise to the dependent requests array
	        dependantRequests.push(new Promise(function (resolve, reject) {
	          initialiseControl($this, controlType, resolve);
	        }));
	      }
	    }); // If there were dependant requests then once they have all completed we can intialise the rest of the controls

	    Promise.all(dependantRequests).then(function () {
	      // Only do non dependant controls
	      $('[data-afd-control]').each(function () {
	        var $this = $(this);
	        var controlType = $this.data('afd-control');

	        if (dependantFields.indexOf(controlType) === -1) {
	          initialiseControl($this, controlType, null);
	        }
	      });
	    });
	  });
	}

	function initialiseControl(control, controlType, resolve) {
	  // activate the module on this element according to the data-afd-control
	  try {
	    control.afd(controlType, resolve);
	  } catch (e) {
	    console.error(e);
	  }
	}

	window.afdInitScripts = typeof window.afdInitScripts === 'undefined' ? {
	  lookupButton: null,
	  typeahead: null,
	  reverseGeocodeButton: null,
	  account: null,
	  card: null,
	  email: null,
	  phone: null,
	  country: null
	} : window.afdInitScripts;
	window.afdInitScripts.lookupButton = typeof initLookup !== 'undefined' ? initLookup : window.afdInitScripts.lookupButton ? window.afdInitScripts.lookupButton : null;
	window.afdInitScripts.typeahead = typeof initTypeahead !== 'undefined' ? initTypeahead : window.afdInitScripts.typeahead ? window.afdInitScripts.typeahead : null;
	window.afdInitScripts.reverseGeocodeButton = typeof initReverseGeocode !== 'undefined' ? initReverseGeocode : window.afdInitScripts.reverseGeocodeButton ? window.afdInitScripts.reverseGeocodeButton : null;
	window.afdInitScripts.account = typeof initAccount !== 'undefined' ? initAccount : window.afdInitScripts.account ? window.afdInitScripts.account : null;
	window.afdInitScripts.card = typeof initCard !== 'undefined' ? initCard : window.afdInitScripts.card ? _typeof_1(window.afdInitScripts.card) : null;
	window.afdInitScripts.email = typeof initEmail !== 'undefined' ? initEmail : window.afdInitScripts.email ? window.afdInitScripts.email : null;
	window.afdInitScripts.phone = typeof initPhone !== 'undefined' ? initPhone : window.afdInitScripts.phone ? window.afdInitScripts.phone : null;
	window.afdInitScripts.country = typeof initCountry !== 'undefined' ? initCountry : window.afdInitScripts.country ? window.afdInitScripts.country : null;

	(function ($) {
	  // Init plugin so $('selector').afd('control-name') can work
	  $.fn.afd = function (controlType, resolve) {
	    return this.each(function () {
	      //fields that do not need to be initialised
	      var nonInitFields = ['lookupField', 'lookupResultsList', 'reverseGeocodeResultsList', 'sort', 'expiry'];

	      if (nonInitFields.indexOf(controlType) > -1) {
	        return;
	      } //If invalid field is supplied


	      var validFields = ['typeahead', 'lookupButton', 'country', 'reverseGeocodeButton', 'phone', 'email', 'account', 'card'];

	      if (validFields.indexOf(controlType) === -1) {
	        throw '`' + controlType + '` is not a valid AFD jQuery control.  Please use one of ' + validFields + ',' + nonInitFields;
	      } // if user is trying to init a field that module isn't loaded


	      if (!window.afdInitScripts[controlType]) {
	        throw 'You are trying to intitialise the control `' + controlType + '` but it seems that you have not loaded this module';
	      }

	      try {
	        window.afdInitScripts[controlType].call(this, controlType, resolve, constructor);
	      } catch (err) {
	        console.error('Problem initialising AFD Control');
	        console.error(err);
	      }
	    });
	  }; // Definitions for `data-afd-control=`


	  dataDefinition(); // If this is post render version

	  if (typeof postRender !== 'undefined') {
	    $(document).ready(function () {
	      $(document).trigger('afd::initPostRender');
	    });
	    $(document).on('afd::initPostRender', function () {
	      try {
	        if (typeof afdOptions.postRender === 'undefined') {
	          throw 'Post Render version of plugin used bit no post render options supplied';
	        }

	        postRender(afdOptions.postRender);
	        $(document).trigger('afd:postRenderInitComplete');
	      } catch (e) {
	        console.error(e);
	      }

	      $(document).trigger('afd::page_ready');
	    });
	  }
	})(jQuery);

})));
//# sourceMappingURL=afd.typeahead.jquery.1.9.0.min.js.map
