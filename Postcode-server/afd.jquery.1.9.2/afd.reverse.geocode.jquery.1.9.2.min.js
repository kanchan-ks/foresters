(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('jquery')) :
	typeof define === 'function' && define.amd ? define(['jquery'], factory) :
	(factory(global.$));
}(this, (function (jQuery$1) { 'use strict';

	jQuery$1 = jQuery$1 && jQuery$1.hasOwnProperty('default') ? jQuery$1['default'] : jQuery$1;

	var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	var _global = createCommonjsModule(function (module) {
	// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
	var global = module.exports = typeof window != 'undefined' && window.Math == Math
	  ? window : typeof self != 'undefined' && self.Math == Math ? self
	  // eslint-disable-next-line no-new-func
	  : Function('return this')();
	if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef
	});

	var _core = createCommonjsModule(function (module) {
	var core = module.exports = { version: '2.5.7' };
	if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef
	});
	var _core_1 = _core.version;

	var _isObject = function (it) {
	  return typeof it === 'object' ? it !== null : typeof it === 'function';
	};

	var _anObject = function (it) {
	  if (!_isObject(it)) throw TypeError(it + ' is not an object!');
	  return it;
	};

	var _fails = function (exec) {
	  try {
	    return !!exec();
	  } catch (e) {
	    return true;
	  }
	};

	// Thank's IE8 for his funny defineProperty
	var _descriptors = !_fails(function () {
	  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
	});

	var document$1 = _global.document;
	// typeof document.createElement is 'object' in old IE
	var is = _isObject(document$1) && _isObject(document$1.createElement);
	var _domCreate = function (it) {
	  return is ? document$1.createElement(it) : {};
	};

	var _ie8DomDefine = !_descriptors && !_fails(function () {
	  return Object.defineProperty(_domCreate('div'), 'a', { get: function () { return 7; } }).a != 7;
	});

	// 7.1.1 ToPrimitive(input [, PreferredType])

	// instead of the ES6 spec version, we didn't implement @@toPrimitive case
	// and the second argument - flag - preferred type is a string
	var _toPrimitive = function (it, S) {
	  if (!_isObject(it)) return it;
	  var fn, val;
	  if (S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) return val;
	  if (typeof (fn = it.valueOf) == 'function' && !_isObject(val = fn.call(it))) return val;
	  if (!S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) return val;
	  throw TypeError("Can't convert object to primitive value");
	};

	var dP = Object.defineProperty;

	var f = _descriptors ? Object.defineProperty : function defineProperty(O, P, Attributes) {
	  _anObject(O);
	  P = _toPrimitive(P, true);
	  _anObject(Attributes);
	  if (_ie8DomDefine) try {
	    return dP(O, P, Attributes);
	  } catch (e) { /* empty */ }
	  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
	  if ('value' in Attributes) O[P] = Attributes.value;
	  return O;
	};

	var _objectDp = {
		f: f
	};

	var _propertyDesc = function (bitmap, value) {
	  return {
	    enumerable: !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable: !(bitmap & 4),
	    value: value
	  };
	};

	var _hide = _descriptors ? function (object, key, value) {
	  return _objectDp.f(object, key, _propertyDesc(1, value));
	} : function (object, key, value) {
	  object[key] = value;
	  return object;
	};

	var hasOwnProperty = {}.hasOwnProperty;
	var _has = function (it, key) {
	  return hasOwnProperty.call(it, key);
	};

	var id = 0;
	var px = Math.random();
	var _uid = function (key) {
	  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
	};

	var _redefine = createCommonjsModule(function (module) {
	var SRC = _uid('src');
	var TO_STRING = 'toString';
	var $toString = Function[TO_STRING];
	var TPL = ('' + $toString).split(TO_STRING);

	_core.inspectSource = function (it) {
	  return $toString.call(it);
	};

	(module.exports = function (O, key, val, safe) {
	  var isFunction = typeof val == 'function';
	  if (isFunction) _has(val, 'name') || _hide(val, 'name', key);
	  if (O[key] === val) return;
	  if (isFunction) _has(val, SRC) || _hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
	  if (O === _global) {
	    O[key] = val;
	  } else if (!safe) {
	    delete O[key];
	    _hide(O, key, val);
	  } else if (O[key]) {
	    O[key] = val;
	  } else {
	    _hide(O, key, val);
	  }
	// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
	})(Function.prototype, TO_STRING, function toString() {
	  return typeof this == 'function' && this[SRC] || $toString.call(this);
	});
	});

	var _aFunction = function (it) {
	  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
	  return it;
	};

	// optional / simple context binding

	var _ctx = function (fn, that, length) {
	  _aFunction(fn);
	  if (that === undefined) return fn;
	  switch (length) {
	    case 1: return function (a) {
	      return fn.call(that, a);
	    };
	    case 2: return function (a, b) {
	      return fn.call(that, a, b);
	    };
	    case 3: return function (a, b, c) {
	      return fn.call(that, a, b, c);
	    };
	  }
	  return function (/* ...args */) {
	    return fn.apply(that, arguments);
	  };
	};

	var PROTOTYPE = 'prototype';

	var $export = function (type, name, source) {
	  var IS_FORCED = type & $export.F;
	  var IS_GLOBAL = type & $export.G;
	  var IS_STATIC = type & $export.S;
	  var IS_PROTO = type & $export.P;
	  var IS_BIND = type & $export.B;
	  var target = IS_GLOBAL ? _global : IS_STATIC ? _global[name] || (_global[name] = {}) : (_global[name] || {})[PROTOTYPE];
	  var exports = IS_GLOBAL ? _core : _core[name] || (_core[name] = {});
	  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
	  var key, own, out, exp;
	  if (IS_GLOBAL) source = name;
	  for (key in source) {
	    // contains in native
	    own = !IS_FORCED && target && target[key] !== undefined;
	    // export native or passed
	    out = (own ? target : source)[key];
	    // bind timers to global for call from export context
	    exp = IS_BIND && own ? _ctx(out, _global) : IS_PROTO && typeof out == 'function' ? _ctx(Function.call, out) : out;
	    // extend global
	    if (target) _redefine(target, key, out, type & $export.U);
	    // export
	    if (exports[key] != out) _hide(exports, key, exp);
	    if (IS_PROTO && expProto[key] != out) expProto[key] = out;
	  }
	};
	_global.core = _core;
	// type bitmap
	$export.F = 1;   // forced
	$export.G = 2;   // global
	$export.S = 4;   // static
	$export.P = 8;   // proto
	$export.B = 16;  // bind
	$export.W = 32;  // wrap
	$export.U = 64;  // safe
	$export.R = 128; // real proto method for `library`
	var _export = $export;

	var toString = {}.toString;

	var _cof = function (it) {
	  return toString.call(it).slice(8, -1);
	};

	// fallback for non-array-like ES3 and non-enumerable old V8 strings

	// eslint-disable-next-line no-prototype-builtins
	var _iobject = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
	  return _cof(it) == 'String' ? it.split('') : Object(it);
	};

	// 7.2.1 RequireObjectCoercible(argument)
	var _defined = function (it) {
	  if (it == undefined) throw TypeError("Can't call method on  " + it);
	  return it;
	};

	// 7.1.13 ToObject(argument)

	var _toObject = function (it) {
	  return Object(_defined(it));
	};

	// 7.1.4 ToInteger
	var ceil = Math.ceil;
	var floor = Math.floor;
	var _toInteger = function (it) {
	  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
	};

	// 7.1.15 ToLength

	var min = Math.min;
	var _toLength = function (it) {
	  return it > 0 ? min(_toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
	};

	// 7.2.2 IsArray(argument)

	var _isArray = Array.isArray || function isArray(arg) {
	  return _cof(arg) == 'Array';
	};

	var _library = false;

	var _shared = createCommonjsModule(function (module) {
	var SHARED = '__core-js_shared__';
	var store = _global[SHARED] || (_global[SHARED] = {});

	(module.exports = function (key, value) {
	  return store[key] || (store[key] = value !== undefined ? value : {});
	})('versions', []).push({
	  version: _core.version,
	  mode: 'global',
	  copyright: 'Â© 2018 Denis Pushkarev (zloirock.ru)'
	});
	});

	var _wks = createCommonjsModule(function (module) {
	var store = _shared('wks');

	var Symbol = _global.Symbol;
	var USE_SYMBOL = typeof Symbol == 'function';

	var $exports = module.exports = function (name) {
	  return store[name] || (store[name] =
	    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : _uid)('Symbol.' + name));
	};

	$exports.store = store;
	});

	var SPECIES = _wks('species');

	var _arraySpeciesConstructor = function (original) {
	  var C;
	  if (_isArray(original)) {
	    C = original.constructor;
	    // cross-realm fallback
	    if (typeof C == 'function' && (C === Array || _isArray(C.prototype))) C = undefined;
	    if (_isObject(C)) {
	      C = C[SPECIES];
	      if (C === null) C = undefined;
	    }
	  } return C === undefined ? Array : C;
	};

	// 9.4.2.3 ArraySpeciesCreate(originalArray, length)


	var _arraySpeciesCreate = function (original, length) {
	  return new (_arraySpeciesConstructor(original))(length);
	};

	// 0 -> Array#forEach
	// 1 -> Array#map
	// 2 -> Array#filter
	// 3 -> Array#some
	// 4 -> Array#every
	// 5 -> Array#find
	// 6 -> Array#findIndex





	var _arrayMethods = function (TYPE, $create) {
	  var IS_MAP = TYPE == 1;
	  var IS_FILTER = TYPE == 2;
	  var IS_SOME = TYPE == 3;
	  var IS_EVERY = TYPE == 4;
	  var IS_FIND_INDEX = TYPE == 6;
	  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
	  var create = $create || _arraySpeciesCreate;
	  return function ($this, callbackfn, that) {
	    var O = _toObject($this);
	    var self = _iobject(O);
	    var f = _ctx(callbackfn, that, 3);
	    var length = _toLength(self.length);
	    var index = 0;
	    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
	    var val, res;
	    for (;length > index; index++) if (NO_HOLES || index in self) {
	      val = self[index];
	      res = f(val, index, O);
	      if (TYPE) {
	        if (IS_MAP) result[index] = res;   // map
	        else if (res) switch (TYPE) {
	          case 3: return true;             // some
	          case 5: return val;              // find
	          case 6: return index;            // findIndex
	          case 2: result.push(val);        // filter
	        } else if (IS_EVERY) return false; // every
	      }
	    }
	    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
	  };
	};

	// 22.1.3.31 Array.prototype[@@unscopables]
	var UNSCOPABLES = _wks('unscopables');
	var ArrayProto = Array.prototype;
	if (ArrayProto[UNSCOPABLES] == undefined) _hide(ArrayProto, UNSCOPABLES, {});
	var _addToUnscopables = function (key) {
	  ArrayProto[UNSCOPABLES][key] = true;
	};

	// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)

	var $find = _arrayMethods(5);
	var KEY = 'find';
	var forced = true;
	// Shouldn't skip holes
	if (KEY in []) Array(1)[KEY](function () { forced = false; });
	_export(_export.P + _export.F * forced, 'Array', {
	  find: function find(callbackfn /* , that = undefined */) {
	    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});
	_addToUnscopables(KEY);

	var defaults = {
	  pceUrl: '//pce.afd.co.uk/afddata.pce',
	  nativeValidationMessages: false,
	  defaultCountry: null,
	  afdc: 0,
	  phone: {
	    defaultDialingCode: '+44',
	    invalidPhoneNumberMessage: 'Please input a valid phone number',
	    loadingSpinner: null,
	    countryControl: null,
	    countryControlConverter: null
	  },
	  email: {
	    invalidEmailMessage: 'Please input a valid email address',
	    loadingSpinner: null
	  },
	  card: {
	    invalidCardNumberMessage: 'Please input a valid card number',
	    invalidCardOrExpiryMessage: 'Either the card number or expiry date are not valid',
	    invalidExpiryMonthMessage: 'Please input a valid month',
	    invalidExpiryDateMessage: 'Please input a valid expiry date',
	    loadingSpinner: null,
	    logoHeight: 16,
	    logoWidth: 24
	  },
	  account: {
	    invalidAccountNumberMessage: 'Please input a valid account number',
	    invalidSortCodeMessage: 'Please input a valid Sort Code',
	    loadingSpinner: null
	  },
	  typeahead: {
	    maxItems: 5,
	    pushUp: false,
	    afterHideTypeahead: false,
	    searchAgain: true,
	    afterClearTypeahead: true,
	    beforeHideResults: false,
	    parentClass: null,
	    fieldSets: [],
	    manualInputButton: false,
	    fewResultsManualInput: true,
	    fewResultsManualInputText: 'Can\'t see your address? Enter it manually',
	    notEmptyShowResults: false,
	    hideEmpties: false,
	    containers: [],
	    retrieveFields: 'standard',
	    availableCountries: [],
	    minLength: 2,
	    matchPositions: false,
	    postcodeFirst: true,
	    hideForCountries: [],
	    showForCountries: [],
	    containerOnlyContainsControl: false,
	    regionMap: null,
	    regionAttribute: 'value'
	  },
	  lookup: {
	    prefetch: true,
	    pushUp: false,
	    beforeHideResults: false,
	    parentClass: null,
	    fieldSets: [],
	    manualInputButton: false,
	    hideEmpties: false,
	    afterRetrieveHideResultsList: true,
	    postcodeIsLookup: false,
	    resultsContainer: '',
	    containers: [],
	    retrieveFields: 'standard',
	    availableCountries: [],
	    postcodeFirst: true,
	    hideForCountries: [],
	    showForCountries: [],
	    regionMap: null,
	    regionAttribute: 'value',
	    selectAddressText: 'Please select an address'
	  },
	  country: {
	    defaultCountry: null,
	    availableCountries: [],
	    customCountryControl: null,
	    customCountryConverter: null
	  },
	  reverseGeocode: {
	    maxItems: 100,
	    pushUp: false,
	    fieldSets: [],
	    hideEmpties: false,
	    afterRetrieveHideResultsList: true,
	    containers: [],
	    retrieveFields: 'standard',
	    postcodeFirst: true,
	    hideForCountries: [],
	    showForCountries: ['GBR'],
	    linkedControl: 'typeahead',
	    hideOnDesktop: false,
	    buttonContainer: null
	  }
	};

	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	}

	var classCallCheck = _classCallCheck;

	var _typeof_1 = createCommonjsModule(function (module) {
	function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

	function _typeof(obj) {
	  if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
	    module.exports = _typeof = function _typeof(obj) {
	      return _typeof2(obj);
	    };
	  } else {
	    module.exports = _typeof = function _typeof(obj) {
	      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
	    };
	  }

	  return _typeof(obj);
	}

	module.exports = _typeof;
	});

	function _assertThisInitialized(self) {
	  if (self === void 0) {
	    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	  }

	  return self;
	}

	var assertThisInitialized = _assertThisInitialized;

	function _possibleConstructorReturn(self, call) {
	  if (call && (_typeof_1(call) === "object" || typeof call === "function")) {
	    return call;
	  }

	  return assertThisInitialized(self);
	}

	var possibleConstructorReturn = _possibleConstructorReturn;

	var getPrototypeOf = createCommonjsModule(function (module) {
	function _getPrototypeOf(o) {
	  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
	    return o.__proto__ || Object.getPrototypeOf(o);
	  };
	  return _getPrototypeOf(o);
	}

	module.exports = _getPrototypeOf;
	});

	var setPrototypeOf = createCommonjsModule(function (module) {
	function _setPrototypeOf(o, p) {
	  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
	    o.__proto__ = p;
	    return o;
	  };

	  return _setPrototypeOf(o, p);
	}

	module.exports = _setPrototypeOf;
	});

	function _inherits(subClass, superClass) {
	  if (typeof superClass !== "function" && superClass !== null) {
	    throw new TypeError("Super expression must either be null or a function");
	  }

	  subClass.prototype = Object.create(superClass && superClass.prototype, {
	    constructor: {
	      value: subClass,
	      writable: true,
	      configurable: true
	    }
	  });
	  if (superClass) setPrototypeOf(subClass, superClass);
	}

	var inherits = _inherits;

	function _defineProperty(obj, key, value) {
	  if (key in obj) {
	    Object.defineProperty(obj, key, {
	      value: value,
	      enumerable: true,
	      configurable: true,
	      writable: true
	    });
	  } else {
	    obj[key] = value;
	  }

	  return obj;
	}

	var defineProperty = _defineProperty;

	// 21.2.5.3 get RegExp.prototype.flags

	var _flags = function () {
	  var that = _anObject(this);
	  var result = '';
	  if (that.global) result += 'g';
	  if (that.ignoreCase) result += 'i';
	  if (that.multiline) result += 'm';
	  if (that.unicode) result += 'u';
	  if (that.sticky) result += 'y';
	  return result;
	};

	// 21.2.5.3 get RegExp.prototype.flags()
	if (_descriptors && /./g.flags != 'g') _objectDp.f(RegExp.prototype, 'flags', {
	  configurable: true,
	  get: _flags
	});

	var TO_STRING = 'toString';
	var $toString = /./[TO_STRING];

	var define = function (fn) {
	  _redefine(RegExp.prototype, TO_STRING, fn, true);
	};

	// 21.2.5.14 RegExp.prototype.toString()
	if (_fails(function () { return $toString.call({ source: 'a', flags: 'b' }) != '/a/b'; })) {
	  define(function toString() {
	    var R = _anObject(this);
	    return '/'.concat(R.source, '/',
	      'flags' in R ? R.flags : !_descriptors && R instanceof RegExp ? _flags.call(R) : undefined);
	  });
	// FF44- RegExp#toString has a wrong name
	} else if ($toString.name != TO_STRING) {
	  define(function toString() {
	    return $toString.call(this);
	  });
	}

	var AfdControl = function AfdControl($el, options) {
	  var _this = this;

	  classCallCheck(this, AfdControl);

	  defineProperty(this, "setupParams", function (requestOptions) {
	    var defaultData = {
	      format: 'json'
	    };

	    if (_this.options.serial && _this.options.password) {
	      defaultData.serial = _this.options.serial;
	      defaultData.password = _this.options.password;
	    } else if (_this.options.token && _this.options.id) {
	      defaultData.token = _this.options.token;
	      defaultData.id = _this.options.id;
	    } else {
	      throw 'You must either supply password and serial, or token and id';
	    } // reverseGeocode should not have a country ISO set


	    if (_this.controlType !== 'reverseGeocode') {
	      // check to see if default country
	      if (_this.options.defaultCountry) {
	        defaultData.countryiso = _this.options.defaultCountry;
	      }

	      if (_this.options.country.defaultCountry) {
	        defaultData.countryiso = _this.options.country.defaultCountry;
	      } // Check to see if there is a country control, if so WA will be activated


	      var $countryField = $('[data-afd-control="country"]');

	      if ($countryField.length > 0) {
	        defaultData.countryiso = $countryField.val();
	      } // checks to see if there is a custom country control and whether or not a function is supplied to turn the value into ISO3


	      if (_this.options.country.customCountryControl) {
	        var customCountryControl = _this.options.typeahead.containers.length === 0 ? $(_this.options.country.customCountryControl) : _this.$element.closest(_this.options.typeahead.containers.toString).find(_this.options.country.customCountryControl);

	        if (_this.options.country.customCountryConverter) {
	          if (typeof _this.options.country.customCountryConverter !== 'function') {
	            throw 'customCountryConverter Must be a function';
	          }

	          defaultData.countryiso = _this.options.country.customCountryConverter(customCountryControl.val());
	        } else {
	          defaultData.countryiso = customCountryControl.val();
	        }
	      }
	    }

	    try {
	      return {
	        method: 'GET',
	        url: _this.options.pceUrl,
	        error: function error(err, errText, errThrown) {
	          console.log(err);
	          console.log(errText);
	          console.log(errThrown);
	          $(document).trigger('afd:pceError', err);
	        },
	        data: $.extend(true, {}, defaultData, requestOptions),
	        // callback and beforesend are only applicable when the request sequence module is used
	        callback: typeof _this.requestCallback !== 'undefined' ? {
	          done: _this.requestCallback
	        } : null,
	        beforeSend: typeof _this.beforeSend !== 'undefined' ? _this.beforeSend : null
	      };
	    } catch (err) {
	      console.error('Error setting up request');
	      console.error(err);
	    }
	  });

	  defineProperty(this, "eventHandler", function ($element, event, handler) {
	    $element.off(event + '.afd').on(event + '.afd', handler);
	  });

	  this.$element = $el;
	  this.element = $el.get()[0];

	  if (typeof $el.data('afd-additional-options') !== 'undefined') {
	    var customOptions = window[$el.data('afd-additional-options')];
	    this.options = $.extend(true, {}, options, customOptions);
	  } else {
	    this.options = options;
	  }
	};

	function _arrayWithHoles(arr) {
	  if (Array.isArray(arr)) return arr;
	}

	var arrayWithHoles = _arrayWithHoles;

	function _iterableToArrayLimit(arr, i) {
	  var _arr = [];
	  var _n = true;
	  var _d = false;
	  var _e = undefined;

	  try {
	    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
	      _arr.push(_s.value);

	      if (i && _arr.length === i) break;
	    }
	  } catch (err) {
	    _d = true;
	    _e = err;
	  } finally {
	    try {
	      if (!_n && _i["return"] != null) _i["return"]();
	    } finally {
	      if (_d) throw _e;
	    }
	  }

	  return _arr;
	}

	var iterableToArrayLimit = _iterableToArrayLimit;

	function _nonIterableRest() {
	  throw new TypeError("Invalid attempt to destructure non-iterable instance");
	}

	var nonIterableRest = _nonIterableRest;

	function _slicedToArray(arr, i) {
	  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || nonIterableRest();
	}

	var slicedToArray = _slicedToArray;

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$1 = objectProto.hasOwnProperty;

	/**
	 * The base implementation of `_.has` without support for deep paths.
	 *
	 * @private
	 * @param {Object} [object] The object to query.
	 * @param {Array|string} key The key to check.
	 * @returns {boolean} Returns `true` if `key` exists, else `false`.
	 */
	function baseHas(object, key) {
	  return object != null && hasOwnProperty$1.call(object, key);
	}

	var _baseHas = baseHas;

	/**
	 * Checks if `value` is classified as an `Array` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
	 * @example
	 *
	 * _.isArray([1, 2, 3]);
	 * // => true
	 *
	 * _.isArray(document.body.children);
	 * // => false
	 *
	 * _.isArray('abc');
	 * // => false
	 *
	 * _.isArray(_.noop);
	 * // => false
	 */
	var isArray = Array.isArray;

	var isArray_1 = isArray;

	/** Detect free variable `global` from Node.js. */
	var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

	var _freeGlobal = freeGlobal;

	/** Detect free variable `self`. */
	var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

	/** Used as a reference to the global object. */
	var root = _freeGlobal || freeSelf || Function('return this')();

	var _root = root;

	/** Built-in value references. */
	var Symbol$1 = _root.Symbol;

	var _Symbol = Symbol$1;

	/** Used for built-in method references. */
	var objectProto$1 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$2 = objectProto$1.hasOwnProperty;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString = objectProto$1.toString;

	/** Built-in value references. */
	var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;

	/**
	 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the raw `toStringTag`.
	 */
	function getRawTag(value) {
	  var isOwn = hasOwnProperty$2.call(value, symToStringTag),
	      tag = value[symToStringTag];

	  try {
	    value[symToStringTag] = undefined;
	  } catch (e) {}

	  var result = nativeObjectToString.call(value);
	  {
	    if (isOwn) {
	      value[symToStringTag] = tag;
	    } else {
	      delete value[symToStringTag];
	    }
	  }
	  return result;
	}

	var _getRawTag = getRawTag;

	/** Used for built-in method references. */
	var objectProto$2 = Object.prototype;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString$1 = objectProto$2.toString;

	/**
	 * Converts `value` to a string using `Object.prototype.toString`.
	 *
	 * @private
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 */
	function objectToString(value) {
	  return nativeObjectToString$1.call(value);
	}

	var _objectToString = objectToString;

	/** `Object#toString` result references. */
	var nullTag = '[object Null]',
	    undefinedTag = '[object Undefined]';

	/** Built-in value references. */
	var symToStringTag$1 = _Symbol ? _Symbol.toStringTag : undefined;

	/**
	 * The base implementation of `getTag` without fallbacks for buggy environments.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	function baseGetTag(value) {
	  if (value == null) {
	    return value === undefined ? undefinedTag : nullTag;
	  }
	  return (symToStringTag$1 && symToStringTag$1 in Object(value))
	    ? _getRawTag(value)
	    : _objectToString(value);
	}

	var _baseGetTag = baseGetTag;

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return value != null && typeof value == 'object';
	}

	var isObjectLike_1 = isObjectLike;

	/** `Object#toString` result references. */
	var symbolTag = '[object Symbol]';

	/**
	 * Checks if `value` is classified as a `Symbol` primitive or object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
	 * @example
	 *
	 * _.isSymbol(Symbol.iterator);
	 * // => true
	 *
	 * _.isSymbol('abc');
	 * // => false
	 */
	function isSymbol(value) {
	  return typeof value == 'symbol' ||
	    (isObjectLike_1(value) && _baseGetTag(value) == symbolTag);
	}

	var isSymbol_1 = isSymbol;

	/** Used to match property names within property paths. */
	var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
	    reIsPlainProp = /^\w*$/;

	/**
	 * Checks if `value` is a property name and not a property path.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {Object} [object] The object to query keys on.
	 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
	 */
	function isKey(value, object) {
	  if (isArray_1(value)) {
	    return false;
	  }
	  var type = typeof value;
	  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
	      value == null || isSymbol_1(value)) {
	    return true;
	  }
	  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
	    (object != null && value in Object(object));
	}

	var _isKey = isKey;

	/**
	 * Checks if `value` is the
	 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */
	function isObject(value) {
	  var type = typeof value;
	  return value != null && (type == 'object' || type == 'function');
	}

	var isObject_1 = isObject;

	/** `Object#toString` result references. */
	var asyncTag = '[object AsyncFunction]',
	    funcTag = '[object Function]',
	    genTag = '[object GeneratorFunction]',
	    proxyTag = '[object Proxy]';

	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction(value) {
	  if (!isObject_1(value)) {
	    return false;
	  }
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in Safari 9 which returns 'object' for typed arrays and other constructors.
	  var tag = _baseGetTag(value);
	  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
	}

	var isFunction_1 = isFunction;

	/** Used to detect overreaching core-js shims. */
	var coreJsData = _root['__core-js_shared__'];

	var _coreJsData = coreJsData;

	/** Used to detect methods masquerading as native. */
	var maskSrcKey = (function() {
	  var uid = /[^.]+$/.exec(_coreJsData && _coreJsData.keys && _coreJsData.keys.IE_PROTO || '');
	  return uid ? ('Symbol(src)_1.' + uid) : '';
	}());

	/**
	 * Checks if `func` has its source masked.
	 *
	 * @private
	 * @param {Function} func The function to check.
	 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
	 */
	function isMasked(func) {
	  return !!maskSrcKey && (maskSrcKey in func);
	}

	var _isMasked = isMasked;

	/** Used for built-in method references. */
	var funcProto = Function.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;

	/**
	 * Converts `func` to its source code.
	 *
	 * @private
	 * @param {Function} func The function to convert.
	 * @returns {string} Returns the source code.
	 */
	function toSource(func) {
	  if (func != null) {
	    try {
	      return funcToString.call(func);
	    } catch (e) {}
	    try {
	      return (func + '');
	    } catch (e) {}
	  }
	  return '';
	}

	var _toSource = toSource;

	/**
	 * Used to match `RegExp`
	 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
	 */
	var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

	/** Used to detect host constructors (Safari). */
	var reIsHostCtor = /^\[object .+?Constructor\]$/;

	/** Used for built-in method references. */
	var funcProto$1 = Function.prototype,
	    objectProto$3 = Object.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString$1 = funcProto$1.toString;

	/** Used to check objects for own properties. */
	var hasOwnProperty$3 = objectProto$3.hasOwnProperty;

	/** Used to detect if a method is native. */
	var reIsNative = RegExp('^' +
	  funcToString$1.call(hasOwnProperty$3).replace(reRegExpChar, '\\$&')
	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	);

	/**
	 * The base implementation of `_.isNative` without bad shim checks.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a native function,
	 *  else `false`.
	 */
	function baseIsNative(value) {
	  if (!isObject_1(value) || _isMasked(value)) {
	    return false;
	  }
	  var pattern = isFunction_1(value) ? reIsNative : reIsHostCtor;
	  return pattern.test(_toSource(value));
	}

	var _baseIsNative = baseIsNative;

	/**
	 * Gets the value at `key` of `object`.
	 *
	 * @private
	 * @param {Object} [object] The object to query.
	 * @param {string} key The key of the property to get.
	 * @returns {*} Returns the property value.
	 */
	function getValue(object, key) {
	  return object == null ? undefined : object[key];
	}

	var _getValue = getValue;

	/**
	 * Gets the native function at `key` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the method to get.
	 * @returns {*} Returns the function if it's native, else `undefined`.
	 */
	function getNative(object, key) {
	  var value = _getValue(object, key);
	  return _baseIsNative(value) ? value : undefined;
	}

	var _getNative = getNative;

	/* Built-in method references that are verified to be native. */
	var nativeCreate = _getNative(Object, 'create');

	var _nativeCreate = nativeCreate;

	/**
	 * Removes all key-value entries from the hash.
	 *
	 * @private
	 * @name clear
	 * @memberOf Hash
	 */
	function hashClear() {
	  this.__data__ = _nativeCreate ? _nativeCreate(null) : {};
	  this.size = 0;
	}

	var _hashClear = hashClear;

	/**
	 * Removes `key` and its value from the hash.
	 *
	 * @private
	 * @name delete
	 * @memberOf Hash
	 * @param {Object} hash The hash to modify.
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function hashDelete(key) {
	  var result = this.has(key) && delete this.__data__[key];
	  this.size -= result ? 1 : 0;
	  return result;
	}

	var _hashDelete = hashDelete;

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = '__lodash_hash_undefined__';

	/** Used for built-in method references. */
	var objectProto$4 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$4 = objectProto$4.hasOwnProperty;

	/**
	 * Gets the hash value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Hash
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function hashGet(key) {
	  var data = this.__data__;
	  if (_nativeCreate) {
	    var result = data[key];
	    return result === HASH_UNDEFINED ? undefined : result;
	  }
	  return hasOwnProperty$4.call(data, key) ? data[key] : undefined;
	}

	var _hashGet = hashGet;

	/** Used for built-in method references. */
	var objectProto$5 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$5 = objectProto$5.hasOwnProperty;

	/**
	 * Checks if a hash value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Hash
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function hashHas(key) {
	  var data = this.__data__;
	  return _nativeCreate ? (data[key] !== undefined) : hasOwnProperty$5.call(data, key);
	}

	var _hashHas = hashHas;

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

	/**
	 * Sets the hash `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Hash
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the hash instance.
	 */
	function hashSet(key, value) {
	  var data = this.__data__;
	  this.size += this.has(key) ? 0 : 1;
	  data[key] = (_nativeCreate && value === undefined) ? HASH_UNDEFINED$1 : value;
	  return this;
	}

	var _hashSet = hashSet;

	/**
	 * Creates a hash object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Hash(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `Hash`.
	Hash.prototype.clear = _hashClear;
	Hash.prototype['delete'] = _hashDelete;
	Hash.prototype.get = _hashGet;
	Hash.prototype.has = _hashHas;
	Hash.prototype.set = _hashSet;

	var _Hash = Hash;

	/**
	 * Removes all key-value entries from the list cache.
	 *
	 * @private
	 * @name clear
	 * @memberOf ListCache
	 */
	function listCacheClear() {
	  this.__data__ = [];
	  this.size = 0;
	}

	var _listCacheClear = listCacheClear;

	/**
	 * Performs a
	 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * comparison between two values to determine if they are equivalent.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 * var other = { 'a': 1 };
	 *
	 * _.eq(object, object);
	 * // => true
	 *
	 * _.eq(object, other);
	 * // => false
	 *
	 * _.eq('a', 'a');
	 * // => true
	 *
	 * _.eq('a', Object('a'));
	 * // => false
	 *
	 * _.eq(NaN, NaN);
	 * // => true
	 */
	function eq(value, other) {
	  return value === other || (value !== value && other !== other);
	}

	var eq_1 = eq;

	/**
	 * Gets the index at which the `key` is found in `array` of key-value pairs.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} key The key to search for.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function assocIndexOf(array, key) {
	  var length = array.length;
	  while (length--) {
	    if (eq_1(array[length][0], key)) {
	      return length;
	    }
	  }
	  return -1;
	}

	var _assocIndexOf = assocIndexOf;

	/** Used for built-in method references. */
	var arrayProto = Array.prototype;

	/** Built-in value references. */
	var splice = arrayProto.splice;

	/**
	 * Removes `key` and its value from the list cache.
	 *
	 * @private
	 * @name delete
	 * @memberOf ListCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function listCacheDelete(key) {
	  var data = this.__data__,
	      index = _assocIndexOf(data, key);

	  if (index < 0) {
	    return false;
	  }
	  var lastIndex = data.length - 1;
	  if (index == lastIndex) {
	    data.pop();
	  } else {
	    splice.call(data, index, 1);
	  }
	  --this.size;
	  return true;
	}

	var _listCacheDelete = listCacheDelete;

	/**
	 * Gets the list cache value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf ListCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function listCacheGet(key) {
	  var data = this.__data__,
	      index = _assocIndexOf(data, key);

	  return index < 0 ? undefined : data[index][1];
	}

	var _listCacheGet = listCacheGet;

	/**
	 * Checks if a list cache value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf ListCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function listCacheHas(key) {
	  return _assocIndexOf(this.__data__, key) > -1;
	}

	var _listCacheHas = listCacheHas;

	/**
	 * Sets the list cache `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf ListCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the list cache instance.
	 */
	function listCacheSet(key, value) {
	  var data = this.__data__,
	      index = _assocIndexOf(data, key);

	  if (index < 0) {
	    ++this.size;
	    data.push([key, value]);
	  } else {
	    data[index][1] = value;
	  }
	  return this;
	}

	var _listCacheSet = listCacheSet;

	/**
	 * Creates an list cache object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function ListCache(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `ListCache`.
	ListCache.prototype.clear = _listCacheClear;
	ListCache.prototype['delete'] = _listCacheDelete;
	ListCache.prototype.get = _listCacheGet;
	ListCache.prototype.has = _listCacheHas;
	ListCache.prototype.set = _listCacheSet;

	var _ListCache = ListCache;

	/* Built-in method references that are verified to be native. */
	var Map = _getNative(_root, 'Map');

	var _Map = Map;

	/**
	 * Removes all key-value entries from the map.
	 *
	 * @private
	 * @name clear
	 * @memberOf MapCache
	 */
	function mapCacheClear() {
	  this.size = 0;
	  this.__data__ = {
	    'hash': new _Hash,
	    'map': new (_Map || _ListCache),
	    'string': new _Hash
	  };
	}

	var _mapCacheClear = mapCacheClear;

	/**
	 * Checks if `value` is suitable for use as unique object key.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
	 */
	function isKeyable(value) {
	  var type = typeof value;
	  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
	    ? (value !== '__proto__')
	    : (value === null);
	}

	var _isKeyable = isKeyable;

	/**
	 * Gets the data for `map`.
	 *
	 * @private
	 * @param {Object} map The map to query.
	 * @param {string} key The reference key.
	 * @returns {*} Returns the map data.
	 */
	function getMapData(map, key) {
	  var data = map.__data__;
	  return _isKeyable(key)
	    ? data[typeof key == 'string' ? 'string' : 'hash']
	    : data.map;
	}

	var _getMapData = getMapData;

	/**
	 * Removes `key` and its value from the map.
	 *
	 * @private
	 * @name delete
	 * @memberOf MapCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function mapCacheDelete(key) {
	  var result = _getMapData(this, key)['delete'](key);
	  this.size -= result ? 1 : 0;
	  return result;
	}

	var _mapCacheDelete = mapCacheDelete;

	/**
	 * Gets the map value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf MapCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function mapCacheGet(key) {
	  return _getMapData(this, key).get(key);
	}

	var _mapCacheGet = mapCacheGet;

	/**
	 * Checks if a map value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf MapCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function mapCacheHas(key) {
	  return _getMapData(this, key).has(key);
	}

	var _mapCacheHas = mapCacheHas;

	/**
	 * Sets the map `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf MapCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the map cache instance.
	 */
	function mapCacheSet(key, value) {
	  var data = _getMapData(this, key),
	      size = data.size;

	  data.set(key, value);
	  this.size += data.size == size ? 0 : 1;
	  return this;
	}

	var _mapCacheSet = mapCacheSet;

	/**
	 * Creates a map cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function MapCache(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `MapCache`.
	MapCache.prototype.clear = _mapCacheClear;
	MapCache.prototype['delete'] = _mapCacheDelete;
	MapCache.prototype.get = _mapCacheGet;
	MapCache.prototype.has = _mapCacheHas;
	MapCache.prototype.set = _mapCacheSet;

	var _MapCache = MapCache;

	/** Error message constants. */
	var FUNC_ERROR_TEXT = 'Expected a function';

	/**
	 * Creates a function that memoizes the result of `func`. If `resolver` is
	 * provided, it determines the cache key for storing the result based on the
	 * arguments provided to the memoized function. By default, the first argument
	 * provided to the memoized function is used as the map cache key. The `func`
	 * is invoked with the `this` binding of the memoized function.
	 *
	 * **Note:** The cache is exposed as the `cache` property on the memoized
	 * function. Its creation may be customized by replacing the `_.memoize.Cache`
	 * constructor with one whose instances implement the
	 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
	 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Function
	 * @param {Function} func The function to have its output memoized.
	 * @param {Function} [resolver] The function to resolve the cache key.
	 * @returns {Function} Returns the new memoized function.
	 * @example
	 *
	 * var object = { 'a': 1, 'b': 2 };
	 * var other = { 'c': 3, 'd': 4 };
	 *
	 * var values = _.memoize(_.values);
	 * values(object);
	 * // => [1, 2]
	 *
	 * values(other);
	 * // => [3, 4]
	 *
	 * object.a = 2;
	 * values(object);
	 * // => [1, 2]
	 *
	 * // Modify the result cache.
	 * values.cache.set(object, ['a', 'b']);
	 * values(object);
	 * // => ['a', 'b']
	 *
	 * // Replace `_.memoize.Cache`.
	 * _.memoize.Cache = WeakMap;
	 */
	function memoize(func, resolver) {
	  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
	    throw new TypeError(FUNC_ERROR_TEXT);
	  }
	  var memoized = function() {
	    var args = arguments,
	        key = resolver ? resolver.apply(this, args) : args[0],
	        cache = memoized.cache;

	    if (cache.has(key)) {
	      return cache.get(key);
	    }
	    var result = func.apply(this, args);
	    memoized.cache = cache.set(key, result) || cache;
	    return result;
	  };
	  memoized.cache = new (memoize.Cache || _MapCache);
	  return memoized;
	}

	// Expose `MapCache`.
	memoize.Cache = _MapCache;

	var memoize_1 = memoize;

	/** Used as the maximum memoize cache size. */
	var MAX_MEMOIZE_SIZE = 500;

	/**
	 * A specialized version of `_.memoize` which clears the memoized function's
	 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
	 *
	 * @private
	 * @param {Function} func The function to have its output memoized.
	 * @returns {Function} Returns the new memoized function.
	 */
	function memoizeCapped(func) {
	  var result = memoize_1(func, function(key) {
	    if (cache.size === MAX_MEMOIZE_SIZE) {
	      cache.clear();
	    }
	    return key;
	  });

	  var cache = result.cache;
	  return result;
	}

	var _memoizeCapped = memoizeCapped;

	/** Used to match property names within property paths. */
	var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

	/** Used to match backslashes in property paths. */
	var reEscapeChar = /\\(\\)?/g;

	/**
	 * Converts `string` to a property path array.
	 *
	 * @private
	 * @param {string} string The string to convert.
	 * @returns {Array} Returns the property path array.
	 */
	var stringToPath = _memoizeCapped(function(string) {
	  var result = [];
	  if (string.charCodeAt(0) === 46 /* . */) {
	    result.push('');
	  }
	  string.replace(rePropName, function(match, number, quote, subString) {
	    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
	  });
	  return result;
	});

	var _stringToPath = stringToPath;

	/**
	 * A specialized version of `_.map` for arrays without support for iteratee
	 * shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the new mapped array.
	 */
	function arrayMap(array, iteratee) {
	  var index = -1,
	      length = array == null ? 0 : array.length,
	      result = Array(length);

	  while (++index < length) {
	    result[index] = iteratee(array[index], index, array);
	  }
	  return result;
	}

	var _arrayMap = arrayMap;

	/** Used as references for various `Number` constants. */
	var INFINITY = 1 / 0;

	/** Used to convert symbols to primitives and strings. */
	var symbolProto = _Symbol ? _Symbol.prototype : undefined,
	    symbolToString = symbolProto ? symbolProto.toString : undefined;

	/**
	 * The base implementation of `_.toString` which doesn't convert nullish
	 * values to empty strings.
	 *
	 * @private
	 * @param {*} value The value to process.
	 * @returns {string} Returns the string.
	 */
	function baseToString(value) {
	  // Exit early for strings to avoid a performance hit in some environments.
	  if (typeof value == 'string') {
	    return value;
	  }
	  if (isArray_1(value)) {
	    // Recursively convert values (susceptible to call stack limits).
	    return _arrayMap(value, baseToString) + '';
	  }
	  if (isSymbol_1(value)) {
	    return symbolToString ? symbolToString.call(value) : '';
	  }
	  var result = (value + '');
	  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
	}

	var _baseToString = baseToString;

	/**
	 * Converts `value` to a string. An empty string is returned for `null`
	 * and `undefined` values. The sign of `-0` is preserved.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 * @example
	 *
	 * _.toString(null);
	 * // => ''
	 *
	 * _.toString(-0);
	 * // => '-0'
	 *
	 * _.toString([1, 2, 3]);
	 * // => '1,2,3'
	 */
	function toString$1(value) {
	  return value == null ? '' : _baseToString(value);
	}

	var toString_1 = toString$1;

	/**
	 * Casts `value` to a path array if it's not one.
	 *
	 * @private
	 * @param {*} value The value to inspect.
	 * @param {Object} [object] The object to query keys on.
	 * @returns {Array} Returns the cast property path array.
	 */
	function castPath(value, object) {
	  if (isArray_1(value)) {
	    return value;
	  }
	  return _isKey(value, object) ? [value] : _stringToPath(toString_1(value));
	}

	var _castPath = castPath;

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]';

	/**
	 * The base implementation of `_.isArguments`.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 */
	function baseIsArguments(value) {
	  return isObjectLike_1(value) && _baseGetTag(value) == argsTag;
	}

	var _baseIsArguments = baseIsArguments;

	/** Used for built-in method references. */
	var objectProto$6 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$6 = objectProto$6.hasOwnProperty;

	/** Built-in value references. */
	var propertyIsEnumerable = objectProto$6.propertyIsEnumerable;

	/**
	 * Checks if `value` is likely an `arguments` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArguments(function() { return arguments; }());
	 * // => true
	 *
	 * _.isArguments([1, 2, 3]);
	 * // => false
	 */
	var isArguments = _baseIsArguments(function() { return arguments; }()) ? _baseIsArguments : function(value) {
	  return isObjectLike_1(value) && hasOwnProperty$6.call(value, 'callee') &&
	    !propertyIsEnumerable.call(value, 'callee');
	};

	var isArguments_1 = isArguments;

	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER = 9007199254740991;

	/** Used to detect unsigned integer values. */
	var reIsUint = /^(?:0|[1-9]\d*)$/;

	/**
	 * Checks if `value` is a valid array-like index.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	 */
	function isIndex(value, length) {
	  var type = typeof value;
	  length = length == null ? MAX_SAFE_INTEGER : length;

	  return !!length &&
	    (type == 'number' ||
	      (type != 'symbol' && reIsUint.test(value))) &&
	        (value > -1 && value % 1 == 0 && value < length);
	}

	var _isIndex = isIndex;

	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER$1 = 9007199254740991;

	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This method is loosely based on
	 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 * @example
	 *
	 * _.isLength(3);
	 * // => true
	 *
	 * _.isLength(Number.MIN_VALUE);
	 * // => false
	 *
	 * _.isLength(Infinity);
	 * // => false
	 *
	 * _.isLength('3');
	 * // => false
	 */
	function isLength(value) {
	  return typeof value == 'number' &&
	    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$1;
	}

	var isLength_1 = isLength;

	/** Used as references for various `Number` constants. */
	var INFINITY$1 = 1 / 0;

	/**
	 * Converts `value` to a string key if it's not a string or symbol.
	 *
	 * @private
	 * @param {*} value The value to inspect.
	 * @returns {string|symbol} Returns the key.
	 */
	function toKey(value) {
	  if (typeof value == 'string' || isSymbol_1(value)) {
	    return value;
	  }
	  var result = (value + '');
	  return (result == '0' && (1 / value) == -INFINITY$1) ? '-0' : result;
	}

	var _toKey = toKey;

	/**
	 * Checks if `path` exists on `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path to check.
	 * @param {Function} hasFunc The function to check properties.
	 * @returns {boolean} Returns `true` if `path` exists, else `false`.
	 */
	function hasPath(object, path, hasFunc) {
	  path = _castPath(path, object);

	  var index = -1,
	      length = path.length,
	      result = false;

	  while (++index < length) {
	    var key = _toKey(path[index]);
	    if (!(result = object != null && hasFunc(object, key))) {
	      break;
	    }
	    object = object[key];
	  }
	  if (result || ++index != length) {
	    return result;
	  }
	  length = object == null ? 0 : object.length;
	  return !!length && isLength_1(length) && _isIndex(key, length) &&
	    (isArray_1(object) || isArguments_1(object));
	}

	var _hasPath = hasPath;

	/**
	 * Checks if `path` is a direct property of `object`.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path to check.
	 * @returns {boolean} Returns `true` if `path` exists, else `false`.
	 * @example
	 *
	 * var object = { 'a': { 'b': 2 } };
	 * var other = _.create({ 'a': _.create({ 'b': 2 }) });
	 *
	 * _.has(object, 'a');
	 * // => true
	 *
	 * _.has(object, 'a.b');
	 * // => true
	 *
	 * _.has(object, ['a', 'b']);
	 * // => true
	 *
	 * _.has(other, 'a');
	 * // => false
	 */
	function has(object, path) {
	  return object != null && _hasPath(object, path, _baseHas);
	}

	var has_1 = has;

	/**
	 * The base implementation of `_.get` without support for default values.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path of the property to get.
	 * @returns {*} Returns the resolved value.
	 */
	function baseGet(object, path) {
	  path = _castPath(path, object);

	  var index = 0,
	      length = path.length;

	  while (object != null && index < length) {
	    object = object[_toKey(path[index++])];
	  }
	  return (index && index == length) ? object : undefined;
	}

	var _baseGet = baseGet;

	/**
	 * Gets the value at `path` of `object`. If the resolved value is
	 * `undefined`, the `defaultValue` is returned in its place.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.7.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path of the property to get.
	 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
	 * @returns {*} Returns the resolved value.
	 * @example
	 *
	 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	 *
	 * _.get(object, 'a[0].b.c');
	 * // => 3
	 *
	 * _.get(object, ['a', '0', 'b', 'c']);
	 * // => 3
	 *
	 * _.get(object, 'a.b.c', 'default');
	 * // => 'default'
	 */
	function get(object, path, defaultValue) {
	  var result = object == null ? undefined : _baseGet(object, path);
	  return result === undefined ? defaultValue : result;
	}

	var get_1 = get;

	/**
	 *
	 *
	 * @author Jerry Bendy <jerry@icewingcc.com>
	 * @licence MIT
	 *
	 */

	(function(self) {

	    var nativeURLSearchParams = (self.URLSearchParams && self.URLSearchParams.prototype.get) ? self.URLSearchParams : null,
	        isSupportObjectConstructor = nativeURLSearchParams && (new nativeURLSearchParams({a: 1})).toString() === 'a=1',
	        // There is a bug in safari 10.1 (and earlier) that incorrectly decodes `%2B` as an empty space and not a plus.
	        decodesPlusesCorrectly = nativeURLSearchParams && (new nativeURLSearchParams('s=%2B').get('s') === '+'),
	        __URLSearchParams__ = "__URLSearchParams__",
	        // Fix bug in Edge which cannot encode ' &' correctly
	        encodesAmpersandsCorrectly = nativeURLSearchParams ? (function() {
	            var ampersandTest = new nativeURLSearchParams();
	            ampersandTest.append('s', ' &');
	            return ampersandTest.toString() === 's=+%26';
	        })() : true,
	        prototype = URLSearchParamsPolyfill.prototype,
	        iterable = !!(self.Symbol && self.Symbol.iterator);

	    if (nativeURLSearchParams && isSupportObjectConstructor && decodesPlusesCorrectly && encodesAmpersandsCorrectly) {
	        return;
	    }


	    /**
	     * Make a URLSearchParams instance
	     *
	     * @param {object|string|URLSearchParams} search
	     * @constructor
	     */
	    function URLSearchParamsPolyfill(search) {
	        search = search || "";

	        // support construct object with another URLSearchParams instance
	        if (search instanceof URLSearchParams || search instanceof URLSearchParamsPolyfill) {
	            search = search.toString();
	        }
	        this [__URLSearchParams__] = parseToDict(search);
	    }


	    /**
	     * Appends a specified key/value pair as a new search parameter.
	     *
	     * @param {string} name
	     * @param {string} value
	     */
	    prototype.append = function(name, value) {
	        appendTo(this [__URLSearchParams__], name, value);
	    };

	    /**
	     * Deletes the given search parameter, and its associated value,
	     * from the list of all search parameters.
	     *
	     * @param {string} name
	     */
	    prototype['delete'] = function(name) {
	        delete this [__URLSearchParams__] [name];
	    };

	    /**
	     * Returns the first value associated to the given search parameter.
	     *
	     * @param {string} name
	     * @returns {string|null}
	     */
	    prototype.get = function(name) {
	        var dict = this [__URLSearchParams__];
	        return name in dict ? dict[name][0] : null;
	    };

	    /**
	     * Returns all the values association with a given search parameter.
	     *
	     * @param {string} name
	     * @returns {Array}
	     */
	    prototype.getAll = function(name) {
	        var dict = this [__URLSearchParams__];
	        return name in dict ? dict [name].slice(0) : [];
	    };

	    /**
	     * Returns a Boolean indicating if such a search parameter exists.
	     *
	     * @param {string} name
	     * @returns {boolean}
	     */
	    prototype.has = function(name) {
	        return name in this [__URLSearchParams__];
	    };

	    /**
	     * Sets the value associated to a given search parameter to
	     * the given value. If there were several values, delete the
	     * others.
	     *
	     * @param {string} name
	     * @param {string} value
	     */
	    prototype.set = function set(name, value) {
	        this [__URLSearchParams__][name] = ['' + value];
	    };

	    /**
	     * Returns a string containg a query string suitable for use in a URL.
	     *
	     * @returns {string}
	     */
	    prototype.toString = function() {
	        var dict = this[__URLSearchParams__], query = [], i, key, name, value;
	        for (key in dict) {
	            name = encode(key);
	            for (i = 0, value = dict[key]; i < value.length; i++) {
	                query.push(name + '=' + encode(value[i]));
	            }
	        }
	        return query.join('&');
	    };

	    // There is a bug in Safari 10.1 and `Proxy`ing it is not enough.
	    var forSureUsePolyfill = !decodesPlusesCorrectly;
	    var useProxy = (!forSureUsePolyfill && nativeURLSearchParams && !isSupportObjectConstructor && self.Proxy);
	    /*
	     * Apply polifill to global object and append other prototype into it
	     */
	    Object.defineProperty(self, 'URLSearchParams', {
	        value: (useProxy ?
	            // Safari 10.0 doesn't support Proxy, so it won't extend URLSearchParams on safari 10.0
	            new Proxy(nativeURLSearchParams, {
	                construct: function(target, args) {
	                    return new target((new URLSearchParamsPolyfill(args[0]).toString()));
	                }
	            }) :
	            URLSearchParamsPolyfill)
	    });

	    var USPProto = self.URLSearchParams.prototype;

	    USPProto.polyfill = true;

	    /**
	     *
	     * @param {function} callback
	     * @param {object} thisArg
	     */
	    USPProto.forEach = USPProto.forEach || function(callback, thisArg) {
	        var dict = parseToDict(this.toString());
	        Object.getOwnPropertyNames(dict).forEach(function(name) {
	            dict[name].forEach(function(value) {
	                callback.call(thisArg, value, name, this);
	            }, this);
	        }, this);
	    };

	    /**
	     * Sort all name-value pairs
	     */
	    USPProto.sort = USPProto.sort || function() {
	        var dict = parseToDict(this.toString()), keys = [], k, i, j;
	        for (k in dict) {
	            keys.push(k);
	        }
	        keys.sort();

	        for (i = 0; i < keys.length; i++) {
	            this['delete'](keys[i]);
	        }
	        for (i = 0; i < keys.length; i++) {
	            var key = keys[i], values = dict[key];
	            for (j = 0; j < values.length; j++) {
	                this.append(key, values[j]);
	            }
	        }
	    };

	    /**
	     * Returns an iterator allowing to go through all keys of
	     * the key/value pairs contained in this object.
	     *
	     * @returns {function}
	     */
	    USPProto.keys = USPProto.keys || function() {
	        var items = [];
	        this.forEach(function(item, name) {
	            items.push(name);
	        });
	        return makeIterator(items);
	    };

	    /**
	     * Returns an iterator allowing to go through all values of
	     * the key/value pairs contained in this object.
	     *
	     * @returns {function}
	     */
	    USPProto.values = USPProto.values || function() {
	        var items = [];
	        this.forEach(function(item) {
	            items.push(item);
	        });
	        return makeIterator(items);
	    };

	    /**
	     * Returns an iterator allowing to go through all key/value
	     * pairs contained in this object.
	     *
	     * @returns {function}
	     */
	    USPProto.entries = USPProto.entries || function() {
	        var items = [];
	        this.forEach(function(item, name) {
	            items.push([name, item]);
	        });
	        return makeIterator(items);
	    };


	    if (iterable) {
	        USPProto[self.Symbol.iterator] = USPProto[self.Symbol.iterator] || USPProto.entries;
	    }


	    function encode(str) {
	        var replace = {
	            '!': '%21',
	            "'": '%27',
	            '(': '%28',
	            ')': '%29',
	            '~': '%7E',
	            '%20': '+',
	            '%00': '\x00'
	        };
	        return encodeURIComponent(str).replace(/[!'\(\)~]|%20|%00/g, function(match) {
	            return replace[match];
	        });
	    }

	    function decode(str) {
	        return str
	            .replace(/[ +]/g, '%20')
	            .replace(/(%[a-f0-9]{2})+/ig, function(match) {
	                return decodeURIComponent(match);
	            });
	    }

	    function makeIterator(arr) {
	        var iterator = {
	            next: function() {
	                var value = arr.shift();
	                return {done: value === undefined, value: value};
	            }
	        };

	        if (iterable) {
	            iterator[self.Symbol.iterator] = function() {
	                return iterator;
	            };
	        }

	        return iterator;
	    }

	    function parseToDict(search) {
	        var dict = {};

	        if (typeof search === "object") {
	            // if `search` is an array, treat it as a sequence
	            if (isArray(search)) {
	                for (var i = 0; i < search.length; i++) {
	                    var item = search[i];
	                    if (isArray(item) && item.length === 2) {
	                        appendTo(dict, item[0], item[1]);
	                    } else {
	                        throw new TypeError("Failed to construct 'URLSearchParams': Sequence initializer must only contain pair elements");
	                    }
	                }

	            } else {
	                for (var key in search) {
	                    if (search.hasOwnProperty(key)) {
	                        appendTo(dict, key, search[key]);
	                    }
	                }
	            }

	        } else {
	            // remove first '?'
	            if (search.indexOf("?") === 0) {
	                search = search.slice(1);
	            }

	            var pairs = search.split("&");
	            for (var j = 0; j < pairs.length; j++) {
	                var value = pairs [j],
	                    index = value.indexOf('=');

	                if (-1 < index) {
	                    appendTo(dict, decode(value.slice(0, index)), decode(value.slice(index + 1)));

	                } else {
	                    if (value) {
	                        appendTo(dict, decode(value), '');
	                    }
	                }
	            }
	        }

	        return dict;
	    }

	    function appendTo(dict, name, value) {
	        var val = typeof value === 'string' ? value : (
	            value !== null && value !== undefined && typeof value.toString === 'function' ? value.toString() : JSON.stringify(value)
	        );

	        if (name in dict) {
	            dict[name].push(val);
	        } else {
	            dict[name] = [val];
	        }
	    }

	    function isArray(val) {
	        return !!val && '[object Array]' === Object.prototype.toString.call(val);
	    }

	})(typeof commonjsGlobal !== 'undefined' ? commonjsGlobal : (typeof window !== 'undefined' ? window : commonjsGlobal));

	var addressToolsMixin = function addressToolsMixin(Base) {
	  var _temp;

	  return _temp =
	  /*#__PURE__*/
	  function (_Base) {
	    inherits(_temp, _Base);

	    function _temp($element, _options) {
	      var _this;

	      classCallCheck(this, _temp);

	      _this = possibleConstructorReturn(this, getPrototypeOf(_temp).call(this, $element, _options));

	      defineProperty(assertThisInitialized(assertThisInitialized(_this)), "initRequestSequence", function () {
	        _this.seq = 0;
	        _this.lastSeq = 0;
	      });

	      defineProperty(assertThisInitialized(assertThisInitialized(_this)), "beforeSend", function (jqXHR, options) {
	        var urlParams = new URLSearchParams(options.url);
	        jqXHR.lookup = urlParams.get('lookup');
	        jqXHR.seq = _this.seq;
	        _this.seq++;
	        $(document).trigger('afd:pceLookupStarted', [jqXHR, urlParams.get('lookup')]);
	      });

	      defineProperty(assertThisInitialized(assertThisInitialized(_this)), "requestCallback", function (data, textStatus, jqXHR) {
	        $(document).trigger('afd:pceLookupComplete', [data, jqXHR, jqXHR.lookup]);
	      });

	      defineProperty(assertThisInitialized(assertThisInitialized(_this)), "refreshUniqeID", function () {
	        _this.uniqueID = _this.getUniqueID();
	      });

	      defineProperty(assertThisInitialized(assertThisInitialized(_this)), "getUniqueID", function () {
	        return Math.floor(Math.random() * 90000) + 10000;
	      });

	      defineProperty(assertThisInitialized(assertThisInitialized(_this)), "setFields", function () {
	        var controlType = _this.options[_this.controlType].linkedControl ? _this.options[_this.controlType].linkedControl : _this.controlType;
	        _this.$typeaheadFieldandLabel = get_1(_this.options, controlType + '.containerOnlyContainsControl', false) ? _this.$typeaheadFieldandLabel = $('.afd-typeahead-container') : _this.$typeaheadFieldandLabel = $('.afd-typeahead-container label, .afd-typeahead-field');
	        _this.$typeAheadInput = $('.afd-typeahead-container input');
	        _this.$resultFields = $('[data-afd-result]');
	        _this.$typeaheadContainer = $('.afd-typeahead-container');
	        _this.$manualInputButton = has_1(_this.options, controlType + '.manualInputButtonIdentifier') ? $(_this.options[controlType].manualInputButtonIdentifier) : $('.afd-manual-input-button');
	        _this.$manualInputSearchButton = has_1(_this.options, controlType + '.manualInputSearchButtonIdentifier') ? $(_this.options[controlType].manualInputSearchButtonIdentifier) : $('.afd-manual-input-search-button');
	        _this.$searchAgainButton = has_1(_this.options, controlType + '.searchAgainButtonIdentifier') ? $(_this.options[controlType].searchAgainButtonIdentifier) : $('.afd-search-again');
	        _this.$fieldSets = $(_this.options[controlType].fieldSets.toString());
	        _this.$customCountryField = _this.options.country.customCountryControl ? $(_this.options.country.customCountryControl) : null;
	        _this.containers = _this.options[controlType].containers.toString();
	        _this.multiForms = _this.containers.length > 0; // If a non-afd country control is supplied then listen for changes and fire change event

	        if (_this.$customCountryField) {
	          if (_this.$customCountryField.length === 0) {
	            throw 'Custom country field selector ' + _this.options.country.customCountryControl + ' supplied, but no matching control found.';
	          }

	          _this.$customCountryField.off('change.afd', _this.onCustomCountryChange).on('change.afd', _this.onCustomCountryChange);
	        }
	      });

	      defineProperty(assertThisInitialized(assertThisInitialized(_this)), "initFields", function () {
	        var controlType = _this.controlType;

	        _this.handleMultiForms();

	        _this.$typeaheadFieldandLabel.show();

	        var fieldSets = _this.options[controlType].fieldSets; // show or hide the manual input button
	        // hide or show controls based on the country - also returns country

	        var country = _this.getInitialCountry(); // if set to hide result fields beforehand


	        if (_this.options[controlType].beforeHideResults) {
	          _this.$manualInputSearchButton.hide();

	          _this.hideResultFields(country);

	          if (fieldSets.length > 0) {
	            for (var i = 0; i < fieldSets.length; i++) {
	              $(fieldSets[i]).hide();
	            }
	          }
	        } else {
	          _this.showResultFields();

	          if (fieldSets.length > 0) {
	            for (var _i = 0; _i < fieldSets.length; _i++) {
	              $(fieldSets[_i]).show();
	            }
	          }
	        } // If option is set, show fields of not empty regardless of what is set on beforeHideResults
	        // this setting is useful when you are editing a previous address and you want to still show the previous values


	        if (_this.options[controlType].notEmptyShowResults) {
	          var container = _this.$element.closest(_this.containers);

	          var allEmpty = !_this.multiForms ? $('[data-afd-result]:empty').filter(function () {
	            return $.trim($(this).val()).length !== 0;
	          }).length === 0 : container.find('[data-afd-result]:empty').filter(function () {
	            return $.trim($(this).val()).length !== 0;
	          }).length === 0;

	          if (!allEmpty) {
	            _this.showResultFields();

	            _this.$fieldSets.show();

	            _this.$manualInputButton.hide();
	          }
	        }
	      });

	      defineProperty(assertThisInitialized(assertThisInitialized(_this)), "handleMultiForms", function () {
	        // this function handles the fact that their may be multiple forms on a single page
	        // if a `linkedControl` is specified (reverseGeocode), then this sets all the fields in relation to the linked control instead
	        var controlType = _this.options[_this.controlType].linkedControl ? _this.options[_this.controlType].linkedControl : _this.controlType; // if the containers array lists containers, we need to make sure that only fields in the containers are initialised

	        var container = _this.$element.closest(_this.containers);

	        if (_this.multiForms) {
	          _this.$manualInputButton = has_1(_this.options, controlType + '.manualInputButtonIdentifier') ? container.find(_this.options[controlType].manualInputButtonIdentifier) : container.find('.afd-manual-input-button');
	          _this.$manualInputSearchButton = has_1(_this.options, controlType + '.manualInputSearchButtonIdentifier') ? container.find(_this.options[controlType].manualInputSearchButtonIdentifier) : container.find('.afd-manual-input-search-button');
	          _this.$searchAgainButton = has_1(_this.options, controlType + '.searchAgainButtonIdentifier') ? container.find(_this.options[controlType].searchAgainButtonIdentifier) : container.find('.afd-search-again');
	          _this.$resultFields = container.find('[data-afd-result]');
	          _this.$typeaheadFieldandLabel = get_1(_this.options, controlType + '.containerOnlyContainsControl', false) ? container.find('.afd-typeahead-container') : container.find('.afd-typeahead-container > label, .afd-typeahead-field');
	          _this.$typeaheadContainer = container.find('.afd-typeahead-container');
	          _this.$customCountryField = _this.options.country.customCountryControl ? container.find(_this.options.country.customCountryControl) : null;
	          _this.$fieldSets = container.find(_this.options[controlType].fieldSets.toString()); //console.log(this.$typeaheadFieldandLabel);
	        }
	      });

	      defineProperty(assertThisInitialized(assertThisInitialized(_this)), "addressLookup", function (lookup) {
	        var controlType = _this.controlType;

	        var requestOptions = _this.setupParams({
	          data: 'address',
	          task: 'fastfindv4',
	          fields: _this.options[controlType].postcodeFirst ? 'list' : 'fflist',
	          uniqueid: _this.uniqueID,
	          lookup: lookup,
	          allpc: '1'
	        }); // for afd website


	        if (_this.options.afdc === 1) {
	          requestOptions.data.afdc = 1;
	        }

	        return $.ajax(requestOptions);
	      });

	      defineProperty(assertThisInitialized(assertThisInitialized(_this)), "addressRetrieve", function (key) {
	        var requestOptions = _this.setupParams({
	          key: key,
	          data: 'address',
	          task: 'retrieve',
	          fields: _this.options[_this.controlType].retrieveFields
	        });

	        if (_this.options.afdc === 1) {
	          requestOptions.data.afdc = 1;
	        }

	        return $.ajax(requestOptions);
	      });

	      defineProperty(assertThisInitialized(assertThisInitialized(_this)), "reverseGeocodeLookup", function (coords) {
	        var controlType = _this.controlType;

	        var requestOptions = _this.setupParams({
	          data: 'address',
	          task: 'nearest',
	          fields: _this.options[controlType].postcodeFirst ? 'list' : 'fflist',
	          uniqueid: _this.uniqueID,
	          longitude: coords.longitude,
	          latitude: coords.latitude,
	          allpc: '1'
	        }); // for afd website


	        if (_this.options.afdc === 1) {
	          requestOptions.data.afdc = 1;
	        }

	        return $.ajax(requestOptions);
	      });

	      defineProperty(assertThisInitialized(assertThisInitialized(_this)), "handleAddressRetrieve", function (data) {
	        var controlType = _this.options[_this.controlType].linkedControl ? _this.options[_this.controlType].linkedControl : _this.controlType;

	        if (typeof data.Item === 'undefined') {
	          return;
	        }

	        var _data$Item = slicedToArray(data.Item, 1);

	        _this.result = _data$Item[0];
	        $(document).trigger('afd:pceRetrieveComplete', [_this.result]); // hide the manual input after search completed

	        _this.$manualInputButton.hide(); // Clear the typeahead if option set


	        if (_this.options[controlType].afterClearTypeahead) {
	          _this.$typeAheadInput.val('');
	        } // Hide typeahed if option set


	        if (_this.options[controlType].afterHideTypeahead) {
	          _this.$typeaheadFieldandLabel.hide(); // Show search again if set


	          if (_this.options[controlType].searchAgain) {
	            _this.$searchAgainButton.show();
	          }
	        } // Hide lookup button if option set


	        if (_this.options[controlType].afterHideLookupButton) {
	          _this.$lookupButton.hide(); // Show search again if set


	          if (_this.options[controlType].searchAgain) {
	            _this.$searchAgainButton.show();
	          }
	        }

	        _this.$fieldSets.show();

	        if (_this.$resultFields.length < 1) {
	          return;
	        }

	        _this.$resultFields.each(_this.populateResult);

	        _this.$typeAheadInput.blur();
	      });

	      defineProperty(assertThisInitialized(assertThisInitialized(_this)), "populateResult", function (index) {
	        var $el = $(_this.$resultFields[index]);
	        var fieldName = $el.data('afd-result'); // this is for linking geoloaction with either lookup or typeahead

	        var controlType = _this.options[_this.controlType].linkedControl ? _this.options[_this.controlType].linkedControl : _this.controlType; // If a region mapping function is supplied, deal with region fields as dropdown

	        var regionFields = ['Region', 'State', 'AbbreviatedOptionalCounty', 'AbbreviatedPostalCounty', 'AdministrativeCounty', 'PostalCounty', 'TraditionalCounty'];

	        if (regionFields.indexOf(fieldName) > -1 && _this.options[controlType].regionMap) {
	          if (!$el.is('select')) {
	            throw '<' + $el.prop('tagName').toLowerCase() + '> is not a valid tag for `[data-afd-result="' + fieldName + '"]`, when regionMap is set.  This should be <select>';
	          }

	          var regionAttribute = _this.options[controlType].regionAttribute;
	          var afdResult = _this.result[fieldName];
	          var mappedResult = _this.options[controlType].regionMap[afdResult];
	          var optionValue = $el.find('[' + regionAttribute + '="' + mappedResult + '"]').val();
	          $el.val(optionValue);
	          return;
	        } // if pushup option is turned off, just fill out the form


	        if (!_this.options[controlType].pushUp) {
	          $el.val(_this.result[fieldName]); // if pushup is supplied as an array
	        } else if (Array.isArray(_this.options[controlType].pushUp)) {
	          _this.handlePushUp(_this.options[controlType].pushUp, fieldName, $el); // for anything else use default pushup options

	        } else {
	          _this.handlePushUp(['Property', 'Street', 'Locality'], fieldName, $el);
	        } // logic for hiding empty fields


	        if (!_this.options[controlType].hideEmpties || $el.val() && $el.val().length > 0) {
	          if (_this.options[controlType].parentClass) {
	            $el.closest('.' + _this.options[controlType].parentClass).show();
	          } else {
	            $el.show();
	          }
	        } else {
	          if (_this.options[controlType].parentClass) {
	            $el.closest('.' + _this.options[controlType].parentClass).hide();
	          } else {
	            $el.hide();
	          }
	        }

	        _this.$fieldSets.show(); // manually triggering keyup on the field, without this some validators still think the field is empty


	        $el.keyup();
	        $(document).trigger('afd:populateResultsComplete');
	      });

	      defineProperty(assertThisInitialized(assertThisInitialized(_this)), "populateResultsList", function () {
	        var itemTag = _this.$resultList.prop('tagName') === 'SELECT' ? 'option' : 'li';

	        _this.$resultList.empty();

	        if (itemTag === 'option' && typeof _this.$resultList.attr('multiple') === 'undefined') {
	          _this.$resultList.append('<option value="' + null + '">' + _this.options.lookup.selectAddressText + '</option>');
	        }

	        for (var i = 0; i < _this.results.length; i++) {
	          var result = _this.results[i];

	          _this.$resultList.append('<' + itemTag + ' value="' + result.Key + '">' + result.List + '</' + itemTag + '>');
	        } // Special event handling required if $resultList is <ul>


	        if (itemTag === 'li') {
	          _this.$resultListResults = _this.$resultList.children('li');

	          _this.eventHandler(_this.$resultListResults, 'click', _this.onResultListItemClick);
	        }

	        _this.$resultList.show().closest('.afd-form-control').show();

	        _this.$resultList.focus();
	      });

	      defineProperty(assertThisInitialized(assertThisInitialized(_this)), "onResultListItemClick", function (e) {
	        _this.selectResult(e);
	      });

	      defineProperty(assertThisInitialized(assertThisInitialized(_this)), "onKeyDownResult", function (e) {
	        var keycode = e.keyCode ? e.keyCode : e.which;

	        if (keycode === 13) {
	          e.preventDefault();
	        }

	        if ([38, 40].indexOf(keycode) > -1) {
	          _this.blockChange = true;
	        }
	      });

	      defineProperty(assertThisInitialized(assertThisInitialized(_this)), "onKeyUpResult", function (e) {
	        var keycode = e.keyCode ? e.keyCode : e.which;

	        if (keycode === 13) {
	          _this.selectResult(e);
	        }
	      });

	      defineProperty(assertThisInitialized(assertThisInitialized(_this)), "onChangeResult", function (e) {
	        if (!_this.blockChange) {
	          _this.selectResult(e);
	        }

	        _this.blockChange = false;
	      });

	      defineProperty(assertThisInitialized(assertThisInitialized(_this)), "selectResult", function (e) {
	        if (_this.options[_this.controlType].afterRetrieveHideResultsList) {
	          _this.hideResultsElement();
	        }

	        _this.addressRetrieve(e.target.value).then(function (data) {
	          _this.handleAddressRetrieve(data);
	        }).fail(function (err) {
	          throw err;
	        });
	      });

	      defineProperty(assertThisInitialized(assertThisInitialized(_this)), "hideResultsElement", function () {
	        _this.$resultList.closest('.afd-form-control').hide();
	      });

	      defineProperty(assertThisInitialized(assertThisInitialized(_this)), "hideResultFields", function (country) {
	        var controlType = _this.controlType; // only do this if the current control is visible - needed if both lookup and typeahead are on same form

	        var controlRestricted = _this.options[controlType].showForCountries.length > 0 || _this.options[controlType].hideForCountries.length > 0;
	        var controlVisible = !controlRestricted || _this.options[controlType].showForCountries.length > 0 && _this.options[controlType].showForCountries.indexOf(country) > -1 || _this.options[controlType].hideForCountries.length > 0 && _this.options[controlType].hideForCountries.indexOf(country) === -1;

	        if (controlVisible) {
	          // parentClass is for input containers which may include labels/validation etc
	          if (_this.options[controlType].parentClass) {
	            _this.$resultFields.closest('.' + _this.options[controlType].parentClass).hide();
	          } else {
	            _this.$resultFields.hide();
	          }

	          _this.$fieldSets.hide(); // only lookup


	          var showPostcode = get_1(_this.options, controlType + '.postcodeIsLookup', false);

	          if (showPostcode) {
	            if (_this.options[controlType].parentClass) {
	              $('[data-afd-result="Postcode"]').closest('.' + _this.options[controlType].parentClass).show();
	            } else {
	              $('[data-afd-result="Postcode"]').show();
	            }
	          }
	        }
	      });

	      defineProperty(assertThisInitialized(assertThisInitialized(_this)), "showResultFields", function () {
	        var controlType = _this.controlType; // parentClass is for input containers whcih may include labels/validation etc

	        if (_this.options[controlType].parentClass) {
	          _this.$resultFields.closest('.' + _this.options[controlType].parentClass).show();
	        } else {
	          _this.$resultFields.show();
	        }

	        _this.$fieldSets.show();
	      });

	      defineProperty(assertThisInitialized(assertThisInitialized(_this)), "fieldEmpty", function (field) {
	        return typeof _this.result[field] !== 'undefined' && _this.result[field].length === 0;
	      });

	      defineProperty(assertThisInitialized(assertThisInitialized(_this)), "onAfdSearchAgainButtonClick", function () {
	        var controlType = _this.controlType;

	        _this.$resultFields.val('');

	        _this.$searchAgainButton.hide();

	        if (controlType === 'typeahead') {
	          _this.$typeaheadFieldandLabel.show();
	        } else if (controlType === 'lookup') {
	          _this.$lookupButton.show();

	          _this.$lookupField.focus();
	        }

	        if (_this.options[controlType].beforeHideResults) {
	          _this.$manualInputButton.show();

	          _this.hideResultFields(_this.country);

	          _this.$fieldSets.hide();
	        } else {
	          _this.$manualInputButton.hide();

	          _this.showResultFields();

	          _this.$fieldSets.show();
	        }
	      });

	      defineProperty(assertThisInitialized(assertThisInitialized(_this)), "onAfdManualInputButtonClick", function () {
	        var controlType = _this.controlType;

	        _this.$manualInputButton.hide();

	        _this.$manualInputSearchButton.show();

	        if (controlType === 'typeahead') {
	          _this.$typeaheadFieldandLabel.hide();
	        } else {
	          _this.$lookupButton.hide();
	        }

	        _this.showResultFields();

	        if (_this.options[controlType].fieldSets.length > 0) {
	          for (var i = 0; i < _this.options[controlType].fieldSets.length; i++) {
	            $(_this.options[controlType].fieldSets[i]).show();
	          }
	        }
	      });

	      defineProperty(assertThisInitialized(assertThisInitialized(_this)), "onAfdManualInputSearchButtonClick", function () {
	        var controlType = _this.controlType;

	        if (controlType === 'typeahead') {
	          _this.$typeaheadFieldandLabel.show();
	        } else if (controlType === 'lookup') {
	          _this.$lookupButton.show();
	        }

	        _this.$manualInputButton.show();

	        _this.$manualInputSearchButton.hide();

	        _this.hideResultFields(_this.country);

	        _this.$fieldSets.hide();
	      });

	      defineProperty(assertThisInitialized(assertThisInitialized(_this)), "onCustomCountryChange", function () {
	        var country = _this.$customCountryField.val();

	        if (_this.options.country.customCountryConverter) {
	          if (typeof _this.options.country.customCountryConverter !== 'function') {
	            throw 'customCountryConverter Must be a function';
	          }

	          country = _this.options.country.customCountryConverter(country);
	        }

	        $(document).trigger('afd:countryChanged', [country]);
	      });

	      defineProperty(assertThisInitialized(assertThisInitialized(_this)), "onCountryChanged", function (e, country) {
	        _this.country = country;

	        _this.handleHideShowControls(country);
	      });

	      defineProperty(assertThisInitialized(assertThisInitialized(_this)), "handleHideShowControls", function (country) {
	        var controlType = _this.controlType;

	        _this.$searchAgainButton.hide();

	        if (_this.options[controlType].hideForCountries.length > 0) {
	          if (_this.options[controlType].hideForCountries.indexOf(country) > -1) {
	            _this.hideControls(controlType);
	          } else {
	            _this.showControls(controlType);
	          }
	        }

	        if (_this.options[controlType].showForCountries.length > 0) {
	          if (_this.options[controlType].showForCountries.indexOf(country) > -1) {
	            _this.showControls(controlType);

	            if (_this.options[controlType].beforeHideResults) {
	              _this.$manualInputButton.show();

	              _this.hideResultFields(country);

	              _this.$fieldSets.hide();
	            } else {
	              _this.$manualInputButton.hide();

	              _this.showResultFields();

	              _this.$fieldSets.show();
	            }
	          } else {
	            _this.hideControls(controlType);

	            _this.showResultFields();
	          }
	        }

	        if (_this.options[controlType].hideForCountries.length === 0 && _this.options[controlType].showForCountries.length === 0) {
	          _this.showControls(controlType);
	        }
	      });

	      defineProperty(assertThisInitialized(assertThisInitialized(_this)), "showControls", function (controlType) {
	        if (controlType === 'lookup') {
	          _this.$lookupButton.closest('.afd-form-control').show();

	          _this.$lookupField.closest('.afd-form-control').show();
	        } else {
	          _this.$typeaheadFieldandLabel.show();
	        }

	        if (_this.options[controlType].manualInputButton) {
	          _this.$manualInputButton.show();
	        }
	      });

	      defineProperty(assertThisInitialized(assertThisInitialized(_this)), "hideControls", function (controlType) {
	        if (controlType === 'lookup') {
	          _this.$lookupButton.closest('.afd-form-control').hide();

	          _this.$lookupField.closest('.afd-form-control').hide();

	          _this.$resultList.closest('.afd-form-control').hide();
	        } else {
	          _this.$typeaheadFieldandLabel.hide();
	        }

	        _this.$manualInputButton.hide();
	      });

	      defineProperty(assertThisInitialized(assertThisInitialized(_this)), "getInitialCountry", function () {
	        var country = null;

	        if (_this.$customCountryField) {
	          country = _this.$customCountryField.val();

	          if (_this.options.country.customCountryConverter) {
	            if (typeof _this.options.country.customCountryConverter !== 'function') {
	              throw 'customCountryConverter Must be a function';
	            }

	            country = _this.options.country.customCountryConverter(country);
	          }

	          _this.handleHideShowControls(country);
	        } else if (_this.options.country.defaultCountry) {
	          country = _this.options.country.defaultCountry;

	          _this.handleHideShowControls(_this.options.country.defaultCountry);
	        } else if (_this.options.defaultCountry) {
	          country = _this.options.defaultCountry;

	          _this.handleHideShowControls(_this.options.defaultCountry);
	        }

	        return country;
	      });

	      defineProperty(assertThisInitialized(assertThisInitialized(_this)), "handlePushUp", function (fields, fieldName, $el) {
	        //get index of current field in array
	        var index = fields.indexOf(fieldName); // if this field is not involved in pushup manipulation

	        if (index === -1) {
	          $el.val(_this.result[fieldName]);
	          return;
	        } // create an array that contains the populated fields


	        var populatedFields = [];

	        for (var i = 0; i < fields.length; i++) {
	          if (_this.result[fields[i]].length > 0) {
	            populatedFields.push(_this.result[fields[i]]);
	          }
	        }

	        $el.val(populatedFields[index]);
	      });

	      return _this;
	    } // logic for identifying each different lookup so that old ones can be discarded if they come in too late


	    return _temp;
	  }(Base), _temp;
	};

	/**
	 * jQuery.browser.mobile (http://detectmobilebrowser.com/)
	 *
	 * jQuery.browser.mobile will be true if the browser is a mobile device
	 *
	 **/

	(function (a) {
	  (jQuery.browser = jQuery.browser || {}).mobile = /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0, 4));
	})(navigator.userAgent || navigator.vendor || window.opera);

	var AfdReverseGeocode =
	/*#__PURE__*/
	function (_addressToolsMixin) {
	  inherits(AfdReverseGeocode, _addressToolsMixin);

	  function AfdReverseGeocode($button, $result, options) {
	    var _this;

	    classCallCheck(this, AfdReverseGeocode);

	    _this = possibleConstructorReturn(this, getPrototypeOf(AfdReverseGeocode).call(this, $button, options)); // specifying controlType is important for the options that the addressTools Mixin uses

	    defineProperty(assertThisInitialized(assertThisInitialized(_this)), "init", function () {
	      // hide result element by default
	      _this.hideResultsElement(_this.$resultList, _this.options); // events


	      var event = _this.eventHandler;
	      event(_this.$button, 'click', _this.onButtonClick);
	      event($(document), 'afd:initFields', _this.onAfdInitFields);
	      event($(document), 'afd:countryChanged', _this.onAfdCountryChanged);
	      event(_this.$resultList, 'keydown', _this.onKeyDownResult);
	      event(_this.$resultList, 'keyup', _this.onKeyUpResult);
	      event(_this.$resultList, 'change', _this.onChangeResult);

	      if (!$.browser.mobile && _this.options.reverseGeocode.hideOnDesktop) {
	        if (_this.options.buttonContainer) {
	          _this.$button.closest(_this.options.buttonContainer).hide();
	        } else {
	          _this.$button.hide();
	        }
	      }

	      try {
	        _this.initFields();
	      } catch (err) {
	        console.error('Error initisalising reverseGeocode controls');
	        console.error(err);
	      }
	    });

	    defineProperty(assertThisInitialized(assertThisInitialized(_this)), "setupReverseGeocodeRequestOptions", function (lng, lat) {
	      _this.requestOptions = _this.setupParams({
	        data: 'address',
	        fields: _this.options.reverseGeocode.postcodeFirst ? 'list' : 'fflist',
	        task: 'nearest',
	        maxquantity: _this.options.reverseGeocode.maxItems,
	        longitude: lng,
	        latitude: lat
	      });
	    });

	    defineProperty(assertThisInitialized(assertThisInitialized(_this)), "onAfdCountryChanged", function (e, country) {
	      _this.typeaheadOptions.source.lookup.ajax.data.countryiso = country;
	    });

	    defineProperty(assertThisInitialized(assertThisInitialized(_this)), "onAfdInitFields", function () {
	      // in case the elements were loaded after initialisation redeclare variables
	      _this.setFields();

	      _this.handleMultiForms();
	    });

	    defineProperty(assertThisInitialized(assertThisInitialized(_this)), "onButtonClick", function (e) {
	      navigator.geolocation.getCurrentPosition(function (position) {
	        _this.setupReverseGeocodeRequestOptions(position.coords.longitude, position.coords.latitude);

	        $.ajax(_this.requestOptions).then(function (res) {
	          _this.results = res.Item;

	          _this.populateResultsList();
	        });
	      });
	    });

	    _this.controlType = 'reverseGeocode';
	    _this.$button = $button;
	    _this.$resultList = $result; // set all the correct vars

	    _this.setFields();

	    _this.handleMultiForms();

	    return _this;
	  }

	  return AfdReverseGeocode;
	}(addressToolsMixin(AfdControl));

	function initReverseGeocode () {

	  var options = $.extend(true, {}, defaults, afdOptions); // assign button

	  var $button = $(this); // find out whether or not there is a container in which all elements should be present

	  var $containerScope = options.reverseGeocode.containers.length === 0 ? $(document) : $button.closest(afdOptions.reverseGeocode.containers); // Validate that there is only one button in container scope

	  if ($containerScope.find('[data-afd-control="reverseGeocodeButton"]').length > 1) {
	    throw 'More than one instance of `reverseGeocodeButton` detected.  If these are in separate containers please define the containers in `afdOptions.reverseGeocode.containers';
	  } // Validate that button is either <a> or <button>


	  if (!$button.is('a, button')) {
	    throw '<' + $button.prop('tagName').toLowerCase() + '> is not a valid tag for `reverseGeocodeButton`, use either <a> or <button>';
	  } // assign result


	  var $result = $containerScope.find('[data-afd-control="reverseGeocodeResultsList"]'); // Validate that there is only one result in container scope

	  var resultCount = $containerScope.find('[data-afd-control="reverseGeocodeResultsList"]').length;

	  if (resultCount === 0) {
	    throw 'Could not find an instance of `reverseGeocodeResultsList`.  If afdoptions.reverseGeocode.containers is set have you included the results list inside the supplied container?';
	  } else if (resultCount > 1) {
	    throw 'More than one instance of `reverseGeocodeResultsList` found';
	  } // Validate that result is <select>


	  if (!$result.is('select, ul')) {
	    throw '<' + $result.prop('tagName').toLowerCase() + '> is not a valid tag for `reverseGeocodeResultsList`, use <select> or <ul>';
	  } // initialise the control


	  var reverseGeocode = new AfdReverseGeocode($button, $result, options);
	  $(document).off('afd:init.afd').on('afd:init.afd', function () {
	    reverseGeocode.init();
	  });
	  reverseGeocode.init();
	}

	var _iterStep = function (done, value) {
	  return { value: value, done: !!done };
	};

	var _iterators = {};

	// to indexed object, toObject with fallback for non-array-like ES3 strings


	var _toIobject = function (it) {
	  return _iobject(_defined(it));
	};

	var max = Math.max;
	var min$1 = Math.min;
	var _toAbsoluteIndex = function (index, length) {
	  index = _toInteger(index);
	  return index < 0 ? max(index + length, 0) : min$1(index, length);
	};

	// false -> Array#indexOf
	// true  -> Array#includes



	var _arrayIncludes = function (IS_INCLUDES) {
	  return function ($this, el, fromIndex) {
	    var O = _toIobject($this);
	    var length = _toLength(O.length);
	    var index = _toAbsoluteIndex(fromIndex, length);
	    var value;
	    // Array#includes uses SameValueZero equality algorithm
	    // eslint-disable-next-line no-self-compare
	    if (IS_INCLUDES && el != el) while (length > index) {
	      value = O[index++];
	      // eslint-disable-next-line no-self-compare
	      if (value != value) return true;
	    // Array#indexOf ignores holes, Array#includes - not
	    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
	      if (O[index] === el) return IS_INCLUDES || index || 0;
	    } return !IS_INCLUDES && -1;
	  };
	};

	var shared = _shared('keys');

	var _sharedKey = function (key) {
	  return shared[key] || (shared[key] = _uid(key));
	};

	var arrayIndexOf = _arrayIncludes(false);
	var IE_PROTO = _sharedKey('IE_PROTO');

	var _objectKeysInternal = function (object, names) {
	  var O = _toIobject(object);
	  var i = 0;
	  var result = [];
	  var key;
	  for (key in O) if (key != IE_PROTO) _has(O, key) && result.push(key);
	  // Don't enum bug & hidden keys
	  while (names.length > i) if (_has(O, key = names[i++])) {
	    ~arrayIndexOf(result, key) || result.push(key);
	  }
	  return result;
	};

	// IE 8- don't enum bug keys
	var _enumBugKeys = (
	  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
	).split(',');

	// 19.1.2.14 / 15.2.3.14 Object.keys(O)



	var _objectKeys = Object.keys || function keys(O) {
	  return _objectKeysInternal(O, _enumBugKeys);
	};

	var _objectDps = _descriptors ? Object.defineProperties : function defineProperties(O, Properties) {
	  _anObject(O);
	  var keys = _objectKeys(Properties);
	  var length = keys.length;
	  var i = 0;
	  var P;
	  while (length > i) _objectDp.f(O, P = keys[i++], Properties[P]);
	  return O;
	};

	var document$2 = _global.document;
	var _html = document$2 && document$2.documentElement;

	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])



	var IE_PROTO$1 = _sharedKey('IE_PROTO');
	var Empty = function () { /* empty */ };
	var PROTOTYPE$1 = 'prototype';

	// Create object with fake `null` prototype: use iframe Object with cleared prototype
	var createDict = function () {
	  // Thrash, waste and sodomy: IE GC bug
	  var iframe = _domCreate('iframe');
	  var i = _enumBugKeys.length;
	  var lt = '<';
	  var gt = '>';
	  var iframeDocument;
	  iframe.style.display = 'none';
	  _html.appendChild(iframe);
	  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
	  // createDict = iframe.contentWindow.Object;
	  // html.removeChild(iframe);
	  iframeDocument = iframe.contentWindow.document;
	  iframeDocument.open();
	  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
	  iframeDocument.close();
	  createDict = iframeDocument.F;
	  while (i--) delete createDict[PROTOTYPE$1][_enumBugKeys[i]];
	  return createDict();
	};

	var _objectCreate = Object.create || function create(O, Properties) {
	  var result;
	  if (O !== null) {
	    Empty[PROTOTYPE$1] = _anObject(O);
	    result = new Empty();
	    Empty[PROTOTYPE$1] = null;
	    // add "__proto__" for Object.getPrototypeOf polyfill
	    result[IE_PROTO$1] = O;
	  } else result = createDict();
	  return Properties === undefined ? result : _objectDps(result, Properties);
	};

	var def = _objectDp.f;

	var TAG = _wks('toStringTag');

	var _setToStringTag = function (it, tag, stat) {
	  if (it && !_has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
	};

	var IteratorPrototype = {};

	// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
	_hide(IteratorPrototype, _wks('iterator'), function () { return this; });

	var _iterCreate = function (Constructor, NAME, next) {
	  Constructor.prototype = _objectCreate(IteratorPrototype, { next: _propertyDesc(1, next) });
	  _setToStringTag(Constructor, NAME + ' Iterator');
	};

	// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)


	var IE_PROTO$2 = _sharedKey('IE_PROTO');
	var ObjectProto = Object.prototype;

	var _objectGpo = Object.getPrototypeOf || function (O) {
	  O = _toObject(O);
	  if (_has(O, IE_PROTO$2)) return O[IE_PROTO$2];
	  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
	    return O.constructor.prototype;
	  } return O instanceof Object ? ObjectProto : null;
	};

	var ITERATOR = _wks('iterator');
	var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
	var FF_ITERATOR = '@@iterator';
	var KEYS = 'keys';
	var VALUES = 'values';

	var returnThis = function () { return this; };

	var _iterDefine = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
	  _iterCreate(Constructor, NAME, next);
	  var getMethod = function (kind) {
	    if (!BUGGY && kind in proto) return proto[kind];
	    switch (kind) {
	      case KEYS: return function keys() { return new Constructor(this, kind); };
	      case VALUES: return function values() { return new Constructor(this, kind); };
	    } return function entries() { return new Constructor(this, kind); };
	  };
	  var TAG = NAME + ' Iterator';
	  var DEF_VALUES = DEFAULT == VALUES;
	  var VALUES_BUG = false;
	  var proto = Base.prototype;
	  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
	  var $default = $native || getMethod(DEFAULT);
	  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
	  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
	  var methods, key, IteratorPrototype;
	  // Fix native
	  if ($anyNative) {
	    IteratorPrototype = _objectGpo($anyNative.call(new Base()));
	    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
	      // Set @@toStringTag to native iterators
	      _setToStringTag(IteratorPrototype, TAG, true);
	      // fix for some old engines
	      if (!_library && typeof IteratorPrototype[ITERATOR] != 'function') _hide(IteratorPrototype, ITERATOR, returnThis);
	    }
	  }
	  // fix Array#{values, @@iterator}.name in V8 / FF
	  if (DEF_VALUES && $native && $native.name !== VALUES) {
	    VALUES_BUG = true;
	    $default = function values() { return $native.call(this); };
	  }
	  // Define iterator
	  if ((!_library || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
	    _hide(proto, ITERATOR, $default);
	  }
	  // Plug for library
	  _iterators[NAME] = $default;
	  _iterators[TAG] = returnThis;
	  if (DEFAULT) {
	    methods = {
	      values: DEF_VALUES ? $default : getMethod(VALUES),
	      keys: IS_SET ? $default : getMethod(KEYS),
	      entries: $entries
	    };
	    if (FORCED) for (key in methods) {
	      if (!(key in proto)) _redefine(proto, key, methods[key]);
	    } else _export(_export.P + _export.F * (BUGGY || VALUES_BUG), NAME, methods);
	  }
	  return methods;
	};

	// 22.1.3.4 Array.prototype.entries()
	// 22.1.3.13 Array.prototype.keys()
	// 22.1.3.29 Array.prototype.values()
	// 22.1.3.30 Array.prototype[@@iterator]()
	var es6_array_iterator = _iterDefine(Array, 'Array', function (iterated, kind) {
	  this._t = _toIobject(iterated); // target
	  this._i = 0;                   // next index
	  this._k = kind;                // kind
	// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
	}, function () {
	  var O = this._t;
	  var kind = this._k;
	  var index = this._i++;
	  if (!O || index >= O.length) {
	    this._t = undefined;
	    return _iterStep(1);
	  }
	  if (kind == 'keys') return _iterStep(0, index);
	  if (kind == 'values') return _iterStep(0, O[index]);
	  return _iterStep(0, [index, O[index]]);
	}, 'values');

	// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
	_iterators.Arguments = _iterators.Array;

	_addToUnscopables('keys');
	_addToUnscopables('values');
	_addToUnscopables('entries');

	var ITERATOR$1 = _wks('iterator');
	var TO_STRING_TAG = _wks('toStringTag');
	var ArrayValues = _iterators.Array;

	var DOMIterables = {
	  CSSRuleList: true, // TODO: Not spec compliant, should be false.
	  CSSStyleDeclaration: false,
	  CSSValueList: false,
	  ClientRectList: false,
	  DOMRectList: false,
	  DOMStringList: false,
	  DOMTokenList: true,
	  DataTransferItemList: false,
	  FileList: false,
	  HTMLAllCollection: false,
	  HTMLCollection: false,
	  HTMLFormElement: false,
	  HTMLSelectElement: false,
	  MediaList: true, // TODO: Not spec compliant, should be false.
	  MimeTypeArray: false,
	  NamedNodeMap: false,
	  NodeList: true,
	  PaintRequestList: false,
	  Plugin: false,
	  PluginArray: false,
	  SVGLengthList: false,
	  SVGNumberList: false,
	  SVGPathSegList: false,
	  SVGPointList: false,
	  SVGStringList: false,
	  SVGTransformList: false,
	  SourceBufferList: false,
	  StyleSheetList: true, // TODO: Not spec compliant, should be false.
	  TextTrackCueList: false,
	  TextTrackList: false,
	  TouchList: false
	};

	for (var collections = _objectKeys(DOMIterables), i = 0; i < collections.length; i++) {
	  var NAME = collections[i];
	  var explicit = DOMIterables[NAME];
	  var Collection = _global[NAME];
	  var proto = Collection && Collection.prototype;
	  var key;
	  if (proto) {
	    if (!proto[ITERATOR$1]) _hide(proto, ITERATOR$1, ArrayValues);
	    if (!proto[TO_STRING_TAG]) _hide(proto, TO_STRING_TAG, NAME);
	    _iterators[NAME] = ArrayValues;
	    if (explicit) for (key in es6_array_iterator) if (!proto[key]) _redefine(proto, key, es6_array_iterator[key], true);
	  }
	}

	// getting tag from 19.1.3.6 Object.prototype.toString()

	var TAG$1 = _wks('toStringTag');
	// ES3 wrong here
	var ARG = _cof(function () { return arguments; }()) == 'Arguments';

	// fallback for IE11 Script Access Denied error
	var tryGet = function (it, key) {
	  try {
	    return it[key];
	  } catch (e) { /* empty */ }
	};

	var _classof = function (it) {
	  var O, T, B;
	  return it === undefined ? 'Undefined' : it === null ? 'Null'
	    // @@toStringTag case
	    : typeof (T = tryGet(O = Object(it), TAG$1)) == 'string' ? T
	    // builtinTag case
	    : ARG ? _cof(O)
	    // ES3 arguments fallback
	    : (B = _cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
	};

	var _anInstance = function (it, Constructor, name, forbiddenField) {
	  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
	    throw TypeError(name + ': incorrect invocation!');
	  } return it;
	};

	// call something on iterator step with safe closing on error

	var _iterCall = function (iterator, fn, value, entries) {
	  try {
	    return entries ? fn(_anObject(value)[0], value[1]) : fn(value);
	  // 7.4.6 IteratorClose(iterator, completion)
	  } catch (e) {
	    var ret = iterator['return'];
	    if (ret !== undefined) _anObject(ret.call(iterator));
	    throw e;
	  }
	};

	// check on default Array iterator

	var ITERATOR$2 = _wks('iterator');
	var ArrayProto$1 = Array.prototype;

	var _isArrayIter = function (it) {
	  return it !== undefined && (_iterators.Array === it || ArrayProto$1[ITERATOR$2] === it);
	};

	var ITERATOR$3 = _wks('iterator');

	var core_getIteratorMethod = _core.getIteratorMethod = function (it) {
	  if (it != undefined) return it[ITERATOR$3]
	    || it['@@iterator']
	    || _iterators[_classof(it)];
	};

	var _forOf = createCommonjsModule(function (module) {
	var BREAK = {};
	var RETURN = {};
	var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
	  var iterFn = ITERATOR ? function () { return iterable; } : core_getIteratorMethod(iterable);
	  var f = _ctx(fn, that, entries ? 2 : 1);
	  var index = 0;
	  var length, step, iterator, result;
	  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
	  // fast case for arrays with default iterator
	  if (_isArrayIter(iterFn)) for (length = _toLength(iterable.length); length > index; index++) {
	    result = entries ? f(_anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
	    if (result === BREAK || result === RETURN) return result;
	  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
	    result = _iterCall(iterator, f, step.value, entries);
	    if (result === BREAK || result === RETURN) return result;
	  }
	};
	exports.BREAK = BREAK;
	exports.RETURN = RETURN;
	});

	// 7.3.20 SpeciesConstructor(O, defaultConstructor)


	var SPECIES$1 = _wks('species');
	var _speciesConstructor = function (O, D) {
	  var C = _anObject(O).constructor;
	  var S;
	  return C === undefined || (S = _anObject(C)[SPECIES$1]) == undefined ? D : _aFunction(S);
	};

	// fast apply, http://jsperf.lnkit.com/fast-apply/5
	var _invoke = function (fn, args, that) {
	  var un = that === undefined;
	  switch (args.length) {
	    case 0: return un ? fn()
	                      : fn.call(that);
	    case 1: return un ? fn(args[0])
	                      : fn.call(that, args[0]);
	    case 2: return un ? fn(args[0], args[1])
	                      : fn.call(that, args[0], args[1]);
	    case 3: return un ? fn(args[0], args[1], args[2])
	                      : fn.call(that, args[0], args[1], args[2]);
	    case 4: return un ? fn(args[0], args[1], args[2], args[3])
	                      : fn.call(that, args[0], args[1], args[2], args[3]);
	  } return fn.apply(that, args);
	};

	var process = _global.process;
	var setTask = _global.setImmediate;
	var clearTask = _global.clearImmediate;
	var MessageChannel = _global.MessageChannel;
	var Dispatch = _global.Dispatch;
	var counter = 0;
	var queue = {};
	var ONREADYSTATECHANGE = 'onreadystatechange';
	var defer, channel, port;
	var run = function () {
	  var id = +this;
	  // eslint-disable-next-line no-prototype-builtins
	  if (queue.hasOwnProperty(id)) {
	    var fn = queue[id];
	    delete queue[id];
	    fn();
	  }
	};
	var listener = function (event) {
	  run.call(event.data);
	};
	// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
	if (!setTask || !clearTask) {
	  setTask = function setImmediate(fn) {
	    var args = [];
	    var i = 1;
	    while (arguments.length > i) args.push(arguments[i++]);
	    queue[++counter] = function () {
	      // eslint-disable-next-line no-new-func
	      _invoke(typeof fn == 'function' ? fn : Function(fn), args);
	    };
	    defer(counter);
	    return counter;
	  };
	  clearTask = function clearImmediate(id) {
	    delete queue[id];
	  };
	  // Node.js 0.8-
	  if (_cof(process) == 'process') {
	    defer = function (id) {
	      process.nextTick(_ctx(run, id, 1));
	    };
	  // Sphere (JS game engine) Dispatch API
	  } else if (Dispatch && Dispatch.now) {
	    defer = function (id) {
	      Dispatch.now(_ctx(run, id, 1));
	    };
	  // Browsers with MessageChannel, includes WebWorkers
	  } else if (MessageChannel) {
	    channel = new MessageChannel();
	    port = channel.port2;
	    channel.port1.onmessage = listener;
	    defer = _ctx(port.postMessage, port, 1);
	  // Browsers with postMessage, skip WebWorkers
	  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
	  } else if (_global.addEventListener && typeof postMessage == 'function' && !_global.importScripts) {
	    defer = function (id) {
	      _global.postMessage(id + '', '*');
	    };
	    _global.addEventListener('message', listener, false);
	  // IE8-
	  } else if (ONREADYSTATECHANGE in _domCreate('script')) {
	    defer = function (id) {
	      _html.appendChild(_domCreate('script'))[ONREADYSTATECHANGE] = function () {
	        _html.removeChild(this);
	        run.call(id);
	      };
	    };
	  // Rest old browsers
	  } else {
	    defer = function (id) {
	      setTimeout(_ctx(run, id, 1), 0);
	    };
	  }
	}
	var _task = {
	  set: setTask,
	  clear: clearTask
	};

	var macrotask = _task.set;
	var Observer = _global.MutationObserver || _global.WebKitMutationObserver;
	var process$1 = _global.process;
	var Promise$1 = _global.Promise;
	var isNode = _cof(process$1) == 'process';

	var _microtask = function () {
	  var head, last, notify;

	  var flush = function () {
	    var parent, fn;
	    if (isNode && (parent = process$1.domain)) parent.exit();
	    while (head) {
	      fn = head.fn;
	      head = head.next;
	      try {
	        fn();
	      } catch (e) {
	        if (head) notify();
	        else last = undefined;
	        throw e;
	      }
	    } last = undefined;
	    if (parent) parent.enter();
	  };

	  // Node.js
	  if (isNode) {
	    notify = function () {
	      process$1.nextTick(flush);
	    };
	  // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339
	  } else if (Observer && !(_global.navigator && _global.navigator.standalone)) {
	    var toggle = true;
	    var node = document.createTextNode('');
	    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
	    notify = function () {
	      node.data = toggle = !toggle;
	    };
	  // environments with maybe non-completely correct, but existent Promise
	  } else if (Promise$1 && Promise$1.resolve) {
	    // Promise.resolve without an argument throws an error in LG WebOS 2
	    var promise = Promise$1.resolve(undefined);
	    notify = function () {
	      promise.then(flush);
	    };
	  // for other environments - macrotask based on:
	  // - setImmediate
	  // - MessageChannel
	  // - window.postMessag
	  // - onreadystatechange
	  // - setTimeout
	  } else {
	    notify = function () {
	      // strange IE + webpack dev server bug - use .call(global)
	      macrotask.call(_global, flush);
	    };
	  }

	  return function (fn) {
	    var task = { fn: fn, next: undefined };
	    if (last) last.next = task;
	    if (!head) {
	      head = task;
	      notify();
	    } last = task;
	  };
	};

	// 25.4.1.5 NewPromiseCapability(C)


	function PromiseCapability(C) {
	  var resolve, reject;
	  this.promise = new C(function ($$resolve, $$reject) {
	    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
	    resolve = $$resolve;
	    reject = $$reject;
	  });
	  this.resolve = _aFunction(resolve);
	  this.reject = _aFunction(reject);
	}

	var f$1 = function (C) {
	  return new PromiseCapability(C);
	};

	var _newPromiseCapability = {
		f: f$1
	};

	var _perform = function (exec) {
	  try {
	    return { e: false, v: exec() };
	  } catch (e) {
	    return { e: true, v: e };
	  }
	};

	var navigator$1 = _global.navigator;

	var _userAgent = navigator$1 && navigator$1.userAgent || '';

	var _promiseResolve = function (C, x) {
	  _anObject(C);
	  if (_isObject(x) && x.constructor === C) return x;
	  var promiseCapability = _newPromiseCapability.f(C);
	  var resolve = promiseCapability.resolve;
	  resolve(x);
	  return promiseCapability.promise;
	};

	var _redefineAll = function (target, src, safe) {
	  for (var key in src) _redefine(target, key, src[key], safe);
	  return target;
	};

	var SPECIES$2 = _wks('species');

	var _setSpecies = function (KEY) {
	  var C = _global[KEY];
	  if (_descriptors && C && !C[SPECIES$2]) _objectDp.f(C, SPECIES$2, {
	    configurable: true,
	    get: function () { return this; }
	  });
	};

	var ITERATOR$4 = _wks('iterator');
	var SAFE_CLOSING = false;

	try {
	  var riter = [7][ITERATOR$4]();
	  riter['return'] = function () { SAFE_CLOSING = true; };
	} catch (e) { /* empty */ }

	var _iterDetect = function (exec, skipClosing) {
	  if (!skipClosing && !SAFE_CLOSING) return false;
	  var safe = false;
	  try {
	    var arr = [7];
	    var iter = arr[ITERATOR$4]();
	    iter.next = function () { return { done: safe = true }; };
	    arr[ITERATOR$4] = function () { return iter; };
	    exec(arr);
	  } catch (e) { /* empty */ }
	  return safe;
	};

	var task = _task.set;
	var microtask = _microtask();




	var PROMISE = 'Promise';
	var TypeError$1 = _global.TypeError;
	var process$2 = _global.process;
	var versions = process$2 && process$2.versions;
	var v8 = versions && versions.v8 || '';
	var $Promise = _global[PROMISE];
	var isNode$1 = _classof(process$2) == 'process';
	var empty = function () { /* empty */ };
	var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
	var newPromiseCapability = newGenericPromiseCapability = _newPromiseCapability.f;

	var USE_NATIVE = !!function () {
	  try {
	    // correct subclassing with @@species support
	    var promise = $Promise.resolve(1);
	    var FakePromise = (promise.constructor = {})[_wks('species')] = function (exec) {
	      exec(empty, empty);
	    };
	    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
	    return (isNode$1 || typeof PromiseRejectionEvent == 'function')
	      && promise.then(empty) instanceof FakePromise
	      // v8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
	      // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
	      // we can't detect it synchronously, so just check versions
	      && v8.indexOf('6.6') !== 0
	      && _userAgent.indexOf('Chrome/66') === -1;
	  } catch (e) { /* empty */ }
	}();

	// helpers
	var isThenable = function (it) {
	  var then;
	  return _isObject(it) && typeof (then = it.then) == 'function' ? then : false;
	};
	var notify = function (promise, isReject) {
	  if (promise._n) return;
	  promise._n = true;
	  var chain = promise._c;
	  microtask(function () {
	    var value = promise._v;
	    var ok = promise._s == 1;
	    var i = 0;
	    var run = function (reaction) {
	      var handler = ok ? reaction.ok : reaction.fail;
	      var resolve = reaction.resolve;
	      var reject = reaction.reject;
	      var domain = reaction.domain;
	      var result, then, exited;
	      try {
	        if (handler) {
	          if (!ok) {
	            if (promise._h == 2) onHandleUnhandled(promise);
	            promise._h = 1;
	          }
	          if (handler === true) result = value;
	          else {
	            if (domain) domain.enter();
	            result = handler(value); // may throw
	            if (domain) {
	              domain.exit();
	              exited = true;
	            }
	          }
	          if (result === reaction.promise) {
	            reject(TypeError$1('Promise-chain cycle'));
	          } else if (then = isThenable(result)) {
	            then.call(result, resolve, reject);
	          } else resolve(result);
	        } else reject(value);
	      } catch (e) {
	        if (domain && !exited) domain.exit();
	        reject(e);
	      }
	    };
	    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach
	    promise._c = [];
	    promise._n = false;
	    if (isReject && !promise._h) onUnhandled(promise);
	  });
	};
	var onUnhandled = function (promise) {
	  task.call(_global, function () {
	    var value = promise._v;
	    var unhandled = isUnhandled(promise);
	    var result, handler, console;
	    if (unhandled) {
	      result = _perform(function () {
	        if (isNode$1) {
	          process$2.emit('unhandledRejection', value, promise);
	        } else if (handler = _global.onunhandledrejection) {
	          handler({ promise: promise, reason: value });
	        } else if ((console = _global.console) && console.error) {
	          console.error('Unhandled promise rejection', value);
	        }
	      });
	      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
	      promise._h = isNode$1 || isUnhandled(promise) ? 2 : 1;
	    } promise._a = undefined;
	    if (unhandled && result.e) throw result.v;
	  });
	};
	var isUnhandled = function (promise) {
	  return promise._h !== 1 && (promise._a || promise._c).length === 0;
	};
	var onHandleUnhandled = function (promise) {
	  task.call(_global, function () {
	    var handler;
	    if (isNode$1) {
	      process$2.emit('rejectionHandled', promise);
	    } else if (handler = _global.onrejectionhandled) {
	      handler({ promise: promise, reason: promise._v });
	    }
	  });
	};
	var $reject = function (value) {
	  var promise = this;
	  if (promise._d) return;
	  promise._d = true;
	  promise = promise._w || promise; // unwrap
	  promise._v = value;
	  promise._s = 2;
	  if (!promise._a) promise._a = promise._c.slice();
	  notify(promise, true);
	};
	var $resolve = function (value) {
	  var promise = this;
	  var then;
	  if (promise._d) return;
	  promise._d = true;
	  promise = promise._w || promise; // unwrap
	  try {
	    if (promise === value) throw TypeError$1("Promise can't be resolved itself");
	    if (then = isThenable(value)) {
	      microtask(function () {
	        var wrapper = { _w: promise, _d: false }; // wrap
	        try {
	          then.call(value, _ctx($resolve, wrapper, 1), _ctx($reject, wrapper, 1));
	        } catch (e) {
	          $reject.call(wrapper, e);
	        }
	      });
	    } else {
	      promise._v = value;
	      promise._s = 1;
	      notify(promise, false);
	    }
	  } catch (e) {
	    $reject.call({ _w: promise, _d: false }, e); // wrap
	  }
	};

	// constructor polyfill
	if (!USE_NATIVE) {
	  // 25.4.3.1 Promise(executor)
	  $Promise = function Promise(executor) {
	    _anInstance(this, $Promise, PROMISE, '_h');
	    _aFunction(executor);
	    Internal.call(this);
	    try {
	      executor(_ctx($resolve, this, 1), _ctx($reject, this, 1));
	    } catch (err) {
	      $reject.call(this, err);
	    }
	  };
	  // eslint-disable-next-line no-unused-vars
	  Internal = function Promise(executor) {
	    this._c = [];             // <- awaiting reactions
	    this._a = undefined;      // <- checked in isUnhandled reactions
	    this._s = 0;              // <- state
	    this._d = false;          // <- done
	    this._v = undefined;      // <- value
	    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
	    this._n = false;          // <- notify
	  };
	  Internal.prototype = _redefineAll($Promise.prototype, {
	    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
	    then: function then(onFulfilled, onRejected) {
	      var reaction = newPromiseCapability(_speciesConstructor(this, $Promise));
	      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
	      reaction.fail = typeof onRejected == 'function' && onRejected;
	      reaction.domain = isNode$1 ? process$2.domain : undefined;
	      this._c.push(reaction);
	      if (this._a) this._a.push(reaction);
	      if (this._s) notify(this, false);
	      return reaction.promise;
	    },
	    // 25.4.5.1 Promise.prototype.catch(onRejected)
	    'catch': function (onRejected) {
	      return this.then(undefined, onRejected);
	    }
	  });
	  OwnPromiseCapability = function () {
	    var promise = new Internal();
	    this.promise = promise;
	    this.resolve = _ctx($resolve, promise, 1);
	    this.reject = _ctx($reject, promise, 1);
	  };
	  _newPromiseCapability.f = newPromiseCapability = function (C) {
	    return C === $Promise || C === Wrapper
	      ? new OwnPromiseCapability(C)
	      : newGenericPromiseCapability(C);
	  };
	}

	_export(_export.G + _export.W + _export.F * !USE_NATIVE, { Promise: $Promise });
	_setToStringTag($Promise, PROMISE);
	_setSpecies(PROMISE);
	Wrapper = _core[PROMISE];

	// statics
	_export(_export.S + _export.F * !USE_NATIVE, PROMISE, {
	  // 25.4.4.5 Promise.reject(r)
	  reject: function reject(r) {
	    var capability = newPromiseCapability(this);
	    var $$reject = capability.reject;
	    $$reject(r);
	    return capability.promise;
	  }
	});
	_export(_export.S + _export.F * (_library || !USE_NATIVE), PROMISE, {
	  // 25.4.4.6 Promise.resolve(x)
	  resolve: function resolve(x) {
	    return _promiseResolve(_library && this === Wrapper ? $Promise : this, x);
	  }
	});
	_export(_export.S + _export.F * !(USE_NATIVE && _iterDetect(function (iter) {
	  $Promise.all(iter)['catch'](empty);
	})), PROMISE, {
	  // 25.4.4.1 Promise.all(iterable)
	  all: function all(iterable) {
	    var C = this;
	    var capability = newPromiseCapability(C);
	    var resolve = capability.resolve;
	    var reject = capability.reject;
	    var result = _perform(function () {
	      var values = [];
	      var index = 0;
	      var remaining = 1;
	      _forOf(iterable, false, function (promise) {
	        var $index = index++;
	        var alreadyCalled = false;
	        values.push(undefined);
	        remaining++;
	        C.resolve(promise).then(function (value) {
	          if (alreadyCalled) return;
	          alreadyCalled = true;
	          values[$index] = value;
	          --remaining || resolve(values);
	        }, reject);
	      });
	      --remaining || resolve(values);
	    });
	    if (result.e) reject(result.v);
	    return capability.promise;
	  },
	  // 25.4.4.4 Promise.race(iterable)
	  race: function race(iterable) {
	    var C = this;
	    var capability = newPromiseCapability(C);
	    var reject = capability.reject;
	    var result = _perform(function () {
	      _forOf(iterable, false, function (promise) {
	        C.resolve(promise).then(capability.resolve, reject);
	      });
	    });
	    if (result.e) reject(result.v);
	    return capability.promise;
	  }
	});

	function dataDefinition() {
	  // prevent the init script from running several times if multiple modules are loaded
	  if (typeof window.afdDataInit === 'undefined') {
	    window.afdDataInit = false;
	  } // Data API definitions


	  $(document).ready(function () {
	    if (!window.afdDataInit) {
	      window.afdDataInit = true;
	      $(document).trigger('afd::page_ready');
	    }
	  }); // Set page_ready listener for data definitions

	  $(document).off('afd::page_ready').on('afd::page_ready', function () {
	    // Fields that need to perform ajax requests before the rest of the controls can be initialised
	    var dependantFields = ['country']; // create an array of promises for dependent requests

	    var dependantRequests = []; //First only initialise the controls that other controls are dependant on

	    $('[data-afd-control]').each(function () {
	      var $this = $(this);
	      var controlType = $this.data('afd-control'); // check if this is a control that needs to be initialised before the rest

	      if (dependantFields.indexOf(controlType) > -1) {
	        // add a new promise to the dependent requests array
	        dependantRequests.push(new Promise(function (resolve, reject) {
	          initialiseControl($this, controlType, resolve);
	        }));
	      }
	    }); // If there were dependant requests then once they have all completed we can intialise the rest of the controls

	    Promise.all(dependantRequests).then(function () {
	      // Only do non dependant controls
	      $('[data-afd-control]').each(function () {
	        var $this = $(this);
	        var controlType = $this.data('afd-control');

	        if (dependantFields.indexOf(controlType) === -1) {
	          initialiseControl($this, controlType, null);
	        }
	      });
	    });
	  });
	}

	function initialiseControl(control, controlType, resolve) {
	  // activate the module on this element according to the data-afd-control
	  try {
	    control.afd(controlType, resolve);
	  } catch (e) {
	    console.error(e);
	  }
	}

	window.afdInitScripts = typeof window.afdInitScripts === 'undefined' ? {
	  lookupButton: null,
	  typeahead: null,
	  reverseGeocodeButton: null,
	  account: null,
	  card: null,
	  email: null,
	  phone: null,
	  country: null
	} : window.afdInitScripts;
	window.afdInitScripts.lookupButton = typeof initLookup !== 'undefined' ? initLookup : window.afdInitScripts.lookupButton ? window.afdInitScripts.lookupButton : null;
	window.afdInitScripts.typeahead = typeof initTypeahead !== 'undefined' ? initTypeahead : window.afdInitScripts.typeahead ? window.afdInitScripts.typeahead : null;
	window.afdInitScripts.reverseGeocodeButton = typeof initReverseGeocode !== 'undefined' ? initReverseGeocode : window.afdInitScripts.reverseGeocodeButton ? window.afdInitScripts.reverseGeocodeButton : null;
	window.afdInitScripts.account = typeof initAccount !== 'undefined' ? initAccount : window.afdInitScripts.account ? window.afdInitScripts.account : null;
	window.afdInitScripts.card = typeof initCard !== 'undefined' ? initCard : window.afdInitScripts.card ? _typeof_1(window.afdInitScripts.card) : null;
	window.afdInitScripts.email = typeof initEmail !== 'undefined' ? initEmail : window.afdInitScripts.email ? window.afdInitScripts.email : null;
	window.afdInitScripts.phone = typeof initPhone !== 'undefined' ? initPhone : window.afdInitScripts.phone ? window.afdInitScripts.phone : null;
	window.afdInitScripts.country = typeof initCountry !== 'undefined' ? initCountry : window.afdInitScripts.country ? window.afdInitScripts.country : null;

	(function ($) {
	  // Init plugin so $('selector').afd('control-name') can work
	  $.fn.afd = function (controlType, resolve) {
	    return this.each(function () {
	      //fields that do not need to be initialised
	      var nonInitFields = ['lookupField', 'lookupResultsList', 'reverseGeocodeResultsList', 'sort', 'expiry'];

	      if (nonInitFields.indexOf(controlType) > -1) {
	        return;
	      } //If invalid field is supplied


	      var validFields = ['typeahead', 'lookupButton', 'country', 'reverseGeocodeButton', 'phone', 'email', 'account', 'card'];

	      if (validFields.indexOf(controlType) === -1) {
	        throw '`' + controlType + '` is not a valid AFD jQuery control.  Please use one of ' + validFields + ',' + nonInitFields;
	      } // if user is trying to init a field that module isn't loaded


	      if (!window.afdInitScripts[controlType]) {
	        throw 'You are trying to intitialise the control `' + controlType + '` but it seems that you have not loaded this module';
	      }

	      try {
	        window.afdInitScripts[controlType].call(this, controlType, resolve, constructor);
	      } catch (err) {
	        console.error('Problem initialising AFD Control');
	        console.error(err);
	      }
	    });
	  }; // Definitions for `data-afd-control=`


	  dataDefinition(); // If this is post render version

	  if (typeof postRender !== 'undefined') {
	    $(document).ready(function () {
	      $(document).trigger('afd::initPostRender');
	    });
	    $(document).on('afd::initPostRender', function () {
	      try {
	        if (typeof afdOptions.postRender === 'undefined') {
	          throw 'Post Render version of plugin used bit no post render options supplied';
	        }

	        postRender(afdOptions.postRender);
	        $(document).trigger('afd:postRenderInitComplete');
	      } catch (e) {
	        console.error(e);
	      }

	      $(document).trigger('afd::page_ready');
	    });
	  }
	})(jQuery$1);

})));
//# sourceMappingURL=afd.reverse.geocode.jquery.1.9.2.min.js.map
